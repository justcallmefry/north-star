
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Relationship
 * 
 */
export type Relationship = $Result.DefaultSelection<Prisma.$RelationshipPayload>
/**
 * Model RelationshipMember
 * 
 */
export type RelationshipMember = $Result.DefaultSelection<Prisma.$RelationshipMemberPayload>
/**
 * Model Invite
 * 
 */
export type Invite = $Result.DefaultSelection<Prisma.$InvitePayload>
/**
 * Model Prompt
 * 
 */
export type Prompt = $Result.DefaultSelection<Prisma.$PromptPayload>
/**
 * Model DailySession
 * 
 */
export type DailySession = $Result.DefaultSelection<Prisma.$DailySessionPayload>
/**
 * Model Response
 * 
 */
export type Response = $Result.DefaultSelection<Prisma.$ResponsePayload>
/**
 * Model ResponseValidation
 * 
 */
export type ResponseValidation = $Result.DefaultSelection<Prisma.$ResponseValidationPayload>
/**
 * Model Reflection
 * 
 */
export type Reflection = $Result.DefaultSelection<Prisma.$ReflectionPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model MeetingEntry
 * 
 */
export type MeetingEntry = $Result.DefaultSelection<Prisma.$MeetingEntryPayload>
/**
 * Model Streak
 * 
 */
export type Streak = $Result.DefaultSelection<Prisma.$StreakPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model BetaSignup
 * 
 */
export type BetaSignup = $Result.DefaultSelection<Prisma.$BetaSignupPayload>
/**
 * Model QuizSession
 * 
 */
export type QuizSession = $Result.DefaultSelection<Prisma.$QuizSessionPayload>
/**
 * Model QuizParticipation
 * 
 */
export type QuizParticipation = $Result.DefaultSelection<Prisma.$QuizParticipationPayload>
/**
 * Model AgreementSession
 * 
 */
export type AgreementSession = $Result.DefaultSelection<Prisma.$AgreementSessionPayload>
/**
 * Model AgreementParticipation
 * 
 */
export type AgreementParticipation = $Result.DefaultSelection<Prisma.$AgreementParticipationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RelationshipStatus: {
  active: 'active',
  archived: 'archived'
};

export type RelationshipStatus = (typeof RelationshipStatus)[keyof typeof RelationshipStatus]


export const InviteStatus: {
  pending: 'pending',
  accepted: 'accepted',
  expired: 'expired'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const PromptType: {
  daily: 'daily',
  daily_meeting: 'daily_meeting'
};

export type PromptType = (typeof PromptType)[keyof typeof PromptType]


export const PromptCategory: {
  gratitude: 'gratitude',
  communication: 'communication',
  reflection: 'reflection',
  fun: 'fun',
  growth: 'growth',
  other: 'other'
};

export type PromptCategory = (typeof PromptCategory)[keyof typeof PromptCategory]


export const PromptTone: {
  light: 'light',
  deep: 'deep',
  playful: 'playful',
  serious: 'serious'
};

export type PromptTone = (typeof PromptTone)[keyof typeof PromptTone]


export const SessionState: {
  open: 'open',
  revealed: 'revealed',
  expired: 'expired'
};

export type SessionState = (typeof SessionState)[keyof typeof SessionState]


export const SubscriptionStatus: {
  active: 'active',
  canceled: 'canceled',
  past_due: 'past_due',
  trialing: 'trialing'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const QuizState: {
  open: 'open',
  revealed: 'revealed'
};

export type QuizState = (typeof QuizState)[keyof typeof QuizState]


export const AgreementState: {
  open: 'open',
  revealed: 'revealed'
};

export type AgreementState = (typeof AgreementState)[keyof typeof AgreementState]

}

export type RelationshipStatus = $Enums.RelationshipStatus

export const RelationshipStatus: typeof $Enums.RelationshipStatus

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type PromptType = $Enums.PromptType

export const PromptType: typeof $Enums.PromptType

export type PromptCategory = $Enums.PromptCategory

export const PromptCategory: typeof $Enums.PromptCategory

export type PromptTone = $Enums.PromptTone

export const PromptTone: typeof $Enums.PromptTone

export type SessionState = $Enums.SessionState

export const SessionState: typeof $Enums.SessionState

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type QuizState = $Enums.QuizState

export const QuizState: typeof $Enums.QuizState

export type AgreementState = $Enums.AgreementState

export const AgreementState: typeof $Enums.AgreementState

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.relationship`: Exposes CRUD operations for the **Relationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relationships
    * const relationships = await prisma.relationship.findMany()
    * ```
    */
  get relationship(): Prisma.RelationshipDelegate<ExtArgs>;

  /**
   * `prisma.relationshipMember`: Exposes CRUD operations for the **RelationshipMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelationshipMembers
    * const relationshipMembers = await prisma.relationshipMember.findMany()
    * ```
    */
  get relationshipMember(): Prisma.RelationshipMemberDelegate<ExtArgs>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **Invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.InviteDelegate<ExtArgs>;

  /**
   * `prisma.prompt`: Exposes CRUD operations for the **Prompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prompts
    * const prompts = await prisma.prompt.findMany()
    * ```
    */
  get prompt(): Prisma.PromptDelegate<ExtArgs>;

  /**
   * `prisma.dailySession`: Exposes CRUD operations for the **DailySession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailySessions
    * const dailySessions = await prisma.dailySession.findMany()
    * ```
    */
  get dailySession(): Prisma.DailySessionDelegate<ExtArgs>;

  /**
   * `prisma.response`: Exposes CRUD operations for the **Response** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responses
    * const responses = await prisma.response.findMany()
    * ```
    */
  get response(): Prisma.ResponseDelegate<ExtArgs>;

  /**
   * `prisma.responseValidation`: Exposes CRUD operations for the **ResponseValidation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResponseValidations
    * const responseValidations = await prisma.responseValidation.findMany()
    * ```
    */
  get responseValidation(): Prisma.ResponseValidationDelegate<ExtArgs>;

  /**
   * `prisma.reflection`: Exposes CRUD operations for the **Reflection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reflections
    * const reflections = await prisma.reflection.findMany()
    * ```
    */
  get reflection(): Prisma.ReflectionDelegate<ExtArgs>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs>;

  /**
   * `prisma.meetingEntry`: Exposes CRUD operations for the **MeetingEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingEntries
    * const meetingEntries = await prisma.meetingEntry.findMany()
    * ```
    */
  get meetingEntry(): Prisma.MeetingEntryDelegate<ExtArgs>;

  /**
   * `prisma.streak`: Exposes CRUD operations for the **Streak** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Streaks
    * const streaks = await prisma.streak.findMany()
    * ```
    */
  get streak(): Prisma.StreakDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.betaSignup`: Exposes CRUD operations for the **BetaSignup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BetaSignups
    * const betaSignups = await prisma.betaSignup.findMany()
    * ```
    */
  get betaSignup(): Prisma.BetaSignupDelegate<ExtArgs>;

  /**
   * `prisma.quizSession`: Exposes CRUD operations for the **QuizSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizSessions
    * const quizSessions = await prisma.quizSession.findMany()
    * ```
    */
  get quizSession(): Prisma.QuizSessionDelegate<ExtArgs>;

  /**
   * `prisma.quizParticipation`: Exposes CRUD operations for the **QuizParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizParticipations
    * const quizParticipations = await prisma.quizParticipation.findMany()
    * ```
    */
  get quizParticipation(): Prisma.QuizParticipationDelegate<ExtArgs>;

  /**
   * `prisma.agreementSession`: Exposes CRUD operations for the **AgreementSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementSessions
    * const agreementSessions = await prisma.agreementSession.findMany()
    * ```
    */
  get agreementSession(): Prisma.AgreementSessionDelegate<ExtArgs>;

  /**
   * `prisma.agreementParticipation`: Exposes CRUD operations for the **AgreementParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementParticipations
    * const agreementParticipations = await prisma.agreementParticipation.findMany()
    * ```
    */
  get agreementParticipation(): Prisma.AgreementParticipationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Relationship: 'Relationship',
    RelationshipMember: 'RelationshipMember',
    Invite: 'Invite',
    Prompt: 'Prompt',
    DailySession: 'DailySession',
    Response: 'Response',
    ResponseValidation: 'ResponseValidation',
    Reflection: 'Reflection',
    Meeting: 'Meeting',
    MeetingEntry: 'MeetingEntry',
    Streak: 'Streak',
    Subscription: 'Subscription',
    BetaSignup: 'BetaSignup',
    QuizSession: 'QuizSession',
    QuizParticipation: 'QuizParticipation',
    AgreementSession: 'AgreementSession',
    AgreementParticipation: 'AgreementParticipation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "account" | "session" | "verificationToken" | "relationship" | "relationshipMember" | "invite" | "prompt" | "dailySession" | "response" | "responseValidation" | "reflection" | "meeting" | "meetingEntry" | "streak" | "subscription" | "betaSignup" | "quizSession" | "quizParticipation" | "agreementSession" | "agreementParticipation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Relationship: {
        payload: Prisma.$RelationshipPayload<ExtArgs>
        fields: Prisma.RelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findFirst: {
            args: Prisma.RelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          findMany: {
            args: Prisma.RelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          create: {
            args: Prisma.RelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          createMany: {
            args: Prisma.RelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>[]
          }
          delete: {
            args: Prisma.RelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          update: {
            args: Prisma.RelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          deleteMany: {
            args: Prisma.RelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipPayload>
          }
          aggregate: {
            args: Prisma.RelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationship>
          }
          groupBy: {
            args: Prisma.RelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<RelationshipCountAggregateOutputType> | number
          }
        }
      }
      RelationshipMember: {
        payload: Prisma.$RelationshipMemberPayload<ExtArgs>
        fields: Prisma.RelationshipMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationshipMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationshipMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>
          }
          findFirst: {
            args: Prisma.RelationshipMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationshipMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>
          }
          findMany: {
            args: Prisma.RelationshipMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>[]
          }
          create: {
            args: Prisma.RelationshipMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>
          }
          createMany: {
            args: Prisma.RelationshipMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelationshipMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>[]
          }
          delete: {
            args: Prisma.RelationshipMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>
          }
          update: {
            args: Prisma.RelationshipMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>
          }
          deleteMany: {
            args: Prisma.RelationshipMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationshipMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelationshipMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationshipMemberPayload>
          }
          aggregate: {
            args: Prisma.RelationshipMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationshipMember>
          }
          groupBy: {
            args: Prisma.RelationshipMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationshipMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationshipMemberCountArgs<ExtArgs>
            result: $Utils.Optional<RelationshipMemberCountAggregateOutputType> | number
          }
        }
      }
      Invite: {
        payload: Prisma.$InvitePayload<ExtArgs>
        fields: Prisma.InviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findFirst: {
            args: Prisma.InviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findMany: {
            args: Prisma.InviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          create: {
            args: Prisma.InviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          createMany: {
            args: Prisma.InviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          delete: {
            args: Prisma.InviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          update: {
            args: Prisma.InviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          deleteMany: {
            args: Prisma.InviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.InviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      Prompt: {
        payload: Prisma.$PromptPayload<ExtArgs>
        fields: Prisma.PromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findFirst: {
            args: Prisma.PromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          findMany: {
            args: Prisma.PromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          create: {
            args: Prisma.PromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          createMany: {
            args: Prisma.PromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>[]
          }
          delete: {
            args: Prisma.PromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          update: {
            args: Prisma.PromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          deleteMany: {
            args: Prisma.PromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromptPayload>
          }
          aggregate: {
            args: Prisma.PromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrompt>
          }
          groupBy: {
            args: Prisma.PromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromptCountArgs<ExtArgs>
            result: $Utils.Optional<PromptCountAggregateOutputType> | number
          }
        }
      }
      DailySession: {
        payload: Prisma.$DailySessionPayload<ExtArgs>
        fields: Prisma.DailySessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailySessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailySessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>
          }
          findFirst: {
            args: Prisma.DailySessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailySessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>
          }
          findMany: {
            args: Prisma.DailySessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>[]
          }
          create: {
            args: Prisma.DailySessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>
          }
          createMany: {
            args: Prisma.DailySessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailySessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>[]
          }
          delete: {
            args: Prisma.DailySessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>
          }
          update: {
            args: Prisma.DailySessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>
          }
          deleteMany: {
            args: Prisma.DailySessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailySessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailySessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailySessionPayload>
          }
          aggregate: {
            args: Prisma.DailySessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailySession>
          }
          groupBy: {
            args: Prisma.DailySessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailySessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailySessionCountArgs<ExtArgs>
            result: $Utils.Optional<DailySessionCountAggregateOutputType> | number
          }
        }
      }
      Response: {
        payload: Prisma.$ResponsePayload<ExtArgs>
        fields: Prisma.ResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          findFirst: {
            args: Prisma.ResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          findMany: {
            args: Prisma.ResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>[]
          }
          create: {
            args: Prisma.ResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          createMany: {
            args: Prisma.ResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>[]
          }
          delete: {
            args: Prisma.ResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          update: {
            args: Prisma.ResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          deleteMany: {
            args: Prisma.ResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          aggregate: {
            args: Prisma.ResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponse>
          }
          groupBy: {
            args: Prisma.ResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponseCountArgs<ExtArgs>
            result: $Utils.Optional<ResponseCountAggregateOutputType> | number
          }
        }
      }
      ResponseValidation: {
        payload: Prisma.$ResponseValidationPayload<ExtArgs>
        fields: Prisma.ResponseValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponseValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponseValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>
          }
          findFirst: {
            args: Prisma.ResponseValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponseValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>
          }
          findMany: {
            args: Prisma.ResponseValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>[]
          }
          create: {
            args: Prisma.ResponseValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>
          }
          createMany: {
            args: Prisma.ResponseValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResponseValidationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>[]
          }
          delete: {
            args: Prisma.ResponseValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>
          }
          update: {
            args: Prisma.ResponseValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>
          }
          deleteMany: {
            args: Prisma.ResponseValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResponseValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResponseValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResponseValidationPayload>
          }
          aggregate: {
            args: Prisma.ResponseValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponseValidation>
          }
          groupBy: {
            args: Prisma.ResponseValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResponseValidationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponseValidationCountArgs<ExtArgs>
            result: $Utils.Optional<ResponseValidationCountAggregateOutputType> | number
          }
        }
      }
      Reflection: {
        payload: Prisma.$ReflectionPayload<ExtArgs>
        fields: Prisma.ReflectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReflectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReflectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>
          }
          findFirst: {
            args: Prisma.ReflectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReflectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>
          }
          findMany: {
            args: Prisma.ReflectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>[]
          }
          create: {
            args: Prisma.ReflectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>
          }
          createMany: {
            args: Prisma.ReflectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReflectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>[]
          }
          delete: {
            args: Prisma.ReflectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>
          }
          update: {
            args: Prisma.ReflectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>
          }
          deleteMany: {
            args: Prisma.ReflectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReflectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReflectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReflectionPayload>
          }
          aggregate: {
            args: Prisma.ReflectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReflection>
          }
          groupBy: {
            args: Prisma.ReflectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReflectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReflectionCountArgs<ExtArgs>
            result: $Utils.Optional<ReflectionCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      MeetingEntry: {
        payload: Prisma.$MeetingEntryPayload<ExtArgs>
        fields: Prisma.MeetingEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>
          }
          findFirst: {
            args: Prisma.MeetingEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>
          }
          findMany: {
            args: Prisma.MeetingEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>[]
          }
          create: {
            args: Prisma.MeetingEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>
          }
          createMany: {
            args: Prisma.MeetingEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>[]
          }
          delete: {
            args: Prisma.MeetingEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>
          }
          update: {
            args: Prisma.MeetingEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>
          }
          deleteMany: {
            args: Prisma.MeetingEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingEntryPayload>
          }
          aggregate: {
            args: Prisma.MeetingEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingEntry>
          }
          groupBy: {
            args: Prisma.MeetingEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingEntryCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingEntryCountAggregateOutputType> | number
          }
        }
      }
      Streak: {
        payload: Prisma.$StreakPayload<ExtArgs>
        fields: Prisma.StreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          findFirst: {
            args: Prisma.StreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          findMany: {
            args: Prisma.StreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>[]
          }
          create: {
            args: Prisma.StreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          createMany: {
            args: Prisma.StreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>[]
          }
          delete: {
            args: Prisma.StreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          update: {
            args: Prisma.StreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          deleteMany: {
            args: Prisma.StreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          aggregate: {
            args: Prisma.StreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStreak>
          }
          groupBy: {
            args: Prisma.StreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreakCountArgs<ExtArgs>
            result: $Utils.Optional<StreakCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      BetaSignup: {
        payload: Prisma.$BetaSignupPayload<ExtArgs>
        fields: Prisma.BetaSignupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BetaSignupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BetaSignupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>
          }
          findFirst: {
            args: Prisma.BetaSignupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BetaSignupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>
          }
          findMany: {
            args: Prisma.BetaSignupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>[]
          }
          create: {
            args: Prisma.BetaSignupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>
          }
          createMany: {
            args: Prisma.BetaSignupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BetaSignupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>[]
          }
          delete: {
            args: Prisma.BetaSignupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>
          }
          update: {
            args: Prisma.BetaSignupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>
          }
          deleteMany: {
            args: Prisma.BetaSignupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BetaSignupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BetaSignupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BetaSignupPayload>
          }
          aggregate: {
            args: Prisma.BetaSignupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBetaSignup>
          }
          groupBy: {
            args: Prisma.BetaSignupGroupByArgs<ExtArgs>
            result: $Utils.Optional<BetaSignupGroupByOutputType>[]
          }
          count: {
            args: Prisma.BetaSignupCountArgs<ExtArgs>
            result: $Utils.Optional<BetaSignupCountAggregateOutputType> | number
          }
        }
      }
      QuizSession: {
        payload: Prisma.$QuizSessionPayload<ExtArgs>
        fields: Prisma.QuizSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          findFirst: {
            args: Prisma.QuizSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          findMany: {
            args: Prisma.QuizSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          create: {
            args: Prisma.QuizSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          createMany: {
            args: Prisma.QuizSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>[]
          }
          delete: {
            args: Prisma.QuizSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          update: {
            args: Prisma.QuizSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          deleteMany: {
            args: Prisma.QuizSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizSessionPayload>
          }
          aggregate: {
            args: Prisma.QuizSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizSession>
          }
          groupBy: {
            args: Prisma.QuizSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizSessionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizSessionCountAggregateOutputType> | number
          }
        }
      }
      QuizParticipation: {
        payload: Prisma.$QuizParticipationPayload<ExtArgs>
        fields: Prisma.QuizParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>
          }
          findFirst: {
            args: Prisma.QuizParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>
          }
          findMany: {
            args: Prisma.QuizParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>[]
          }
          create: {
            args: Prisma.QuizParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>
          }
          createMany: {
            args: Prisma.QuizParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>[]
          }
          delete: {
            args: Prisma.QuizParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>
          }
          update: {
            args: Prisma.QuizParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>
          }
          deleteMany: {
            args: Prisma.QuizParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizParticipationPayload>
          }
          aggregate: {
            args: Prisma.QuizParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizParticipation>
          }
          groupBy: {
            args: Prisma.QuizParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<QuizParticipationCountAggregateOutputType> | number
          }
        }
      }
      AgreementSession: {
        payload: Prisma.$AgreementSessionPayload<ExtArgs>
        fields: Prisma.AgreementSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgreementSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>
          }
          findFirst: {
            args: Prisma.AgreementSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgreementSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>
          }
          findMany: {
            args: Prisma.AgreementSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>[]
          }
          create: {
            args: Prisma.AgreementSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>
          }
          createMany: {
            args: Prisma.AgreementSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgreementSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>[]
          }
          delete: {
            args: Prisma.AgreementSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>
          }
          update: {
            args: Prisma.AgreementSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>
          }
          deleteMany: {
            args: Prisma.AgreementSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgreementSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgreementSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementSessionPayload>
          }
          aggregate: {
            args: Prisma.AgreementSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgreementSession>
          }
          groupBy: {
            args: Prisma.AgreementSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgreementSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgreementSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AgreementSessionCountAggregateOutputType> | number
          }
        }
      }
      AgreementParticipation: {
        payload: Prisma.$AgreementParticipationPayload<ExtArgs>
        fields: Prisma.AgreementParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgreementParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>
          }
          findFirst: {
            args: Prisma.AgreementParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgreementParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>
          }
          findMany: {
            args: Prisma.AgreementParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>[]
          }
          create: {
            args: Prisma.AgreementParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>
          }
          createMany: {
            args: Prisma.AgreementParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgreementParticipationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>[]
          }
          delete: {
            args: Prisma.AgreementParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>
          }
          update: {
            args: Prisma.AgreementParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>
          }
          deleteMany: {
            args: Prisma.AgreementParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgreementParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgreementParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementParticipationPayload>
          }
          aggregate: {
            args: Prisma.AgreementParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgreementParticipation>
          }
          groupBy: {
            args: Prisma.AgreementParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgreementParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgreementParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<AgreementParticipationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    relationshipMembers: number
    invitesSent: number
    responses: number
    reflections: number
    responseValidations: number
    quizParticipations: number
    agreementParticipations: number
    meetingEntries: number
    subscriptions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    relationshipMembers?: boolean | UserCountOutputTypeCountRelationshipMembersArgs
    invitesSent?: boolean | UserCountOutputTypeCountInvitesSentArgs
    responses?: boolean | UserCountOutputTypeCountResponsesArgs
    reflections?: boolean | UserCountOutputTypeCountReflectionsArgs
    responseValidations?: boolean | UserCountOutputTypeCountResponseValidationsArgs
    quizParticipations?: boolean | UserCountOutputTypeCountQuizParticipationsArgs
    agreementParticipations?: boolean | UserCountOutputTypeCountAgreementParticipationsArgs
    meetingEntries?: boolean | UserCountOutputTypeCountMeetingEntriesArgs
    subscriptions?: boolean | UserCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRelationshipMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReflectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResponseValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseValidationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizParticipationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAgreementParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementParticipationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type RelationshipCountOutputType
   */

  export type RelationshipCountOutputType = {
    members: number
    invites: number
    dailySessions: number
    quizSessions: number
    agreementSessions: number
    meetings: number
    subscriptions: number
  }

  export type RelationshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | RelationshipCountOutputTypeCountMembersArgs
    invites?: boolean | RelationshipCountOutputTypeCountInvitesArgs
    dailySessions?: boolean | RelationshipCountOutputTypeCountDailySessionsArgs
    quizSessions?: boolean | RelationshipCountOutputTypeCountQuizSessionsArgs
    agreementSessions?: boolean | RelationshipCountOutputTypeCountAgreementSessionsArgs
    meetings?: boolean | RelationshipCountOutputTypeCountMeetingsArgs
    subscriptions?: boolean | RelationshipCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipCountOutputType
     */
    select?: RelationshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipMemberWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountDailySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailySessionWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountQuizSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSessionWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountAgreementSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementSessionWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * RelationshipCountOutputType without action
   */
  export type RelationshipCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type PromptCountOutputType
   */

  export type PromptCountOutputType = {
    dailySessions: number
  }

  export type PromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailySessions?: boolean | PromptCountOutputTypeCountDailySessionsArgs
  }

  // Custom InputTypes
  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromptCountOutputType
     */
    select?: PromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromptCountOutputType without action
   */
  export type PromptCountOutputTypeCountDailySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailySessionWhereInput
  }


  /**
   * Count Type DailySessionCountOutputType
   */

  export type DailySessionCountOutputType = {
    responses: number
    reflections: number
  }

  export type DailySessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | DailySessionCountOutputTypeCountResponsesArgs
    reflections?: boolean | DailySessionCountOutputTypeCountReflectionsArgs
  }

  // Custom InputTypes
  /**
   * DailySessionCountOutputType without action
   */
  export type DailySessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySessionCountOutputType
     */
    select?: DailySessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DailySessionCountOutputType without action
   */
  export type DailySessionCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
  }

  /**
   * DailySessionCountOutputType without action
   */
  export type DailySessionCountOutputTypeCountReflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReflectionWhereInput
  }


  /**
   * Count Type ResponseCountOutputType
   */

  export type ResponseCountOutputType = {
    validations: number
  }

  export type ResponseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validations?: boolean | ResponseCountOutputTypeCountValidationsArgs
  }

  // Custom InputTypes
  /**
   * ResponseCountOutputType without action
   */
  export type ResponseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseCountOutputType
     */
    select?: ResponseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResponseCountOutputType without action
   */
  export type ResponseCountOutputTypeCountValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseValidationWhereInput
  }


  /**
   * Count Type MeetingCountOutputType
   */

  export type MeetingCountOutputType = {
    entries: number
  }

  export type MeetingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entries?: boolean | MeetingCountOutputTypeCountEntriesArgs
  }

  // Custom InputTypes
  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingCountOutputType
     */
    select?: MeetingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MeetingCountOutputType without action
   */
  export type MeetingCountOutputTypeCountEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingEntryWhereInput
  }


  /**
   * Count Type QuizSessionCountOutputType
   */

  export type QuizSessionCountOutputType = {
    participations: number
  }

  export type QuizSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participations?: boolean | QuizSessionCountOutputTypeCountParticipationsArgs
  }

  // Custom InputTypes
  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSessionCountOutputType
     */
    select?: QuizSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizSessionCountOutputType without action
   */
  export type QuizSessionCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizParticipationWhereInput
  }


  /**
   * Count Type AgreementSessionCountOutputType
   */

  export type AgreementSessionCountOutputType = {
    participations: number
  }

  export type AgreementSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participations?: boolean | AgreementSessionCountOutputTypeCountParticipationsArgs
  }

  // Custom InputTypes
  /**
   * AgreementSessionCountOutputType without action
   */
  export type AgreementSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSessionCountOutputType
     */
    select?: AgreementSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgreementSessionCountOutputType without action
   */
  export type AgreementSessionCountOutputTypeCountParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementParticipationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    name: string | null
    image: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: Date | null
    name: string | null
    image: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    name: number
    image: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    name?: true
    image?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: Date | null
    name: string | null
    image: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    relationshipMembers?: boolean | User$relationshipMembersArgs<ExtArgs>
    invitesSent?: boolean | User$invitesSentArgs<ExtArgs>
    responses?: boolean | User$responsesArgs<ExtArgs>
    reflections?: boolean | User$reflectionsArgs<ExtArgs>
    responseValidations?: boolean | User$responseValidationsArgs<ExtArgs>
    quizParticipations?: boolean | User$quizParticipationsArgs<ExtArgs>
    agreementParticipations?: boolean | User$agreementParticipationsArgs<ExtArgs>
    meetingEntries?: boolean | User$meetingEntriesArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    image?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    relationshipMembers?: boolean | User$relationshipMembersArgs<ExtArgs>
    invitesSent?: boolean | User$invitesSentArgs<ExtArgs>
    responses?: boolean | User$responsesArgs<ExtArgs>
    reflections?: boolean | User$reflectionsArgs<ExtArgs>
    responseValidations?: boolean | User$responseValidationsArgs<ExtArgs>
    quizParticipations?: boolean | User$quizParticipationsArgs<ExtArgs>
    agreementParticipations?: boolean | User$agreementParticipationsArgs<ExtArgs>
    meetingEntries?: boolean | User$meetingEntriesArgs<ExtArgs>
    subscriptions?: boolean | User$subscriptionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      relationshipMembers: Prisma.$RelationshipMemberPayload<ExtArgs>[]
      invitesSent: Prisma.$InvitePayload<ExtArgs>[]
      responses: Prisma.$ResponsePayload<ExtArgs>[]
      reflections: Prisma.$ReflectionPayload<ExtArgs>[]
      responseValidations: Prisma.$ResponseValidationPayload<ExtArgs>[]
      quizParticipations: Prisma.$QuizParticipationPayload<ExtArgs>[]
      agreementParticipations: Prisma.$AgreementParticipationPayload<ExtArgs>[]
      meetingEntries: Prisma.$MeetingEntryPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: Date | null
      name: string | null
      image: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    relationshipMembers<T extends User$relationshipMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$relationshipMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findMany"> | Null>
    invitesSent<T extends User$invitesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany"> | Null>
    responses<T extends User$responsesArgs<ExtArgs> = {}>(args?: Subset<T, User$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany"> | Null>
    reflections<T extends User$reflectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reflectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findMany"> | Null>
    responseValidations<T extends User$responseValidationsArgs<ExtArgs> = {}>(args?: Subset<T, User$responseValidationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findMany"> | Null>
    quizParticipations<T extends User$quizParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findMany"> | Null>
    agreementParticipations<T extends User$agreementParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, User$agreementParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findMany"> | Null>
    meetingEntries<T extends User$meetingEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$meetingEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findMany"> | Null>
    subscriptions<T extends User$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.relationshipMembers
   */
  export type User$relationshipMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    where?: RelationshipMemberWhereInput
    orderBy?: RelationshipMemberOrderByWithRelationInput | RelationshipMemberOrderByWithRelationInput[]
    cursor?: RelationshipMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipMemberScalarFieldEnum | RelationshipMemberScalarFieldEnum[]
  }

  /**
   * User.invitesSent
   */
  export type User$invitesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * User.responses
   */
  export type User$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    cursor?: ResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * User.reflections
   */
  export type User$reflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    where?: ReflectionWhereInput
    orderBy?: ReflectionOrderByWithRelationInput | ReflectionOrderByWithRelationInput[]
    cursor?: ReflectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReflectionScalarFieldEnum | ReflectionScalarFieldEnum[]
  }

  /**
   * User.responseValidations
   */
  export type User$responseValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    where?: ResponseValidationWhereInput
    orderBy?: ResponseValidationOrderByWithRelationInput | ResponseValidationOrderByWithRelationInput[]
    cursor?: ResponseValidationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseValidationScalarFieldEnum | ResponseValidationScalarFieldEnum[]
  }

  /**
   * User.quizParticipations
   */
  export type User$quizParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    where?: QuizParticipationWhereInput
    orderBy?: QuizParticipationOrderByWithRelationInput | QuizParticipationOrderByWithRelationInput[]
    cursor?: QuizParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizParticipationScalarFieldEnum | QuizParticipationScalarFieldEnum[]
  }

  /**
   * User.agreementParticipations
   */
  export type User$agreementParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    where?: AgreementParticipationWhereInput
    orderBy?: AgreementParticipationOrderByWithRelationInput | AgreementParticipationOrderByWithRelationInput[]
    cursor?: AgreementParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgreementParticipationScalarFieldEnum | AgreementParticipationScalarFieldEnum[]
  }

  /**
   * User.meetingEntries
   */
  export type User$meetingEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    where?: MeetingEntryWhereInput
    orderBy?: MeetingEntryOrderByWithRelationInput | MeetingEntryOrderByWithRelationInput[]
    cursor?: MeetingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingEntryScalarFieldEnum | MeetingEntryScalarFieldEnum[]
  }

  /**
   * User.subscriptions
   */
  export type User$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({ 
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model Relationship
   */

  export type AggregateRelationship = {
    _count: RelationshipCountAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  export type RelationshipMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.RelationshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelationshipMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.RelationshipStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelationshipCountAggregateOutputType = {
    id: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelationshipMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelationshipMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelationshipCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationship to aggregate.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Relationships
    **/
    _count?: true | RelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipMaxAggregateInputType
  }

  export type GetRelationshipAggregateType<T extends RelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationship[P]>
      : GetScalarType<T[P], AggregateRelationship[P]>
  }




  export type RelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipWhereInput
    orderBy?: RelationshipOrderByWithAggregationInput | RelationshipOrderByWithAggregationInput[]
    by: RelationshipScalarFieldEnum[] | RelationshipScalarFieldEnum
    having?: RelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipCountAggregateInputType | true
    _min?: RelationshipMinAggregateInputType
    _max?: RelationshipMaxAggregateInputType
  }

  export type RelationshipGroupByOutputType = {
    id: string
    name: string | null
    status: $Enums.RelationshipStatus
    createdAt: Date
    updatedAt: Date
    _count: RelationshipCountAggregateOutputType | null
    _min: RelationshipMinAggregateOutputType | null
    _max: RelationshipMaxAggregateOutputType | null
  }

  type GetRelationshipGroupByPayload<T extends RelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipGroupByOutputType[P]>
        }
      >
    >


  export type RelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Relationship$membersArgs<ExtArgs>
    invites?: boolean | Relationship$invitesArgs<ExtArgs>
    dailySessions?: boolean | Relationship$dailySessionsArgs<ExtArgs>
    quizSessions?: boolean | Relationship$quizSessionsArgs<ExtArgs>
    agreementSessions?: boolean | Relationship$agreementSessionsArgs<ExtArgs>
    meetings?: boolean | Relationship$meetingsArgs<ExtArgs>
    streak?: boolean | Relationship$streakArgs<ExtArgs>
    subscriptions?: boolean | Relationship$subscriptionsArgs<ExtArgs>
    _count?: boolean | RelationshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["relationship"]>

  export type RelationshipSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Relationship$membersArgs<ExtArgs>
    invites?: boolean | Relationship$invitesArgs<ExtArgs>
    dailySessions?: boolean | Relationship$dailySessionsArgs<ExtArgs>
    quizSessions?: boolean | Relationship$quizSessionsArgs<ExtArgs>
    agreementSessions?: boolean | Relationship$agreementSessionsArgs<ExtArgs>
    meetings?: boolean | Relationship$meetingsArgs<ExtArgs>
    streak?: boolean | Relationship$streakArgs<ExtArgs>
    subscriptions?: boolean | Relationship$subscriptionsArgs<ExtArgs>
    _count?: boolean | RelationshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RelationshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Relationship"
    objects: {
      members: Prisma.$RelationshipMemberPayload<ExtArgs>[]
      invites: Prisma.$InvitePayload<ExtArgs>[]
      dailySessions: Prisma.$DailySessionPayload<ExtArgs>[]
      quizSessions: Prisma.$QuizSessionPayload<ExtArgs>[]
      agreementSessions: Prisma.$AgreementSessionPayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      streak: Prisma.$StreakPayload<ExtArgs> | null
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      status: $Enums.RelationshipStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["relationship"]>
    composites: {}
  }

  type RelationshipGetPayload<S extends boolean | null | undefined | RelationshipDefaultArgs> = $Result.GetResult<Prisma.$RelationshipPayload, S>

  type RelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationshipCountAggregateInputType | true
    }

  export interface RelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Relationship'], meta: { name: 'Relationship' } }
    /**
     * Find zero or one Relationship that matches the filter.
     * @param {RelationshipFindUniqueArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationshipFindUniqueArgs>(args: SelectSubset<T, RelationshipFindUniqueArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Relationship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelationshipFindUniqueOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Relationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationshipFindFirstArgs>(args?: SelectSubset<T, RelationshipFindFirstArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Relationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindFirstOrThrowArgs} args - Arguments to find a Relationship
     * @example
     * // Get one Relationship
     * const relationship = await prisma.relationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Relationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relationships
     * const relationships = await prisma.relationship.findMany()
     * 
     * // Get first 10 Relationships
     * const relationships = await prisma.relationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationshipWithIdOnly = await prisma.relationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationshipFindManyArgs>(args?: SelectSubset<T, RelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Relationship.
     * @param {RelationshipCreateArgs} args - Arguments to create a Relationship.
     * @example
     * // Create one Relationship
     * const Relationship = await prisma.relationship.create({
     *   data: {
     *     // ... data to create a Relationship
     *   }
     * })
     * 
     */
    create<T extends RelationshipCreateArgs>(args: SelectSubset<T, RelationshipCreateArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Relationships.
     * @param {RelationshipCreateManyArgs} args - Arguments to create many Relationships.
     * @example
     * // Create many Relationships
     * const relationship = await prisma.relationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationshipCreateManyArgs>(args?: SelectSubset<T, RelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Relationships and returns the data saved in the database.
     * @param {RelationshipCreateManyAndReturnArgs} args - Arguments to create many Relationships.
     * @example
     * // Create many Relationships
     * const relationship = await prisma.relationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Relationships and only return the `id`
     * const relationshipWithIdOnly = await prisma.relationship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelationshipCreateManyAndReturnArgs>(args?: SelectSubset<T, RelationshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Relationship.
     * @param {RelationshipDeleteArgs} args - Arguments to delete one Relationship.
     * @example
     * // Delete one Relationship
     * const Relationship = await prisma.relationship.delete({
     *   where: {
     *     // ... filter to delete one Relationship
     *   }
     * })
     * 
     */
    delete<T extends RelationshipDeleteArgs>(args: SelectSubset<T, RelationshipDeleteArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Relationship.
     * @param {RelationshipUpdateArgs} args - Arguments to update one Relationship.
     * @example
     * // Update one Relationship
     * const relationship = await prisma.relationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationshipUpdateArgs>(args: SelectSubset<T, RelationshipUpdateArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Relationships.
     * @param {RelationshipDeleteManyArgs} args - Arguments to filter Relationships to delete.
     * @example
     * // Delete a few Relationships
     * const { count } = await prisma.relationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationshipDeleteManyArgs>(args?: SelectSubset<T, RelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relationships
     * const relationship = await prisma.relationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationshipUpdateManyArgs>(args: SelectSubset<T, RelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relationship.
     * @param {RelationshipUpsertArgs} args - Arguments to update or create a Relationship.
     * @example
     * // Update or create a Relationship
     * const relationship = await prisma.relationship.upsert({
     *   create: {
     *     // ... data to create a Relationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relationship we want to update
     *   }
     * })
     */
    upsert<T extends RelationshipUpsertArgs>(args: SelectSubset<T, RelationshipUpsertArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Relationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipCountArgs} args - Arguments to filter Relationships to count.
     * @example
     * // Count the number of Relationships
     * const count = await prisma.relationship.count({
     *   where: {
     *     // ... the filter for the Relationships we want to count
     *   }
     * })
    **/
    count<T extends RelationshipCountArgs>(
      args?: Subset<T, RelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipAggregateArgs>(args: Subset<T, RelationshipAggregateArgs>): Prisma.PrismaPromise<GetRelationshipAggregateType<T>>

    /**
     * Group by Relationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationshipGroupByArgs['orderBy'] }
        : { orderBy?: RelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Relationship model
   */
  readonly fields: RelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Relationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Relationship$membersArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends Relationship$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany"> | Null>
    dailySessions<T extends Relationship$dailySessionsArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$dailySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findMany"> | Null>
    quizSessions<T extends Relationship$quizSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$quizSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findMany"> | Null>
    agreementSessions<T extends Relationship$agreementSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$agreementSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findMany"> | Null>
    meetings<T extends Relationship$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany"> | Null>
    streak<T extends Relationship$streakArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$streakArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    subscriptions<T extends Relationship$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Relationship$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Relationship model
   */ 
  interface RelationshipFieldRefs {
    readonly id: FieldRef<"Relationship", 'String'>
    readonly name: FieldRef<"Relationship", 'String'>
    readonly status: FieldRef<"Relationship", 'RelationshipStatus'>
    readonly createdAt: FieldRef<"Relationship", 'DateTime'>
    readonly updatedAt: FieldRef<"Relationship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Relationship findUnique
   */
  export type RelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship findUniqueOrThrow
   */
  export type RelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship findFirst
   */
  export type RelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * Relationship findFirstOrThrow
   */
  export type RelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationship to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relationships.
     */
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * Relationship findMany
   */
  export type RelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter, which Relationships to fetch.
     */
    where?: RelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relationships to fetch.
     */
    orderBy?: RelationshipOrderByWithRelationInput | RelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Relationships.
     */
    cursor?: RelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relationships.
     */
    skip?: number
    distinct?: RelationshipScalarFieldEnum | RelationshipScalarFieldEnum[]
  }

  /**
   * Relationship create
   */
  export type RelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Relationship.
     */
    data: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
  }

  /**
   * Relationship createMany
   */
  export type RelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Relationships.
     */
    data: RelationshipCreateManyInput | RelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Relationship createManyAndReturn
   */
  export type RelationshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Relationships.
     */
    data: RelationshipCreateManyInput | RelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Relationship update
   */
  export type RelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Relationship.
     */
    data: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
    /**
     * Choose, which Relationship to update.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship updateMany
   */
  export type RelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Relationships.
     */
    data: XOR<RelationshipUpdateManyMutationInput, RelationshipUncheckedUpdateManyInput>
    /**
     * Filter which Relationships to update
     */
    where?: RelationshipWhereInput
  }

  /**
   * Relationship upsert
   */
  export type RelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Relationship to update in case it exists.
     */
    where: RelationshipWhereUniqueInput
    /**
     * In case the Relationship found by the `where` argument doesn't exist, create a new Relationship with this data.
     */
    create: XOR<RelationshipCreateInput, RelationshipUncheckedCreateInput>
    /**
     * In case the Relationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationshipUpdateInput, RelationshipUncheckedUpdateInput>
  }

  /**
   * Relationship delete
   */
  export type RelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    /**
     * Filter which Relationship to delete.
     */
    where: RelationshipWhereUniqueInput
  }

  /**
   * Relationship deleteMany
   */
  export type RelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relationships to delete
     */
    where?: RelationshipWhereInput
  }

  /**
   * Relationship.members
   */
  export type Relationship$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    where?: RelationshipMemberWhereInput
    orderBy?: RelationshipMemberOrderByWithRelationInput | RelationshipMemberOrderByWithRelationInput[]
    cursor?: RelationshipMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationshipMemberScalarFieldEnum | RelationshipMemberScalarFieldEnum[]
  }

  /**
   * Relationship.invites
   */
  export type Relationship$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Relationship.dailySessions
   */
  export type Relationship$dailySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    where?: DailySessionWhereInput
    orderBy?: DailySessionOrderByWithRelationInput | DailySessionOrderByWithRelationInput[]
    cursor?: DailySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailySessionScalarFieldEnum | DailySessionScalarFieldEnum[]
  }

  /**
   * Relationship.quizSessions
   */
  export type Relationship$quizSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    where?: QuizSessionWhereInput
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    cursor?: QuizSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * Relationship.agreementSessions
   */
  export type Relationship$agreementSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    where?: AgreementSessionWhereInput
    orderBy?: AgreementSessionOrderByWithRelationInput | AgreementSessionOrderByWithRelationInput[]
    cursor?: AgreementSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgreementSessionScalarFieldEnum | AgreementSessionScalarFieldEnum[]
  }

  /**
   * Relationship.meetings
   */
  export type Relationship$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Relationship.streak
   */
  export type Relationship$streakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    where?: StreakWhereInput
  }

  /**
   * Relationship.subscriptions
   */
  export type Relationship$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Relationship without action
   */
  export type RelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
  }


  /**
   * Model RelationshipMember
   */

  export type AggregateRelationshipMember = {
    _count: RelationshipMemberCountAggregateOutputType | null
    _min: RelationshipMemberMinAggregateOutputType | null
    _max: RelationshipMemberMaxAggregateOutputType | null
  }

  export type RelationshipMemberMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    userId: string | null
    role: string | null
    leftAt: Date | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelationshipMemberMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    userId: string | null
    role: string | null
    leftAt: Date | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RelationshipMemberCountAggregateOutputType = {
    id: number
    relationshipId: number
    userId: number
    role: number
    leftAt: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RelationshipMemberMinAggregateInputType = {
    id?: true
    relationshipId?: true
    userId?: true
    role?: true
    leftAt?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelationshipMemberMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    userId?: true
    role?: true
    leftAt?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RelationshipMemberCountAggregateInputType = {
    id?: true
    relationshipId?: true
    userId?: true
    role?: true
    leftAt?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RelationshipMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationshipMember to aggregate.
     */
    where?: RelationshipMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipMembers to fetch.
     */
    orderBy?: RelationshipMemberOrderByWithRelationInput | RelationshipMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationshipMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelationshipMembers
    **/
    _count?: true | RelationshipMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationshipMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationshipMemberMaxAggregateInputType
  }

  export type GetRelationshipMemberAggregateType<T extends RelationshipMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationshipMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationshipMember[P]>
      : GetScalarType<T[P], AggregateRelationshipMember[P]>
  }




  export type RelationshipMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationshipMemberWhereInput
    orderBy?: RelationshipMemberOrderByWithAggregationInput | RelationshipMemberOrderByWithAggregationInput[]
    by: RelationshipMemberScalarFieldEnum[] | RelationshipMemberScalarFieldEnum
    having?: RelationshipMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationshipMemberCountAggregateInputType | true
    _min?: RelationshipMemberMinAggregateInputType
    _max?: RelationshipMemberMaxAggregateInputType
  }

  export type RelationshipMemberGroupByOutputType = {
    id: string
    relationshipId: string
    userId: string
    role: string | null
    leftAt: Date | null
    joinedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RelationshipMemberCountAggregateOutputType | null
    _min: RelationshipMemberMinAggregateOutputType | null
    _max: RelationshipMemberMaxAggregateOutputType | null
  }

  type GetRelationshipMemberGroupByPayload<T extends RelationshipMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationshipMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationshipMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationshipMemberGroupByOutputType[P]>
            : GetScalarType<T[P], RelationshipMemberGroupByOutputType[P]>
        }
      >
    >


  export type RelationshipMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    userId?: boolean
    role?: boolean
    leftAt?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationshipMember"]>

  export type RelationshipMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    userId?: boolean
    role?: boolean
    leftAt?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationshipMember"]>

  export type RelationshipMemberSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    userId?: boolean
    role?: boolean
    leftAt?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RelationshipMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RelationshipMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RelationshipMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelationshipMember"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      userId: string
      role: string | null
      leftAt: Date | null
      joinedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["relationshipMember"]>
    composites: {}
  }

  type RelationshipMemberGetPayload<S extends boolean | null | undefined | RelationshipMemberDefaultArgs> = $Result.GetResult<Prisma.$RelationshipMemberPayload, S>

  type RelationshipMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationshipMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationshipMemberCountAggregateInputType | true
    }

  export interface RelationshipMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelationshipMember'], meta: { name: 'RelationshipMember' } }
    /**
     * Find zero or one RelationshipMember that matches the filter.
     * @param {RelationshipMemberFindUniqueArgs} args - Arguments to find a RelationshipMember
     * @example
     * // Get one RelationshipMember
     * const relationshipMember = await prisma.relationshipMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationshipMemberFindUniqueArgs>(args: SelectSubset<T, RelationshipMemberFindUniqueArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RelationshipMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelationshipMemberFindUniqueOrThrowArgs} args - Arguments to find a RelationshipMember
     * @example
     * // Get one RelationshipMember
     * const relationshipMember = await prisma.relationshipMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationshipMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationshipMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RelationshipMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberFindFirstArgs} args - Arguments to find a RelationshipMember
     * @example
     * // Get one RelationshipMember
     * const relationshipMember = await prisma.relationshipMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationshipMemberFindFirstArgs>(args?: SelectSubset<T, RelationshipMemberFindFirstArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RelationshipMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberFindFirstOrThrowArgs} args - Arguments to find a RelationshipMember
     * @example
     * // Get one RelationshipMember
     * const relationshipMember = await prisma.relationshipMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationshipMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationshipMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RelationshipMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelationshipMembers
     * const relationshipMembers = await prisma.relationshipMember.findMany()
     * 
     * // Get first 10 RelationshipMembers
     * const relationshipMembers = await prisma.relationshipMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationshipMemberWithIdOnly = await prisma.relationshipMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationshipMemberFindManyArgs>(args?: SelectSubset<T, RelationshipMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RelationshipMember.
     * @param {RelationshipMemberCreateArgs} args - Arguments to create a RelationshipMember.
     * @example
     * // Create one RelationshipMember
     * const RelationshipMember = await prisma.relationshipMember.create({
     *   data: {
     *     // ... data to create a RelationshipMember
     *   }
     * })
     * 
     */
    create<T extends RelationshipMemberCreateArgs>(args: SelectSubset<T, RelationshipMemberCreateArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RelationshipMembers.
     * @param {RelationshipMemberCreateManyArgs} args - Arguments to create many RelationshipMembers.
     * @example
     * // Create many RelationshipMembers
     * const relationshipMember = await prisma.relationshipMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationshipMemberCreateManyArgs>(args?: SelectSubset<T, RelationshipMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RelationshipMembers and returns the data saved in the database.
     * @param {RelationshipMemberCreateManyAndReturnArgs} args - Arguments to create many RelationshipMembers.
     * @example
     * // Create many RelationshipMembers
     * const relationshipMember = await prisma.relationshipMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RelationshipMembers and only return the `id`
     * const relationshipMemberWithIdOnly = await prisma.relationshipMember.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelationshipMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, RelationshipMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RelationshipMember.
     * @param {RelationshipMemberDeleteArgs} args - Arguments to delete one RelationshipMember.
     * @example
     * // Delete one RelationshipMember
     * const RelationshipMember = await prisma.relationshipMember.delete({
     *   where: {
     *     // ... filter to delete one RelationshipMember
     *   }
     * })
     * 
     */
    delete<T extends RelationshipMemberDeleteArgs>(args: SelectSubset<T, RelationshipMemberDeleteArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RelationshipMember.
     * @param {RelationshipMemberUpdateArgs} args - Arguments to update one RelationshipMember.
     * @example
     * // Update one RelationshipMember
     * const relationshipMember = await prisma.relationshipMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationshipMemberUpdateArgs>(args: SelectSubset<T, RelationshipMemberUpdateArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RelationshipMembers.
     * @param {RelationshipMemberDeleteManyArgs} args - Arguments to filter RelationshipMembers to delete.
     * @example
     * // Delete a few RelationshipMembers
     * const { count } = await prisma.relationshipMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationshipMemberDeleteManyArgs>(args?: SelectSubset<T, RelationshipMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelationshipMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelationshipMembers
     * const relationshipMember = await prisma.relationshipMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationshipMemberUpdateManyArgs>(args: SelectSubset<T, RelationshipMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelationshipMember.
     * @param {RelationshipMemberUpsertArgs} args - Arguments to update or create a RelationshipMember.
     * @example
     * // Update or create a RelationshipMember
     * const relationshipMember = await prisma.relationshipMember.upsert({
     *   create: {
     *     // ... data to create a RelationshipMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelationshipMember we want to update
     *   }
     * })
     */
    upsert<T extends RelationshipMemberUpsertArgs>(args: SelectSubset<T, RelationshipMemberUpsertArgs<ExtArgs>>): Prisma__RelationshipMemberClient<$Result.GetResult<Prisma.$RelationshipMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RelationshipMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberCountArgs} args - Arguments to filter RelationshipMembers to count.
     * @example
     * // Count the number of RelationshipMembers
     * const count = await prisma.relationshipMember.count({
     *   where: {
     *     // ... the filter for the RelationshipMembers we want to count
     *   }
     * })
    **/
    count<T extends RelationshipMemberCountArgs>(
      args?: Subset<T, RelationshipMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationshipMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelationshipMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationshipMemberAggregateArgs>(args: Subset<T, RelationshipMemberAggregateArgs>): Prisma.PrismaPromise<GetRelationshipMemberAggregateType<T>>

    /**
     * Group by RelationshipMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationshipMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationshipMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationshipMemberGroupByArgs['orderBy'] }
        : { orderBy?: RelationshipMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationshipMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationshipMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelationshipMember model
   */
  readonly fields: RelationshipMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelationshipMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationshipMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelationshipMember model
   */ 
  interface RelationshipMemberFieldRefs {
    readonly id: FieldRef<"RelationshipMember", 'String'>
    readonly relationshipId: FieldRef<"RelationshipMember", 'String'>
    readonly userId: FieldRef<"RelationshipMember", 'String'>
    readonly role: FieldRef<"RelationshipMember", 'String'>
    readonly leftAt: FieldRef<"RelationshipMember", 'DateTime'>
    readonly joinedAt: FieldRef<"RelationshipMember", 'DateTime'>
    readonly createdAt: FieldRef<"RelationshipMember", 'DateTime'>
    readonly updatedAt: FieldRef<"RelationshipMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelationshipMember findUnique
   */
  export type RelationshipMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipMember to fetch.
     */
    where: RelationshipMemberWhereUniqueInput
  }

  /**
   * RelationshipMember findUniqueOrThrow
   */
  export type RelationshipMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipMember to fetch.
     */
    where: RelationshipMemberWhereUniqueInput
  }

  /**
   * RelationshipMember findFirst
   */
  export type RelationshipMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipMember to fetch.
     */
    where?: RelationshipMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipMembers to fetch.
     */
    orderBy?: RelationshipMemberOrderByWithRelationInput | RelationshipMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationshipMembers.
     */
    cursor?: RelationshipMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationshipMembers.
     */
    distinct?: RelationshipMemberScalarFieldEnum | RelationshipMemberScalarFieldEnum[]
  }

  /**
   * RelationshipMember findFirstOrThrow
   */
  export type RelationshipMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipMember to fetch.
     */
    where?: RelationshipMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipMembers to fetch.
     */
    orderBy?: RelationshipMemberOrderByWithRelationInput | RelationshipMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationshipMembers.
     */
    cursor?: RelationshipMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationshipMembers.
     */
    distinct?: RelationshipMemberScalarFieldEnum | RelationshipMemberScalarFieldEnum[]
  }

  /**
   * RelationshipMember findMany
   */
  export type RelationshipMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * Filter, which RelationshipMembers to fetch.
     */
    where?: RelationshipMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationshipMembers to fetch.
     */
    orderBy?: RelationshipMemberOrderByWithRelationInput | RelationshipMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelationshipMembers.
     */
    cursor?: RelationshipMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationshipMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationshipMembers.
     */
    skip?: number
    distinct?: RelationshipMemberScalarFieldEnum | RelationshipMemberScalarFieldEnum[]
  }

  /**
   * RelationshipMember create
   */
  export type RelationshipMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a RelationshipMember.
     */
    data: XOR<RelationshipMemberCreateInput, RelationshipMemberUncheckedCreateInput>
  }

  /**
   * RelationshipMember createMany
   */
  export type RelationshipMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelationshipMembers.
     */
    data: RelationshipMemberCreateManyInput | RelationshipMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelationshipMember createManyAndReturn
   */
  export type RelationshipMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RelationshipMembers.
     */
    data: RelationshipMemberCreateManyInput | RelationshipMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RelationshipMember update
   */
  export type RelationshipMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a RelationshipMember.
     */
    data: XOR<RelationshipMemberUpdateInput, RelationshipMemberUncheckedUpdateInput>
    /**
     * Choose, which RelationshipMember to update.
     */
    where: RelationshipMemberWhereUniqueInput
  }

  /**
   * RelationshipMember updateMany
   */
  export type RelationshipMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelationshipMembers.
     */
    data: XOR<RelationshipMemberUpdateManyMutationInput, RelationshipMemberUncheckedUpdateManyInput>
    /**
     * Filter which RelationshipMembers to update
     */
    where?: RelationshipMemberWhereInput
  }

  /**
   * RelationshipMember upsert
   */
  export type RelationshipMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the RelationshipMember to update in case it exists.
     */
    where: RelationshipMemberWhereUniqueInput
    /**
     * In case the RelationshipMember found by the `where` argument doesn't exist, create a new RelationshipMember with this data.
     */
    create: XOR<RelationshipMemberCreateInput, RelationshipMemberUncheckedCreateInput>
    /**
     * In case the RelationshipMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationshipMemberUpdateInput, RelationshipMemberUncheckedUpdateInput>
  }

  /**
   * RelationshipMember delete
   */
  export type RelationshipMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
    /**
     * Filter which RelationshipMember to delete.
     */
    where: RelationshipMemberWhereUniqueInput
  }

  /**
   * RelationshipMember deleteMany
   */
  export type RelationshipMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationshipMembers to delete
     */
    where?: RelationshipMemberWhereInput
  }

  /**
   * RelationshipMember without action
   */
  export type RelationshipMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationshipMember
     */
    select?: RelationshipMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipMemberInclude<ExtArgs> | null
  }


  /**
   * Model Invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteMinAggregateOutputType = {
    id: string | null
    code: string | null
    relationshipId: string | null
    invitedBy: string | null
    email: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    claimedBy: string | null
    claimedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InviteMaxAggregateOutputType = {
    id: string | null
    code: string | null
    relationshipId: string | null
    invitedBy: string | null
    email: string | null
    status: $Enums.InviteStatus | null
    expiresAt: Date | null
    claimedBy: string | null
    claimedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    code: number
    relationshipId: number
    invitedBy: number
    email: number
    status: number
    expiresAt: number
    claimedBy: number
    claimedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InviteMinAggregateInputType = {
    id?: true
    code?: true
    relationshipId?: true
    invitedBy?: true
    email?: true
    status?: true
    expiresAt?: true
    claimedBy?: true
    claimedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    code?: true
    relationshipId?: true
    invitedBy?: true
    email?: true
    status?: true
    expiresAt?: true
    claimedBy?: true
    claimedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    code?: true
    relationshipId?: true
    invitedBy?: true
    email?: true
    status?: true
    expiresAt?: true
    claimedBy?: true
    claimedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invite to aggregate.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type InviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithAggregationInput | InviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: InviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: string
    code: string
    relationshipId: string
    invitedBy: string
    email: string | null
    status: $Enums.InviteStatus
    expiresAt: Date | null
    claimedBy: string | null
    claimedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends InviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type InviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    relationshipId?: boolean
    invitedBy?: boolean
    email?: boolean
    status?: boolean
    expiresAt?: boolean
    claimedBy?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    relationshipId?: boolean
    invitedBy?: boolean
    email?: boolean
    status?: boolean
    expiresAt?: boolean
    claimedBy?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectScalar = {
    id?: boolean
    code?: boolean
    relationshipId?: boolean
    invitedBy?: boolean
    email?: boolean
    status?: boolean
    expiresAt?: boolean
    claimedBy?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invite"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      relationshipId: string
      invitedBy: string
      email: string | null
      status: $Enums.InviteStatus
      expiresAt: Date | null
      claimedBy: string | null
      claimedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type InviteGetPayload<S extends boolean | null | undefined | InviteDefaultArgs> = $Result.GetResult<Prisma.$InvitePayload, S>

  type InviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface InviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invite'], meta: { name: 'Invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {InviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteFindUniqueArgs>(args: SelectSubset<T, InviteFindUniqueArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteFindFirstArgs>(args?: SelectSubset<T, InviteFindFirstArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteFindManyArgs>(args?: SelectSubset<T, InviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invite.
     * @param {InviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends InviteCreateArgs>(args: SelectSubset<T, InviteCreateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invites.
     * @param {InviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCreateManyArgs>(args?: SelectSubset<T, InviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invites and returns the data saved in the database.
     * @param {InviteCreateManyAndReturnArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invite.
     * @param {InviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends InviteDeleteArgs>(args: SelectSubset<T, InviteDeleteArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invite.
     * @param {InviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteUpdateArgs>(args: SelectSubset<T, InviteUpdateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invites.
     * @param {InviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteDeleteManyArgs>(args?: SelectSubset<T, InviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteUpdateManyArgs>(args: SelectSubset<T, InviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invite.
     * @param {InviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends InviteUpsertArgs>(args: SelectSubset<T, InviteUpsertArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends InviteCountArgs>(
      args?: Subset<T, InviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteGroupByArgs['orderBy'] }
        : { orderBy?: InviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invite model
   */
  readonly fields: InviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invite model
   */ 
  interface InviteFieldRefs {
    readonly id: FieldRef<"Invite", 'String'>
    readonly code: FieldRef<"Invite", 'String'>
    readonly relationshipId: FieldRef<"Invite", 'String'>
    readonly invitedBy: FieldRef<"Invite", 'String'>
    readonly email: FieldRef<"Invite", 'String'>
    readonly status: FieldRef<"Invite", 'InviteStatus'>
    readonly expiresAt: FieldRef<"Invite", 'DateTime'>
    readonly claimedBy: FieldRef<"Invite", 'String'>
    readonly claimedAt: FieldRef<"Invite", 'DateTime'>
    readonly createdAt: FieldRef<"Invite", 'DateTime'>
    readonly updatedAt: FieldRef<"Invite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invite findUnique
   */
  export type InviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findUniqueOrThrow
   */
  export type InviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findFirst
   */
  export type InviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findFirstOrThrow
   */
  export type InviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findMany
   */
  export type InviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invites to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite create
   */
  export type InviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to create a Invite.
     */
    data: XOR<InviteCreateInput, InviteUncheckedCreateInput>
  }

  /**
   * Invite createMany
   */
  export type InviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invite createManyAndReturn
   */
  export type InviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invite update
   */
  export type InviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to update a Invite.
     */
    data: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
    /**
     * Choose, which Invite to update.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite updateMany
   */
  export type InviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
  }

  /**
   * Invite upsert
   */
  export type InviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The filter to search for the Invite to update in case it exists.
     */
    where: InviteWhereUniqueInput
    /**
     * In case the Invite found by the `where` argument doesn't exist, create a new Invite with this data.
     */
    create: XOR<InviteCreateInput, InviteUncheckedCreateInput>
    /**
     * In case the Invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
  }

  /**
   * Invite delete
   */
  export type InviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter which Invite to delete.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite deleteMany
   */
  export type InviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invites to delete
     */
    where?: InviteWhereInput
  }

  /**
   * Invite without action
   */
  export type InviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
  }


  /**
   * Model Prompt
   */

  export type AggregatePrompt = {
    _count: PromptCountAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  export type PromptMinAggregateOutputType = {
    id: string | null
    text: string | null
    momentText: string | null
    type: $Enums.PromptType | null
    category: $Enums.PromptCategory | null
    tone: $Enums.PromptTone | null
    isPremium: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptMaxAggregateOutputType = {
    id: string | null
    text: string | null
    momentText: string | null
    type: $Enums.PromptType | null
    category: $Enums.PromptCategory | null
    tone: $Enums.PromptTone | null
    isPremium: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromptCountAggregateOutputType = {
    id: number
    text: number
    momentText: number
    type: number
    category: number
    tone: number
    isPremium: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromptMinAggregateInputType = {
    id?: true
    text?: true
    momentText?: true
    type?: true
    category?: true
    tone?: true
    isPremium?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptMaxAggregateInputType = {
    id?: true
    text?: true
    momentText?: true
    type?: true
    category?: true
    tone?: true
    isPremium?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromptCountAggregateInputType = {
    id?: true
    text?: true
    momentText?: true
    type?: true
    category?: true
    tone?: true
    isPremium?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompt to aggregate.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prompts
    **/
    _count?: true | PromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromptMaxAggregateInputType
  }

  export type GetPromptAggregateType<T extends PromptAggregateArgs> = {
        [P in keyof T & keyof AggregatePrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrompt[P]>
      : GetScalarType<T[P], AggregatePrompt[P]>
  }




  export type PromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromptWhereInput
    orderBy?: PromptOrderByWithAggregationInput | PromptOrderByWithAggregationInput[]
    by: PromptScalarFieldEnum[] | PromptScalarFieldEnum
    having?: PromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromptCountAggregateInputType | true
    _min?: PromptMinAggregateInputType
    _max?: PromptMaxAggregateInputType
  }

  export type PromptGroupByOutputType = {
    id: string
    text: string
    momentText: string | null
    type: $Enums.PromptType
    category: $Enums.PromptCategory
    tone: $Enums.PromptTone | null
    isPremium: boolean
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromptCountAggregateOutputType | null
    _min: PromptMinAggregateOutputType | null
    _max: PromptMaxAggregateOutputType | null
  }

  type GetPromptGroupByPayload<T extends PromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromptGroupByOutputType[P]>
            : GetScalarType<T[P], PromptGroupByOutputType[P]>
        }
      >
    >


  export type PromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    momentText?: boolean
    type?: boolean
    category?: boolean
    tone?: boolean
    isPremium?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dailySessions?: boolean | Prompt$dailySessionsArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    momentText?: boolean
    type?: boolean
    category?: boolean
    tone?: boolean
    isPremium?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["prompt"]>

  export type PromptSelectScalar = {
    id?: boolean
    text?: boolean
    momentText?: boolean
    type?: boolean
    category?: boolean
    tone?: boolean
    isPremium?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailySessions?: boolean | Prompt$dailySessionsArgs<ExtArgs>
    _count?: boolean | PromptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prompt"
    objects: {
      dailySessions: Prisma.$DailySessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      momentText: string | null
      type: $Enums.PromptType
      category: $Enums.PromptCategory
      tone: $Enums.PromptTone | null
      isPremium: boolean
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prompt"]>
    composites: {}
  }

  type PromptGetPayload<S extends boolean | null | undefined | PromptDefaultArgs> = $Result.GetResult<Prisma.$PromptPayload, S>

  type PromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromptCountAggregateInputType | true
    }

  export interface PromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prompt'], meta: { name: 'Prompt' } }
    /**
     * Find zero or one Prompt that matches the filter.
     * @param {PromptFindUniqueArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromptFindUniqueArgs>(args: SelectSubset<T, PromptFindUniqueArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromptFindUniqueOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromptFindUniqueOrThrowArgs>(args: SelectSubset<T, PromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromptFindFirstArgs>(args?: SelectSubset<T, PromptFindFirstArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindFirstOrThrowArgs} args - Arguments to find a Prompt
     * @example
     * // Get one Prompt
     * const prompt = await prisma.prompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromptFindFirstOrThrowArgs>(args?: SelectSubset<T, PromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prompts
     * const prompts = await prisma.prompt.findMany()
     * 
     * // Get first 10 Prompts
     * const prompts = await prisma.prompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promptWithIdOnly = await prisma.prompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromptFindManyArgs>(args?: SelectSubset<T, PromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prompt.
     * @param {PromptCreateArgs} args - Arguments to create a Prompt.
     * @example
     * // Create one Prompt
     * const Prompt = await prisma.prompt.create({
     *   data: {
     *     // ... data to create a Prompt
     *   }
     * })
     * 
     */
    create<T extends PromptCreateArgs>(args: SelectSubset<T, PromptCreateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prompts.
     * @param {PromptCreateManyArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromptCreateManyArgs>(args?: SelectSubset<T, PromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prompts and returns the data saved in the database.
     * @param {PromptCreateManyAndReturnArgs} args - Arguments to create many Prompts.
     * @example
     * // Create many Prompts
     * const prompt = await prisma.prompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prompts and only return the `id`
     * const promptWithIdOnly = await prisma.prompt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromptCreateManyAndReturnArgs>(args?: SelectSubset<T, PromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prompt.
     * @param {PromptDeleteArgs} args - Arguments to delete one Prompt.
     * @example
     * // Delete one Prompt
     * const Prompt = await prisma.prompt.delete({
     *   where: {
     *     // ... filter to delete one Prompt
     *   }
     * })
     * 
     */
    delete<T extends PromptDeleteArgs>(args: SelectSubset<T, PromptDeleteArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prompt.
     * @param {PromptUpdateArgs} args - Arguments to update one Prompt.
     * @example
     * // Update one Prompt
     * const prompt = await prisma.prompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromptUpdateArgs>(args: SelectSubset<T, PromptUpdateArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prompts.
     * @param {PromptDeleteManyArgs} args - Arguments to filter Prompts to delete.
     * @example
     * // Delete a few Prompts
     * const { count } = await prisma.prompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromptDeleteManyArgs>(args?: SelectSubset<T, PromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prompts
     * const prompt = await prisma.prompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromptUpdateManyArgs>(args: SelectSubset<T, PromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prompt.
     * @param {PromptUpsertArgs} args - Arguments to update or create a Prompt.
     * @example
     * // Update or create a Prompt
     * const prompt = await prisma.prompt.upsert({
     *   create: {
     *     // ... data to create a Prompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prompt we want to update
     *   }
     * })
     */
    upsert<T extends PromptUpsertArgs>(args: SelectSubset<T, PromptUpsertArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptCountArgs} args - Arguments to filter Prompts to count.
     * @example
     * // Count the number of Prompts
     * const count = await prisma.prompt.count({
     *   where: {
     *     // ... the filter for the Prompts we want to count
     *   }
     * })
    **/
    count<T extends PromptCountArgs>(
      args?: Subset<T, PromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromptAggregateArgs>(args: Subset<T, PromptAggregateArgs>): Prisma.PrismaPromise<GetPromptAggregateType<T>>

    /**
     * Group by Prompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromptGroupByArgs['orderBy'] }
        : { orderBy?: PromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prompt model
   */
  readonly fields: PromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailySessions<T extends Prompt$dailySessionsArgs<ExtArgs> = {}>(args?: Subset<T, Prompt$dailySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prompt model
   */ 
  interface PromptFieldRefs {
    readonly id: FieldRef<"Prompt", 'String'>
    readonly text: FieldRef<"Prompt", 'String'>
    readonly momentText: FieldRef<"Prompt", 'String'>
    readonly type: FieldRef<"Prompt", 'PromptType'>
    readonly category: FieldRef<"Prompt", 'PromptCategory'>
    readonly tone: FieldRef<"Prompt", 'PromptTone'>
    readonly isPremium: FieldRef<"Prompt", 'Boolean'>
    readonly active: FieldRef<"Prompt", 'Boolean'>
    readonly createdAt: FieldRef<"Prompt", 'DateTime'>
    readonly updatedAt: FieldRef<"Prompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prompt findUnique
   */
  export type PromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt findUniqueOrThrow
   */
  export type PromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt findFirst
   */
  export type PromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt findFirstOrThrow
   */
  export type PromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompt to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prompts.
     */
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt findMany
   */
  export type PromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter, which Prompts to fetch.
     */
    where?: PromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prompts to fetch.
     */
    orderBy?: PromptOrderByWithRelationInput | PromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prompts.
     */
    cursor?: PromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prompts.
     */
    skip?: number
    distinct?: PromptScalarFieldEnum | PromptScalarFieldEnum[]
  }

  /**
   * Prompt create
   */
  export type PromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to create a Prompt.
     */
    data: XOR<PromptCreateInput, PromptUncheckedCreateInput>
  }

  /**
   * Prompt createMany
   */
  export type PromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prompt createManyAndReturn
   */
  export type PromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prompts.
     */
    data: PromptCreateManyInput | PromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prompt update
   */
  export type PromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The data needed to update a Prompt.
     */
    data: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
    /**
     * Choose, which Prompt to update.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt updateMany
   */
  export type PromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prompts.
     */
    data: XOR<PromptUpdateManyMutationInput, PromptUncheckedUpdateManyInput>
    /**
     * Filter which Prompts to update
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt upsert
   */
  export type PromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * The filter to search for the Prompt to update in case it exists.
     */
    where: PromptWhereUniqueInput
    /**
     * In case the Prompt found by the `where` argument doesn't exist, create a new Prompt with this data.
     */
    create: XOR<PromptCreateInput, PromptUncheckedCreateInput>
    /**
     * In case the Prompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromptUpdateInput, PromptUncheckedUpdateInput>
  }

  /**
   * Prompt delete
   */
  export type PromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    /**
     * Filter which Prompt to delete.
     */
    where: PromptWhereUniqueInput
  }

  /**
   * Prompt deleteMany
   */
  export type PromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prompts to delete
     */
    where?: PromptWhereInput
  }

  /**
   * Prompt.dailySessions
   */
  export type Prompt$dailySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    where?: DailySessionWhereInput
    orderBy?: DailySessionOrderByWithRelationInput | DailySessionOrderByWithRelationInput[]
    cursor?: DailySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailySessionScalarFieldEnum | DailySessionScalarFieldEnum[]
  }

  /**
   * Prompt without action
   */
  export type PromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
  }


  /**
   * Model DailySession
   */

  export type AggregateDailySession = {
    _count: DailySessionCountAggregateOutputType | null
    _min: DailySessionMinAggregateOutputType | null
    _max: DailySessionMaxAggregateOutputType | null
  }

  export type DailySessionMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    sessionDate: Date | null
    promptId: string | null
    state: $Enums.SessionState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailySessionMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    sessionDate: Date | null
    promptId: string | null
    state: $Enums.SessionState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailySessionCountAggregateOutputType = {
    id: number
    relationshipId: number
    sessionDate: number
    promptId: number
    state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailySessionMinAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    promptId?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailySessionMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    promptId?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailySessionCountAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    promptId?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailySessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailySession to aggregate.
     */
    where?: DailySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailySessions to fetch.
     */
    orderBy?: DailySessionOrderByWithRelationInput | DailySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailySessions
    **/
    _count?: true | DailySessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailySessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailySessionMaxAggregateInputType
  }

  export type GetDailySessionAggregateType<T extends DailySessionAggregateArgs> = {
        [P in keyof T & keyof AggregateDailySession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailySession[P]>
      : GetScalarType<T[P], AggregateDailySession[P]>
  }




  export type DailySessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailySessionWhereInput
    orderBy?: DailySessionOrderByWithAggregationInput | DailySessionOrderByWithAggregationInput[]
    by: DailySessionScalarFieldEnum[] | DailySessionScalarFieldEnum
    having?: DailySessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailySessionCountAggregateInputType | true
    _min?: DailySessionMinAggregateInputType
    _max?: DailySessionMaxAggregateInputType
  }

  export type DailySessionGroupByOutputType = {
    id: string
    relationshipId: string
    sessionDate: Date
    promptId: string | null
    state: $Enums.SessionState
    createdAt: Date
    updatedAt: Date
    _count: DailySessionCountAggregateOutputType | null
    _min: DailySessionMinAggregateOutputType | null
    _max: DailySessionMaxAggregateOutputType | null
  }

  type GetDailySessionGroupByPayload<T extends DailySessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailySessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailySessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailySessionGroupByOutputType[P]>
            : GetScalarType<T[P], DailySessionGroupByOutputType[P]>
        }
      >
    >


  export type DailySessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    promptId?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    prompt?: boolean | DailySession$promptArgs<ExtArgs>
    responses?: boolean | DailySession$responsesArgs<ExtArgs>
    reflections?: boolean | DailySession$reflectionsArgs<ExtArgs>
    _count?: boolean | DailySessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailySession"]>

  export type DailySessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    promptId?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    prompt?: boolean | DailySession$promptArgs<ExtArgs>
  }, ExtArgs["result"]["dailySession"]>

  export type DailySessionSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    promptId?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DailySessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    prompt?: boolean | DailySession$promptArgs<ExtArgs>
    responses?: boolean | DailySession$responsesArgs<ExtArgs>
    reflections?: boolean | DailySession$reflectionsArgs<ExtArgs>
    _count?: boolean | DailySessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DailySessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    prompt?: boolean | DailySession$promptArgs<ExtArgs>
  }

  export type $DailySessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailySession"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      prompt: Prisma.$PromptPayload<ExtArgs> | null
      responses: Prisma.$ResponsePayload<ExtArgs>[]
      reflections: Prisma.$ReflectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      sessionDate: Date
      promptId: string | null
      state: $Enums.SessionState
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailySession"]>
    composites: {}
  }

  type DailySessionGetPayload<S extends boolean | null | undefined | DailySessionDefaultArgs> = $Result.GetResult<Prisma.$DailySessionPayload, S>

  type DailySessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailySessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailySessionCountAggregateInputType | true
    }

  export interface DailySessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailySession'], meta: { name: 'DailySession' } }
    /**
     * Find zero or one DailySession that matches the filter.
     * @param {DailySessionFindUniqueArgs} args - Arguments to find a DailySession
     * @example
     * // Get one DailySession
     * const dailySession = await prisma.dailySession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailySessionFindUniqueArgs>(args: SelectSubset<T, DailySessionFindUniqueArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailySession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailySessionFindUniqueOrThrowArgs} args - Arguments to find a DailySession
     * @example
     * // Get one DailySession
     * const dailySession = await prisma.dailySession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailySessionFindUniqueOrThrowArgs>(args: SelectSubset<T, DailySessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailySession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionFindFirstArgs} args - Arguments to find a DailySession
     * @example
     * // Get one DailySession
     * const dailySession = await prisma.dailySession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailySessionFindFirstArgs>(args?: SelectSubset<T, DailySessionFindFirstArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailySession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionFindFirstOrThrowArgs} args - Arguments to find a DailySession
     * @example
     * // Get one DailySession
     * const dailySession = await prisma.dailySession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailySessionFindFirstOrThrowArgs>(args?: SelectSubset<T, DailySessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailySessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailySessions
     * const dailySessions = await prisma.dailySession.findMany()
     * 
     * // Get first 10 DailySessions
     * const dailySessions = await prisma.dailySession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailySessionWithIdOnly = await prisma.dailySession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailySessionFindManyArgs>(args?: SelectSubset<T, DailySessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailySession.
     * @param {DailySessionCreateArgs} args - Arguments to create a DailySession.
     * @example
     * // Create one DailySession
     * const DailySession = await prisma.dailySession.create({
     *   data: {
     *     // ... data to create a DailySession
     *   }
     * })
     * 
     */
    create<T extends DailySessionCreateArgs>(args: SelectSubset<T, DailySessionCreateArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailySessions.
     * @param {DailySessionCreateManyArgs} args - Arguments to create many DailySessions.
     * @example
     * // Create many DailySessions
     * const dailySession = await prisma.dailySession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailySessionCreateManyArgs>(args?: SelectSubset<T, DailySessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailySessions and returns the data saved in the database.
     * @param {DailySessionCreateManyAndReturnArgs} args - Arguments to create many DailySessions.
     * @example
     * // Create many DailySessions
     * const dailySession = await prisma.dailySession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailySessions and only return the `id`
     * const dailySessionWithIdOnly = await prisma.dailySession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailySessionCreateManyAndReturnArgs>(args?: SelectSubset<T, DailySessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailySession.
     * @param {DailySessionDeleteArgs} args - Arguments to delete one DailySession.
     * @example
     * // Delete one DailySession
     * const DailySession = await prisma.dailySession.delete({
     *   where: {
     *     // ... filter to delete one DailySession
     *   }
     * })
     * 
     */
    delete<T extends DailySessionDeleteArgs>(args: SelectSubset<T, DailySessionDeleteArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailySession.
     * @param {DailySessionUpdateArgs} args - Arguments to update one DailySession.
     * @example
     * // Update one DailySession
     * const dailySession = await prisma.dailySession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailySessionUpdateArgs>(args: SelectSubset<T, DailySessionUpdateArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailySessions.
     * @param {DailySessionDeleteManyArgs} args - Arguments to filter DailySessions to delete.
     * @example
     * // Delete a few DailySessions
     * const { count } = await prisma.dailySession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailySessionDeleteManyArgs>(args?: SelectSubset<T, DailySessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailySessions
     * const dailySession = await prisma.dailySession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailySessionUpdateManyArgs>(args: SelectSubset<T, DailySessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailySession.
     * @param {DailySessionUpsertArgs} args - Arguments to update or create a DailySession.
     * @example
     * // Update or create a DailySession
     * const dailySession = await prisma.dailySession.upsert({
     *   create: {
     *     // ... data to create a DailySession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailySession we want to update
     *   }
     * })
     */
    upsert<T extends DailySessionUpsertArgs>(args: SelectSubset<T, DailySessionUpsertArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionCountArgs} args - Arguments to filter DailySessions to count.
     * @example
     * // Count the number of DailySessions
     * const count = await prisma.dailySession.count({
     *   where: {
     *     // ... the filter for the DailySessions we want to count
     *   }
     * })
    **/
    count<T extends DailySessionCountArgs>(
      args?: Subset<T, DailySessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailySessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailySessionAggregateArgs>(args: Subset<T, DailySessionAggregateArgs>): Prisma.PrismaPromise<GetDailySessionAggregateType<T>>

    /**
     * Group by DailySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailySessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailySessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailySessionGroupByArgs['orderBy'] }
        : { orderBy?: DailySessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailySessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailySessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailySession model
   */
  readonly fields: DailySessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailySession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailySessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prompt<T extends DailySession$promptArgs<ExtArgs> = {}>(args?: Subset<T, DailySession$promptArgs<ExtArgs>>): Prisma__PromptClient<$Result.GetResult<Prisma.$PromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    responses<T extends DailySession$responsesArgs<ExtArgs> = {}>(args?: Subset<T, DailySession$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany"> | Null>
    reflections<T extends DailySession$reflectionsArgs<ExtArgs> = {}>(args?: Subset<T, DailySession$reflectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailySession model
   */ 
  interface DailySessionFieldRefs {
    readonly id: FieldRef<"DailySession", 'String'>
    readonly relationshipId: FieldRef<"DailySession", 'String'>
    readonly sessionDate: FieldRef<"DailySession", 'DateTime'>
    readonly promptId: FieldRef<"DailySession", 'String'>
    readonly state: FieldRef<"DailySession", 'SessionState'>
    readonly createdAt: FieldRef<"DailySession", 'DateTime'>
    readonly updatedAt: FieldRef<"DailySession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailySession findUnique
   */
  export type DailySessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * Filter, which DailySession to fetch.
     */
    where: DailySessionWhereUniqueInput
  }

  /**
   * DailySession findUniqueOrThrow
   */
  export type DailySessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * Filter, which DailySession to fetch.
     */
    where: DailySessionWhereUniqueInput
  }

  /**
   * DailySession findFirst
   */
  export type DailySessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * Filter, which DailySession to fetch.
     */
    where?: DailySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailySessions to fetch.
     */
    orderBy?: DailySessionOrderByWithRelationInput | DailySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailySessions.
     */
    cursor?: DailySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailySessions.
     */
    distinct?: DailySessionScalarFieldEnum | DailySessionScalarFieldEnum[]
  }

  /**
   * DailySession findFirstOrThrow
   */
  export type DailySessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * Filter, which DailySession to fetch.
     */
    where?: DailySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailySessions to fetch.
     */
    orderBy?: DailySessionOrderByWithRelationInput | DailySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailySessions.
     */
    cursor?: DailySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailySessions.
     */
    distinct?: DailySessionScalarFieldEnum | DailySessionScalarFieldEnum[]
  }

  /**
   * DailySession findMany
   */
  export type DailySessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * Filter, which DailySessions to fetch.
     */
    where?: DailySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailySessions to fetch.
     */
    orderBy?: DailySessionOrderByWithRelationInput | DailySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailySessions.
     */
    cursor?: DailySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailySessions.
     */
    skip?: number
    distinct?: DailySessionScalarFieldEnum | DailySessionScalarFieldEnum[]
  }

  /**
   * DailySession create
   */
  export type DailySessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * The data needed to create a DailySession.
     */
    data: XOR<DailySessionCreateInput, DailySessionUncheckedCreateInput>
  }

  /**
   * DailySession createMany
   */
  export type DailySessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailySessions.
     */
    data: DailySessionCreateManyInput | DailySessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailySession createManyAndReturn
   */
  export type DailySessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailySessions.
     */
    data: DailySessionCreateManyInput | DailySessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailySession update
   */
  export type DailySessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * The data needed to update a DailySession.
     */
    data: XOR<DailySessionUpdateInput, DailySessionUncheckedUpdateInput>
    /**
     * Choose, which DailySession to update.
     */
    where: DailySessionWhereUniqueInput
  }

  /**
   * DailySession updateMany
   */
  export type DailySessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailySessions.
     */
    data: XOR<DailySessionUpdateManyMutationInput, DailySessionUncheckedUpdateManyInput>
    /**
     * Filter which DailySessions to update
     */
    where?: DailySessionWhereInput
  }

  /**
   * DailySession upsert
   */
  export type DailySessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * The filter to search for the DailySession to update in case it exists.
     */
    where: DailySessionWhereUniqueInput
    /**
     * In case the DailySession found by the `where` argument doesn't exist, create a new DailySession with this data.
     */
    create: XOR<DailySessionCreateInput, DailySessionUncheckedCreateInput>
    /**
     * In case the DailySession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailySessionUpdateInput, DailySessionUncheckedUpdateInput>
  }

  /**
   * DailySession delete
   */
  export type DailySessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
    /**
     * Filter which DailySession to delete.
     */
    where: DailySessionWhereUniqueInput
  }

  /**
   * DailySession deleteMany
   */
  export type DailySessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailySessions to delete
     */
    where?: DailySessionWhereInput
  }

  /**
   * DailySession.prompt
   */
  export type DailySession$promptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prompt
     */
    select?: PromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromptInclude<ExtArgs> | null
    where?: PromptWhereInput
  }

  /**
   * DailySession.responses
   */
  export type DailySession$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    cursor?: ResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * DailySession.reflections
   */
  export type DailySession$reflectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    where?: ReflectionWhereInput
    orderBy?: ReflectionOrderByWithRelationInput | ReflectionOrderByWithRelationInput[]
    cursor?: ReflectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReflectionScalarFieldEnum | ReflectionScalarFieldEnum[]
  }

  /**
   * DailySession without action
   */
  export type DailySessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailySession
     */
    select?: DailySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailySessionInclude<ExtArgs> | null
  }


  /**
   * Model Response
   */

  export type AggregateResponse = {
    _count: ResponseCountAggregateOutputType | null
    _min: ResponseMinAggregateOutputType | null
    _max: ResponseMaxAggregateOutputType | null
  }

  export type ResponseMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResponseMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResponseCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResponseMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResponseMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResponseCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Response to aggregate.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Responses
    **/
    _count?: true | ResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponseMaxAggregateInputType
  }

  export type GetResponseAggregateType<T extends ResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse[P]>
      : GetScalarType<T[P], AggregateResponse[P]>
  }




  export type ResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithAggregationInput | ResponseOrderByWithAggregationInput[]
    by: ResponseScalarFieldEnum[] | ResponseScalarFieldEnum
    having?: ResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponseCountAggregateInputType | true
    _min?: ResponseMinAggregateInputType
    _max?: ResponseMaxAggregateInputType
  }

  export type ResponseGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    content: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResponseCountAggregateOutputType | null
    _min: ResponseMinAggregateOutputType | null
    _max: ResponseMaxAggregateOutputType | null
  }

  type GetResponseGroupByPayload<T extends ResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponseGroupByOutputType[P]>
            : GetScalarType<T[P], ResponseGroupByOutputType[P]>
        }
      >
    >


  export type ResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    validations?: boolean | Response$validationsArgs<ExtArgs>
    _count?: boolean | ResponseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response"]>

  export type ResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response"]>

  export type ResponseSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    validations?: boolean | Response$validationsArgs<ExtArgs>
    _count?: boolean | ResponseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Response"
    objects: {
      session: Prisma.$DailySessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      validations: Prisma.$ResponseValidationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      content: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["response"]>
    composites: {}
  }

  type ResponseGetPayload<S extends boolean | null | undefined | ResponseDefaultArgs> = $Result.GetResult<Prisma.$ResponsePayload, S>

  type ResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResponseCountAggregateInputType | true
    }

  export interface ResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Response'], meta: { name: 'Response' } }
    /**
     * Find zero or one Response that matches the filter.
     * @param {ResponseFindUniqueArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponseFindUniqueArgs>(args: SelectSubset<T, ResponseFindUniqueArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Response that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResponseFindUniqueOrThrowArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Response that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindFirstArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponseFindFirstArgs>(args?: SelectSubset<T, ResponseFindFirstArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Response that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindFirstOrThrowArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responses
     * const responses = await prisma.response.findMany()
     * 
     * // Get first 10 Responses
     * const responses = await prisma.response.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responseWithIdOnly = await prisma.response.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResponseFindManyArgs>(args?: SelectSubset<T, ResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Response.
     * @param {ResponseCreateArgs} args - Arguments to create a Response.
     * @example
     * // Create one Response
     * const Response = await prisma.response.create({
     *   data: {
     *     // ... data to create a Response
     *   }
     * })
     * 
     */
    create<T extends ResponseCreateArgs>(args: SelectSubset<T, ResponseCreateArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Responses.
     * @param {ResponseCreateManyArgs} args - Arguments to create many Responses.
     * @example
     * // Create many Responses
     * const response = await prisma.response.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponseCreateManyArgs>(args?: SelectSubset<T, ResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Responses and returns the data saved in the database.
     * @param {ResponseCreateManyAndReturnArgs} args - Arguments to create many Responses.
     * @example
     * // Create many Responses
     * const response = await prisma.response.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Responses and only return the `id`
     * const responseWithIdOnly = await prisma.response.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Response.
     * @param {ResponseDeleteArgs} args - Arguments to delete one Response.
     * @example
     * // Delete one Response
     * const Response = await prisma.response.delete({
     *   where: {
     *     // ... filter to delete one Response
     *   }
     * })
     * 
     */
    delete<T extends ResponseDeleteArgs>(args: SelectSubset<T, ResponseDeleteArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Response.
     * @param {ResponseUpdateArgs} args - Arguments to update one Response.
     * @example
     * // Update one Response
     * const response = await prisma.response.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponseUpdateArgs>(args: SelectSubset<T, ResponseUpdateArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Responses.
     * @param {ResponseDeleteManyArgs} args - Arguments to filter Responses to delete.
     * @example
     * // Delete a few Responses
     * const { count } = await prisma.response.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponseDeleteManyArgs>(args?: SelectSubset<T, ResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responses
     * const response = await prisma.response.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponseUpdateManyArgs>(args: SelectSubset<T, ResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response.
     * @param {ResponseUpsertArgs} args - Arguments to update or create a Response.
     * @example
     * // Update or create a Response
     * const response = await prisma.response.upsert({
     *   create: {
     *     // ... data to create a Response
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response we want to update
     *   }
     * })
     */
    upsert<T extends ResponseUpsertArgs>(args: SelectSubset<T, ResponseUpsertArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseCountArgs} args - Arguments to filter Responses to count.
     * @example
     * // Count the number of Responses
     * const count = await prisma.response.count({
     *   where: {
     *     // ... the filter for the Responses we want to count
     *   }
     * })
    **/
    count<T extends ResponseCountArgs>(
      args?: Subset<T, ResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponseAggregateArgs>(args: Subset<T, ResponseAggregateArgs>): Prisma.PrismaPromise<GetResponseAggregateType<T>>

    /**
     * Group by Response.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponseGroupByArgs['orderBy'] }
        : { orderBy?: ResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Response model
   */
  readonly fields: ResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Response.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends DailySessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailySessionDefaultArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    validations<T extends Response$validationsArgs<ExtArgs> = {}>(args?: Subset<T, Response$validationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Response model
   */ 
  interface ResponseFieldRefs {
    readonly id: FieldRef<"Response", 'String'>
    readonly sessionId: FieldRef<"Response", 'String'>
    readonly userId: FieldRef<"Response", 'String'>
    readonly content: FieldRef<"Response", 'String'>
    readonly createdAt: FieldRef<"Response", 'DateTime'>
    readonly updatedAt: FieldRef<"Response", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Response findUnique
   */
  export type ResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response findUniqueOrThrow
   */
  export type ResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response findFirst
   */
  export type ResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Responses.
     */
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Response findFirstOrThrow
   */
  export type ResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Responses.
     */
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Response findMany
   */
  export type ResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Responses to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }

  /**
   * Response create
   */
  export type ResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a Response.
     */
    data: XOR<ResponseCreateInput, ResponseUncheckedCreateInput>
  }

  /**
   * Response createMany
   */
  export type ResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Responses.
     */
    data: ResponseCreateManyInput | ResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Response createManyAndReturn
   */
  export type ResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Responses.
     */
    data: ResponseCreateManyInput | ResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Response update
   */
  export type ResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a Response.
     */
    data: XOR<ResponseUpdateInput, ResponseUncheckedUpdateInput>
    /**
     * Choose, which Response to update.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response updateMany
   */
  export type ResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Responses.
     */
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyInput>
    /**
     * Filter which Responses to update
     */
    where?: ResponseWhereInput
  }

  /**
   * Response upsert
   */
  export type ResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the Response to update in case it exists.
     */
    where: ResponseWhereUniqueInput
    /**
     * In case the Response found by the `where` argument doesn't exist, create a new Response with this data.
     */
    create: XOR<ResponseCreateInput, ResponseUncheckedCreateInput>
    /**
     * In case the Response was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponseUpdateInput, ResponseUncheckedUpdateInput>
  }

  /**
   * Response delete
   */
  export type ResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter which Response to delete.
     */
    where: ResponseWhereUniqueInput
  }

  /**
   * Response deleteMany
   */
  export type ResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Responses to delete
     */
    where?: ResponseWhereInput
  }

  /**
   * Response.validations
   */
  export type Response$validationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    where?: ResponseValidationWhereInput
    orderBy?: ResponseValidationOrderByWithRelationInput | ResponseValidationOrderByWithRelationInput[]
    cursor?: ResponseValidationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseValidationScalarFieldEnum | ResponseValidationScalarFieldEnum[]
  }

  /**
   * Response without action
   */
  export type ResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseInclude<ExtArgs> | null
  }


  /**
   * Model ResponseValidation
   */

  export type AggregateResponseValidation = {
    _count: ResponseValidationCountAggregateOutputType | null
    _min: ResponseValidationMinAggregateOutputType | null
    _max: ResponseValidationMaxAggregateOutputType | null
  }

  export type ResponseValidationMinAggregateOutputType = {
    id: string | null
    responseId: string | null
    userId: string | null
    reactions: string | null
    acknowledgment: string | null
  }

  export type ResponseValidationMaxAggregateOutputType = {
    id: string | null
    responseId: string | null
    userId: string | null
    reactions: string | null
    acknowledgment: string | null
  }

  export type ResponseValidationCountAggregateOutputType = {
    id: number
    responseId: number
    userId: number
    reactions: number
    acknowledgment: number
    _all: number
  }


  export type ResponseValidationMinAggregateInputType = {
    id?: true
    responseId?: true
    userId?: true
    reactions?: true
    acknowledgment?: true
  }

  export type ResponseValidationMaxAggregateInputType = {
    id?: true
    responseId?: true
    userId?: true
    reactions?: true
    acknowledgment?: true
  }

  export type ResponseValidationCountAggregateInputType = {
    id?: true
    responseId?: true
    userId?: true
    reactions?: true
    acknowledgment?: true
    _all?: true
  }

  export type ResponseValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponseValidation to aggregate.
     */
    where?: ResponseValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseValidations to fetch.
     */
    orderBy?: ResponseValidationOrderByWithRelationInput | ResponseValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponseValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResponseValidations
    **/
    _count?: true | ResponseValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponseValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponseValidationMaxAggregateInputType
  }

  export type GetResponseValidationAggregateType<T extends ResponseValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateResponseValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponseValidation[P]>
      : GetScalarType<T[P], AggregateResponseValidation[P]>
  }




  export type ResponseValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseValidationWhereInput
    orderBy?: ResponseValidationOrderByWithAggregationInput | ResponseValidationOrderByWithAggregationInput[]
    by: ResponseValidationScalarFieldEnum[] | ResponseValidationScalarFieldEnum
    having?: ResponseValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponseValidationCountAggregateInputType | true
    _min?: ResponseValidationMinAggregateInputType
    _max?: ResponseValidationMaxAggregateInputType
  }

  export type ResponseValidationGroupByOutputType = {
    id: string
    responseId: string
    userId: string
    reactions: string | null
    acknowledgment: string | null
    _count: ResponseValidationCountAggregateOutputType | null
    _min: ResponseValidationMinAggregateOutputType | null
    _max: ResponseValidationMaxAggregateOutputType | null
  }

  type GetResponseValidationGroupByPayload<T extends ResponseValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponseValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponseValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponseValidationGroupByOutputType[P]>
            : GetScalarType<T[P], ResponseValidationGroupByOutputType[P]>
        }
      >
    >


  export type ResponseValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    userId?: boolean
    reactions?: boolean
    acknowledgment?: boolean
    response?: boolean | ResponseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responseValidation"]>

  export type ResponseValidationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    userId?: boolean
    reactions?: boolean
    acknowledgment?: boolean
    response?: boolean | ResponseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responseValidation"]>

  export type ResponseValidationSelectScalar = {
    id?: boolean
    responseId?: boolean
    userId?: boolean
    reactions?: boolean
    acknowledgment?: boolean
  }

  export type ResponseValidationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | ResponseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ResponseValidationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | ResponseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ResponseValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResponseValidation"
    objects: {
      response: Prisma.$ResponsePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responseId: string
      userId: string
      reactions: string | null
      acknowledgment: string | null
    }, ExtArgs["result"]["responseValidation"]>
    composites: {}
  }

  type ResponseValidationGetPayload<S extends boolean | null | undefined | ResponseValidationDefaultArgs> = $Result.GetResult<Prisma.$ResponseValidationPayload, S>

  type ResponseValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResponseValidationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResponseValidationCountAggregateInputType | true
    }

  export interface ResponseValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResponseValidation'], meta: { name: 'ResponseValidation' } }
    /**
     * Find zero or one ResponseValidation that matches the filter.
     * @param {ResponseValidationFindUniqueArgs} args - Arguments to find a ResponseValidation
     * @example
     * // Get one ResponseValidation
     * const responseValidation = await prisma.responseValidation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResponseValidationFindUniqueArgs>(args: SelectSubset<T, ResponseValidationFindUniqueArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResponseValidation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResponseValidationFindUniqueOrThrowArgs} args - Arguments to find a ResponseValidation
     * @example
     * // Get one ResponseValidation
     * const responseValidation = await prisma.responseValidation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResponseValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, ResponseValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResponseValidation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationFindFirstArgs} args - Arguments to find a ResponseValidation
     * @example
     * // Get one ResponseValidation
     * const responseValidation = await prisma.responseValidation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResponseValidationFindFirstArgs>(args?: SelectSubset<T, ResponseValidationFindFirstArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResponseValidation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationFindFirstOrThrowArgs} args - Arguments to find a ResponseValidation
     * @example
     * // Get one ResponseValidation
     * const responseValidation = await prisma.responseValidation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResponseValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, ResponseValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResponseValidations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResponseValidations
     * const responseValidations = await prisma.responseValidation.findMany()
     * 
     * // Get first 10 ResponseValidations
     * const responseValidations = await prisma.responseValidation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responseValidationWithIdOnly = await prisma.responseValidation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResponseValidationFindManyArgs>(args?: SelectSubset<T, ResponseValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResponseValidation.
     * @param {ResponseValidationCreateArgs} args - Arguments to create a ResponseValidation.
     * @example
     * // Create one ResponseValidation
     * const ResponseValidation = await prisma.responseValidation.create({
     *   data: {
     *     // ... data to create a ResponseValidation
     *   }
     * })
     * 
     */
    create<T extends ResponseValidationCreateArgs>(args: SelectSubset<T, ResponseValidationCreateArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResponseValidations.
     * @param {ResponseValidationCreateManyArgs} args - Arguments to create many ResponseValidations.
     * @example
     * // Create many ResponseValidations
     * const responseValidation = await prisma.responseValidation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResponseValidationCreateManyArgs>(args?: SelectSubset<T, ResponseValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResponseValidations and returns the data saved in the database.
     * @param {ResponseValidationCreateManyAndReturnArgs} args - Arguments to create many ResponseValidations.
     * @example
     * // Create many ResponseValidations
     * const responseValidation = await prisma.responseValidation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResponseValidations and only return the `id`
     * const responseValidationWithIdOnly = await prisma.responseValidation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResponseValidationCreateManyAndReturnArgs>(args?: SelectSubset<T, ResponseValidationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResponseValidation.
     * @param {ResponseValidationDeleteArgs} args - Arguments to delete one ResponseValidation.
     * @example
     * // Delete one ResponseValidation
     * const ResponseValidation = await prisma.responseValidation.delete({
     *   where: {
     *     // ... filter to delete one ResponseValidation
     *   }
     * })
     * 
     */
    delete<T extends ResponseValidationDeleteArgs>(args: SelectSubset<T, ResponseValidationDeleteArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResponseValidation.
     * @param {ResponseValidationUpdateArgs} args - Arguments to update one ResponseValidation.
     * @example
     * // Update one ResponseValidation
     * const responseValidation = await prisma.responseValidation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResponseValidationUpdateArgs>(args: SelectSubset<T, ResponseValidationUpdateArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResponseValidations.
     * @param {ResponseValidationDeleteManyArgs} args - Arguments to filter ResponseValidations to delete.
     * @example
     * // Delete a few ResponseValidations
     * const { count } = await prisma.responseValidation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResponseValidationDeleteManyArgs>(args?: SelectSubset<T, ResponseValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResponseValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResponseValidations
     * const responseValidation = await prisma.responseValidation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResponseValidationUpdateManyArgs>(args: SelectSubset<T, ResponseValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResponseValidation.
     * @param {ResponseValidationUpsertArgs} args - Arguments to update or create a ResponseValidation.
     * @example
     * // Update or create a ResponseValidation
     * const responseValidation = await prisma.responseValidation.upsert({
     *   create: {
     *     // ... data to create a ResponseValidation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResponseValidation we want to update
     *   }
     * })
     */
    upsert<T extends ResponseValidationUpsertArgs>(args: SelectSubset<T, ResponseValidationUpsertArgs<ExtArgs>>): Prisma__ResponseValidationClient<$Result.GetResult<Prisma.$ResponseValidationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResponseValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationCountArgs} args - Arguments to filter ResponseValidations to count.
     * @example
     * // Count the number of ResponseValidations
     * const count = await prisma.responseValidation.count({
     *   where: {
     *     // ... the filter for the ResponseValidations we want to count
     *   }
     * })
    **/
    count<T extends ResponseValidationCountArgs>(
      args?: Subset<T, ResponseValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponseValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResponseValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponseValidationAggregateArgs>(args: Subset<T, ResponseValidationAggregateArgs>): Prisma.PrismaPromise<GetResponseValidationAggregateType<T>>

    /**
     * Group by ResponseValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponseValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponseValidationGroupByArgs['orderBy'] }
        : { orderBy?: ResponseValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponseValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponseValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResponseValidation model
   */
  readonly fields: ResponseValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResponseValidation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponseValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response<T extends ResponseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResponseDefaultArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResponseValidation model
   */ 
  interface ResponseValidationFieldRefs {
    readonly id: FieldRef<"ResponseValidation", 'String'>
    readonly responseId: FieldRef<"ResponseValidation", 'String'>
    readonly userId: FieldRef<"ResponseValidation", 'String'>
    readonly reactions: FieldRef<"ResponseValidation", 'String'>
    readonly acknowledgment: FieldRef<"ResponseValidation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ResponseValidation findUnique
   */
  export type ResponseValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * Filter, which ResponseValidation to fetch.
     */
    where: ResponseValidationWhereUniqueInput
  }

  /**
   * ResponseValidation findUniqueOrThrow
   */
  export type ResponseValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * Filter, which ResponseValidation to fetch.
     */
    where: ResponseValidationWhereUniqueInput
  }

  /**
   * ResponseValidation findFirst
   */
  export type ResponseValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * Filter, which ResponseValidation to fetch.
     */
    where?: ResponseValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseValidations to fetch.
     */
    orderBy?: ResponseValidationOrderByWithRelationInput | ResponseValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponseValidations.
     */
    cursor?: ResponseValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponseValidations.
     */
    distinct?: ResponseValidationScalarFieldEnum | ResponseValidationScalarFieldEnum[]
  }

  /**
   * ResponseValidation findFirstOrThrow
   */
  export type ResponseValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * Filter, which ResponseValidation to fetch.
     */
    where?: ResponseValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseValidations to fetch.
     */
    orderBy?: ResponseValidationOrderByWithRelationInput | ResponseValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResponseValidations.
     */
    cursor?: ResponseValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResponseValidations.
     */
    distinct?: ResponseValidationScalarFieldEnum | ResponseValidationScalarFieldEnum[]
  }

  /**
   * ResponseValidation findMany
   */
  export type ResponseValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * Filter, which ResponseValidations to fetch.
     */
    where?: ResponseValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResponseValidations to fetch.
     */
    orderBy?: ResponseValidationOrderByWithRelationInput | ResponseValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResponseValidations.
     */
    cursor?: ResponseValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResponseValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResponseValidations.
     */
    skip?: number
    distinct?: ResponseValidationScalarFieldEnum | ResponseValidationScalarFieldEnum[]
  }

  /**
   * ResponseValidation create
   */
  export type ResponseValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * The data needed to create a ResponseValidation.
     */
    data: XOR<ResponseValidationCreateInput, ResponseValidationUncheckedCreateInput>
  }

  /**
   * ResponseValidation createMany
   */
  export type ResponseValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResponseValidations.
     */
    data: ResponseValidationCreateManyInput | ResponseValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResponseValidation createManyAndReturn
   */
  export type ResponseValidationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResponseValidations.
     */
    data: ResponseValidationCreateManyInput | ResponseValidationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResponseValidation update
   */
  export type ResponseValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * The data needed to update a ResponseValidation.
     */
    data: XOR<ResponseValidationUpdateInput, ResponseValidationUncheckedUpdateInput>
    /**
     * Choose, which ResponseValidation to update.
     */
    where: ResponseValidationWhereUniqueInput
  }

  /**
   * ResponseValidation updateMany
   */
  export type ResponseValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResponseValidations.
     */
    data: XOR<ResponseValidationUpdateManyMutationInput, ResponseValidationUncheckedUpdateManyInput>
    /**
     * Filter which ResponseValidations to update
     */
    where?: ResponseValidationWhereInput
  }

  /**
   * ResponseValidation upsert
   */
  export type ResponseValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * The filter to search for the ResponseValidation to update in case it exists.
     */
    where: ResponseValidationWhereUniqueInput
    /**
     * In case the ResponseValidation found by the `where` argument doesn't exist, create a new ResponseValidation with this data.
     */
    create: XOR<ResponseValidationCreateInput, ResponseValidationUncheckedCreateInput>
    /**
     * In case the ResponseValidation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponseValidationUpdateInput, ResponseValidationUncheckedUpdateInput>
  }

  /**
   * ResponseValidation delete
   */
  export type ResponseValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
    /**
     * Filter which ResponseValidation to delete.
     */
    where: ResponseValidationWhereUniqueInput
  }

  /**
   * ResponseValidation deleteMany
   */
  export type ResponseValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResponseValidations to delete
     */
    where?: ResponseValidationWhereInput
  }

  /**
   * ResponseValidation without action
   */
  export type ResponseValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResponseValidation
     */
    select?: ResponseValidationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResponseValidationInclude<ExtArgs> | null
  }


  /**
   * Model Reflection
   */

  export type AggregateReflection = {
    _count: ReflectionCountAggregateOutputType | null
    _min: ReflectionMinAggregateOutputType | null
    _max: ReflectionMaxAggregateOutputType | null
  }

  export type ReflectionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    content: string | null
    reaction: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReflectionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    content: string | null
    reaction: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReflectionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    content: number
    reaction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReflectionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    content?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReflectionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    content?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReflectionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    content?: true
    reaction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReflectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reflection to aggregate.
     */
    where?: ReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reflections to fetch.
     */
    orderBy?: ReflectionOrderByWithRelationInput | ReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reflections
    **/
    _count?: true | ReflectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReflectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReflectionMaxAggregateInputType
  }

  export type GetReflectionAggregateType<T extends ReflectionAggregateArgs> = {
        [P in keyof T & keyof AggregateReflection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReflection[P]>
      : GetScalarType<T[P], AggregateReflection[P]>
  }




  export type ReflectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReflectionWhereInput
    orderBy?: ReflectionOrderByWithAggregationInput | ReflectionOrderByWithAggregationInput[]
    by: ReflectionScalarFieldEnum[] | ReflectionScalarFieldEnum
    having?: ReflectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReflectionCountAggregateInputType | true
    _min?: ReflectionMinAggregateInputType
    _max?: ReflectionMaxAggregateInputType
  }

  export type ReflectionGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    content: string | null
    reaction: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReflectionCountAggregateOutputType | null
    _min: ReflectionMinAggregateOutputType | null
    _max: ReflectionMaxAggregateOutputType | null
  }

  type GetReflectionGroupByPayload<T extends ReflectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReflectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReflectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReflectionGroupByOutputType[P]>
            : GetScalarType<T[P], ReflectionGroupByOutputType[P]>
        }
      >
    >


  export type ReflectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    content?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reflection"]>

  export type ReflectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    content?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reflection"]>

  export type ReflectionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    content?: boolean
    reaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReflectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReflectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | DailySessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReflectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reflection"
    objects: {
      session: Prisma.$DailySessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      content: string | null
      reaction: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reflection"]>
    composites: {}
  }

  type ReflectionGetPayload<S extends boolean | null | undefined | ReflectionDefaultArgs> = $Result.GetResult<Prisma.$ReflectionPayload, S>

  type ReflectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReflectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReflectionCountAggregateInputType | true
    }

  export interface ReflectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reflection'], meta: { name: 'Reflection' } }
    /**
     * Find zero or one Reflection that matches the filter.
     * @param {ReflectionFindUniqueArgs} args - Arguments to find a Reflection
     * @example
     * // Get one Reflection
     * const reflection = await prisma.reflection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReflectionFindUniqueArgs>(args: SelectSubset<T, ReflectionFindUniqueArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reflection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReflectionFindUniqueOrThrowArgs} args - Arguments to find a Reflection
     * @example
     * // Get one Reflection
     * const reflection = await prisma.reflection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReflectionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReflectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reflection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionFindFirstArgs} args - Arguments to find a Reflection
     * @example
     * // Get one Reflection
     * const reflection = await prisma.reflection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReflectionFindFirstArgs>(args?: SelectSubset<T, ReflectionFindFirstArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reflection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionFindFirstOrThrowArgs} args - Arguments to find a Reflection
     * @example
     * // Get one Reflection
     * const reflection = await prisma.reflection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReflectionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReflectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reflections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reflections
     * const reflections = await prisma.reflection.findMany()
     * 
     * // Get first 10 Reflections
     * const reflections = await prisma.reflection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reflectionWithIdOnly = await prisma.reflection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReflectionFindManyArgs>(args?: SelectSubset<T, ReflectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reflection.
     * @param {ReflectionCreateArgs} args - Arguments to create a Reflection.
     * @example
     * // Create one Reflection
     * const Reflection = await prisma.reflection.create({
     *   data: {
     *     // ... data to create a Reflection
     *   }
     * })
     * 
     */
    create<T extends ReflectionCreateArgs>(args: SelectSubset<T, ReflectionCreateArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reflections.
     * @param {ReflectionCreateManyArgs} args - Arguments to create many Reflections.
     * @example
     * // Create many Reflections
     * const reflection = await prisma.reflection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReflectionCreateManyArgs>(args?: SelectSubset<T, ReflectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reflections and returns the data saved in the database.
     * @param {ReflectionCreateManyAndReturnArgs} args - Arguments to create many Reflections.
     * @example
     * // Create many Reflections
     * const reflection = await prisma.reflection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reflections and only return the `id`
     * const reflectionWithIdOnly = await prisma.reflection.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReflectionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReflectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reflection.
     * @param {ReflectionDeleteArgs} args - Arguments to delete one Reflection.
     * @example
     * // Delete one Reflection
     * const Reflection = await prisma.reflection.delete({
     *   where: {
     *     // ... filter to delete one Reflection
     *   }
     * })
     * 
     */
    delete<T extends ReflectionDeleteArgs>(args: SelectSubset<T, ReflectionDeleteArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reflection.
     * @param {ReflectionUpdateArgs} args - Arguments to update one Reflection.
     * @example
     * // Update one Reflection
     * const reflection = await prisma.reflection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReflectionUpdateArgs>(args: SelectSubset<T, ReflectionUpdateArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reflections.
     * @param {ReflectionDeleteManyArgs} args - Arguments to filter Reflections to delete.
     * @example
     * // Delete a few Reflections
     * const { count } = await prisma.reflection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReflectionDeleteManyArgs>(args?: SelectSubset<T, ReflectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reflections
     * const reflection = await prisma.reflection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReflectionUpdateManyArgs>(args: SelectSubset<T, ReflectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reflection.
     * @param {ReflectionUpsertArgs} args - Arguments to update or create a Reflection.
     * @example
     * // Update or create a Reflection
     * const reflection = await prisma.reflection.upsert({
     *   create: {
     *     // ... data to create a Reflection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reflection we want to update
     *   }
     * })
     */
    upsert<T extends ReflectionUpsertArgs>(args: SelectSubset<T, ReflectionUpsertArgs<ExtArgs>>): Prisma__ReflectionClient<$Result.GetResult<Prisma.$ReflectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reflections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionCountArgs} args - Arguments to filter Reflections to count.
     * @example
     * // Count the number of Reflections
     * const count = await prisma.reflection.count({
     *   where: {
     *     // ... the filter for the Reflections we want to count
     *   }
     * })
    **/
    count<T extends ReflectionCountArgs>(
      args?: Subset<T, ReflectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReflectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reflection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReflectionAggregateArgs>(args: Subset<T, ReflectionAggregateArgs>): Prisma.PrismaPromise<GetReflectionAggregateType<T>>

    /**
     * Group by Reflection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReflectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReflectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReflectionGroupByArgs['orderBy'] }
        : { orderBy?: ReflectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReflectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReflectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reflection model
   */
  readonly fields: ReflectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reflection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReflectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends DailySessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DailySessionDefaultArgs<ExtArgs>>): Prisma__DailySessionClient<$Result.GetResult<Prisma.$DailySessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reflection model
   */ 
  interface ReflectionFieldRefs {
    readonly id: FieldRef<"Reflection", 'String'>
    readonly sessionId: FieldRef<"Reflection", 'String'>
    readonly userId: FieldRef<"Reflection", 'String'>
    readonly content: FieldRef<"Reflection", 'String'>
    readonly reaction: FieldRef<"Reflection", 'String'>
    readonly createdAt: FieldRef<"Reflection", 'DateTime'>
    readonly updatedAt: FieldRef<"Reflection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reflection findUnique
   */
  export type ReflectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * Filter, which Reflection to fetch.
     */
    where: ReflectionWhereUniqueInput
  }

  /**
   * Reflection findUniqueOrThrow
   */
  export type ReflectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * Filter, which Reflection to fetch.
     */
    where: ReflectionWhereUniqueInput
  }

  /**
   * Reflection findFirst
   */
  export type ReflectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * Filter, which Reflection to fetch.
     */
    where?: ReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reflections to fetch.
     */
    orderBy?: ReflectionOrderByWithRelationInput | ReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reflections.
     */
    cursor?: ReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reflections.
     */
    distinct?: ReflectionScalarFieldEnum | ReflectionScalarFieldEnum[]
  }

  /**
   * Reflection findFirstOrThrow
   */
  export type ReflectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * Filter, which Reflection to fetch.
     */
    where?: ReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reflections to fetch.
     */
    orderBy?: ReflectionOrderByWithRelationInput | ReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reflections.
     */
    cursor?: ReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reflections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reflections.
     */
    distinct?: ReflectionScalarFieldEnum | ReflectionScalarFieldEnum[]
  }

  /**
   * Reflection findMany
   */
  export type ReflectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * Filter, which Reflections to fetch.
     */
    where?: ReflectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reflections to fetch.
     */
    orderBy?: ReflectionOrderByWithRelationInput | ReflectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reflections.
     */
    cursor?: ReflectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reflections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reflections.
     */
    skip?: number
    distinct?: ReflectionScalarFieldEnum | ReflectionScalarFieldEnum[]
  }

  /**
   * Reflection create
   */
  export type ReflectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reflection.
     */
    data: XOR<ReflectionCreateInput, ReflectionUncheckedCreateInput>
  }

  /**
   * Reflection createMany
   */
  export type ReflectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reflections.
     */
    data: ReflectionCreateManyInput | ReflectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reflection createManyAndReturn
   */
  export type ReflectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reflections.
     */
    data: ReflectionCreateManyInput | ReflectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reflection update
   */
  export type ReflectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reflection.
     */
    data: XOR<ReflectionUpdateInput, ReflectionUncheckedUpdateInput>
    /**
     * Choose, which Reflection to update.
     */
    where: ReflectionWhereUniqueInput
  }

  /**
   * Reflection updateMany
   */
  export type ReflectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reflections.
     */
    data: XOR<ReflectionUpdateManyMutationInput, ReflectionUncheckedUpdateManyInput>
    /**
     * Filter which Reflections to update
     */
    where?: ReflectionWhereInput
  }

  /**
   * Reflection upsert
   */
  export type ReflectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reflection to update in case it exists.
     */
    where: ReflectionWhereUniqueInput
    /**
     * In case the Reflection found by the `where` argument doesn't exist, create a new Reflection with this data.
     */
    create: XOR<ReflectionCreateInput, ReflectionUncheckedCreateInput>
    /**
     * In case the Reflection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReflectionUpdateInput, ReflectionUncheckedUpdateInput>
  }

  /**
   * Reflection delete
   */
  export type ReflectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
    /**
     * Filter which Reflection to delete.
     */
    where: ReflectionWhereUniqueInput
  }

  /**
   * Reflection deleteMany
   */
  export type ReflectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reflections to delete
     */
    where?: ReflectionWhereInput
  }

  /**
   * Reflection without action
   */
  export type ReflectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reflection
     */
    select?: ReflectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReflectionInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    weekKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    weekKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    relationshipId: number
    weekKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingMinAggregateInputType = {
    id?: true
    relationshipId?: true
    weekKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    weekKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    relationshipId?: true
    weekKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: string
    relationshipId: string
    weekKey: string
    createdAt: Date
    updatedAt: Date
    _count: MeetingCountAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    weekKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    entries?: boolean | Meeting$entriesArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    weekKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    weekKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    entries?: boolean | Meeting$entriesArgs<ExtArgs>
    _count?: boolean | MeetingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      entries: Prisma.$MeetingEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      weekKey: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    entries<T extends Meeting$entriesArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$entriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */ 
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'String'>
    readonly relationshipId: FieldRef<"Meeting", 'String'>
    readonly weekKey: FieldRef<"Meeting", 'String'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
  }

  /**
   * Meeting.entries
   */
  export type Meeting$entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    where?: MeetingEntryWhereInput
    orderBy?: MeetingEntryOrderByWithRelationInput | MeetingEntryOrderByWithRelationInput[]
    cursor?: MeetingEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingEntryScalarFieldEnum | MeetingEntryScalarFieldEnum[]
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model MeetingEntry
   */

  export type AggregateMeetingEntry = {
    _count: MeetingEntryCountAggregateOutputType | null
    _min: MeetingEntryMinAggregateOutputType | null
    _max: MeetingEntryMaxAggregateOutputType | null
  }

  export type MeetingEntryMinAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    wins: string | null
    stressors: string | null
    request: string | null
    plan: string | null
    appreciation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingEntryMaxAggregateOutputType = {
    id: string | null
    meetingId: string | null
    userId: string | null
    wins: string | null
    stressors: string | null
    request: string | null
    plan: string | null
    appreciation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingEntryCountAggregateOutputType = {
    id: number
    meetingId: number
    userId: number
    wins: number
    stressors: number
    request: number
    plan: number
    appreciation: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingEntryMinAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    wins?: true
    stressors?: true
    request?: true
    plan?: true
    appreciation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingEntryMaxAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    wins?: true
    stressors?: true
    request?: true
    plan?: true
    appreciation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingEntryCountAggregateInputType = {
    id?: true
    meetingId?: true
    userId?: true
    wins?: true
    stressors?: true
    request?: true
    plan?: true
    appreciation?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingEntry to aggregate.
     */
    where?: MeetingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingEntries to fetch.
     */
    orderBy?: MeetingEntryOrderByWithRelationInput | MeetingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingEntries
    **/
    _count?: true | MeetingEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingEntryMaxAggregateInputType
  }

  export type GetMeetingEntryAggregateType<T extends MeetingEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingEntry[P]>
      : GetScalarType<T[P], AggregateMeetingEntry[P]>
  }




  export type MeetingEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingEntryWhereInput
    orderBy?: MeetingEntryOrderByWithAggregationInput | MeetingEntryOrderByWithAggregationInput[]
    by: MeetingEntryScalarFieldEnum[] | MeetingEntryScalarFieldEnum
    having?: MeetingEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingEntryCountAggregateInputType | true
    _min?: MeetingEntryMinAggregateInputType
    _max?: MeetingEntryMaxAggregateInputType
  }

  export type MeetingEntryGroupByOutputType = {
    id: string
    meetingId: string
    userId: string
    wins: string | null
    stressors: string | null
    request: string | null
    plan: string | null
    appreciation: string | null
    createdAt: Date
    updatedAt: Date
    _count: MeetingEntryCountAggregateOutputType | null
    _min: MeetingEntryMinAggregateOutputType | null
    _max: MeetingEntryMaxAggregateOutputType | null
  }

  type GetMeetingEntryGroupByPayload<T extends MeetingEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingEntryGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingEntryGroupByOutputType[P]>
        }
      >
    >


  export type MeetingEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    wins?: boolean
    stressors?: boolean
    request?: boolean
    plan?: boolean
    appreciation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingEntry"]>

  export type MeetingEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    wins?: boolean
    stressors?: boolean
    request?: boolean
    plan?: boolean
    appreciation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingEntry"]>

  export type MeetingEntrySelectScalar = {
    id?: boolean
    meetingId?: boolean
    userId?: boolean
    wins?: boolean
    stressors?: boolean
    request?: boolean
    plan?: boolean
    appreciation?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meeting?: boolean | MeetingDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingEntry"
    objects: {
      meeting: Prisma.$MeetingPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      meetingId: string
      userId: string
      wins: string | null
      stressors: string | null
      request: string | null
      plan: string | null
      appreciation: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meetingEntry"]>
    composites: {}
  }

  type MeetingEntryGetPayload<S extends boolean | null | undefined | MeetingEntryDefaultArgs> = $Result.GetResult<Prisma.$MeetingEntryPayload, S>

  type MeetingEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeetingEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeetingEntryCountAggregateInputType | true
    }

  export interface MeetingEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingEntry'], meta: { name: 'MeetingEntry' } }
    /**
     * Find zero or one MeetingEntry that matches the filter.
     * @param {MeetingEntryFindUniqueArgs} args - Arguments to find a MeetingEntry
     * @example
     * // Get one MeetingEntry
     * const meetingEntry = await prisma.meetingEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingEntryFindUniqueArgs>(args: SelectSubset<T, MeetingEntryFindUniqueArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MeetingEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MeetingEntryFindUniqueOrThrowArgs} args - Arguments to find a MeetingEntry
     * @example
     * // Get one MeetingEntry
     * const meetingEntry = await prisma.meetingEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MeetingEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryFindFirstArgs} args - Arguments to find a MeetingEntry
     * @example
     * // Get one MeetingEntry
     * const meetingEntry = await prisma.meetingEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingEntryFindFirstArgs>(args?: SelectSubset<T, MeetingEntryFindFirstArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MeetingEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryFindFirstOrThrowArgs} args - Arguments to find a MeetingEntry
     * @example
     * // Get one MeetingEntry
     * const meetingEntry = await prisma.meetingEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MeetingEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingEntries
     * const meetingEntries = await prisma.meetingEntry.findMany()
     * 
     * // Get first 10 MeetingEntries
     * const meetingEntries = await prisma.meetingEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingEntryWithIdOnly = await prisma.meetingEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingEntryFindManyArgs>(args?: SelectSubset<T, MeetingEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MeetingEntry.
     * @param {MeetingEntryCreateArgs} args - Arguments to create a MeetingEntry.
     * @example
     * // Create one MeetingEntry
     * const MeetingEntry = await prisma.meetingEntry.create({
     *   data: {
     *     // ... data to create a MeetingEntry
     *   }
     * })
     * 
     */
    create<T extends MeetingEntryCreateArgs>(args: SelectSubset<T, MeetingEntryCreateArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MeetingEntries.
     * @param {MeetingEntryCreateManyArgs} args - Arguments to create many MeetingEntries.
     * @example
     * // Create many MeetingEntries
     * const meetingEntry = await prisma.meetingEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingEntryCreateManyArgs>(args?: SelectSubset<T, MeetingEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingEntries and returns the data saved in the database.
     * @param {MeetingEntryCreateManyAndReturnArgs} args - Arguments to create many MeetingEntries.
     * @example
     * // Create many MeetingEntries
     * const meetingEntry = await prisma.meetingEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingEntries and only return the `id`
     * const meetingEntryWithIdOnly = await prisma.meetingEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MeetingEntry.
     * @param {MeetingEntryDeleteArgs} args - Arguments to delete one MeetingEntry.
     * @example
     * // Delete one MeetingEntry
     * const MeetingEntry = await prisma.meetingEntry.delete({
     *   where: {
     *     // ... filter to delete one MeetingEntry
     *   }
     * })
     * 
     */
    delete<T extends MeetingEntryDeleteArgs>(args: SelectSubset<T, MeetingEntryDeleteArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MeetingEntry.
     * @param {MeetingEntryUpdateArgs} args - Arguments to update one MeetingEntry.
     * @example
     * // Update one MeetingEntry
     * const meetingEntry = await prisma.meetingEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingEntryUpdateArgs>(args: SelectSubset<T, MeetingEntryUpdateArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MeetingEntries.
     * @param {MeetingEntryDeleteManyArgs} args - Arguments to filter MeetingEntries to delete.
     * @example
     * // Delete a few MeetingEntries
     * const { count } = await prisma.meetingEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingEntryDeleteManyArgs>(args?: SelectSubset<T, MeetingEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingEntries
     * const meetingEntry = await prisma.meetingEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingEntryUpdateManyArgs>(args: SelectSubset<T, MeetingEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MeetingEntry.
     * @param {MeetingEntryUpsertArgs} args - Arguments to update or create a MeetingEntry.
     * @example
     * // Update or create a MeetingEntry
     * const meetingEntry = await prisma.meetingEntry.upsert({
     *   create: {
     *     // ... data to create a MeetingEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingEntry we want to update
     *   }
     * })
     */
    upsert<T extends MeetingEntryUpsertArgs>(args: SelectSubset<T, MeetingEntryUpsertArgs<ExtArgs>>): Prisma__MeetingEntryClient<$Result.GetResult<Prisma.$MeetingEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MeetingEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryCountArgs} args - Arguments to filter MeetingEntries to count.
     * @example
     * // Count the number of MeetingEntries
     * const count = await prisma.meetingEntry.count({
     *   where: {
     *     // ... the filter for the MeetingEntries we want to count
     *   }
     * })
    **/
    count<T extends MeetingEntryCountArgs>(
      args?: Subset<T, MeetingEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingEntryAggregateArgs>(args: Subset<T, MeetingEntryAggregateArgs>): Prisma.PrismaPromise<GetMeetingEntryAggregateType<T>>

    /**
     * Group by MeetingEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingEntryGroupByArgs['orderBy'] }
        : { orderBy?: MeetingEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingEntry model
   */
  readonly fields: MeetingEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meeting<T extends MeetingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeetingDefaultArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingEntry model
   */ 
  interface MeetingEntryFieldRefs {
    readonly id: FieldRef<"MeetingEntry", 'String'>
    readonly meetingId: FieldRef<"MeetingEntry", 'String'>
    readonly userId: FieldRef<"MeetingEntry", 'String'>
    readonly wins: FieldRef<"MeetingEntry", 'String'>
    readonly stressors: FieldRef<"MeetingEntry", 'String'>
    readonly request: FieldRef<"MeetingEntry", 'String'>
    readonly plan: FieldRef<"MeetingEntry", 'String'>
    readonly appreciation: FieldRef<"MeetingEntry", 'String'>
    readonly createdAt: FieldRef<"MeetingEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"MeetingEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeetingEntry findUnique
   */
  export type MeetingEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * Filter, which MeetingEntry to fetch.
     */
    where: MeetingEntryWhereUniqueInput
  }

  /**
   * MeetingEntry findUniqueOrThrow
   */
  export type MeetingEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * Filter, which MeetingEntry to fetch.
     */
    where: MeetingEntryWhereUniqueInput
  }

  /**
   * MeetingEntry findFirst
   */
  export type MeetingEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * Filter, which MeetingEntry to fetch.
     */
    where?: MeetingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingEntries to fetch.
     */
    orderBy?: MeetingEntryOrderByWithRelationInput | MeetingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingEntries.
     */
    cursor?: MeetingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingEntries.
     */
    distinct?: MeetingEntryScalarFieldEnum | MeetingEntryScalarFieldEnum[]
  }

  /**
   * MeetingEntry findFirstOrThrow
   */
  export type MeetingEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * Filter, which MeetingEntry to fetch.
     */
    where?: MeetingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingEntries to fetch.
     */
    orderBy?: MeetingEntryOrderByWithRelationInput | MeetingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingEntries.
     */
    cursor?: MeetingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingEntries.
     */
    distinct?: MeetingEntryScalarFieldEnum | MeetingEntryScalarFieldEnum[]
  }

  /**
   * MeetingEntry findMany
   */
  export type MeetingEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * Filter, which MeetingEntries to fetch.
     */
    where?: MeetingEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingEntries to fetch.
     */
    orderBy?: MeetingEntryOrderByWithRelationInput | MeetingEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingEntries.
     */
    cursor?: MeetingEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingEntries.
     */
    skip?: number
    distinct?: MeetingEntryScalarFieldEnum | MeetingEntryScalarFieldEnum[]
  }

  /**
   * MeetingEntry create
   */
  export type MeetingEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingEntry.
     */
    data: XOR<MeetingEntryCreateInput, MeetingEntryUncheckedCreateInput>
  }

  /**
   * MeetingEntry createMany
   */
  export type MeetingEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingEntries.
     */
    data: MeetingEntryCreateManyInput | MeetingEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingEntry createManyAndReturn
   */
  export type MeetingEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MeetingEntries.
     */
    data: MeetingEntryCreateManyInput | MeetingEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingEntry update
   */
  export type MeetingEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingEntry.
     */
    data: XOR<MeetingEntryUpdateInput, MeetingEntryUncheckedUpdateInput>
    /**
     * Choose, which MeetingEntry to update.
     */
    where: MeetingEntryWhereUniqueInput
  }

  /**
   * MeetingEntry updateMany
   */
  export type MeetingEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingEntries.
     */
    data: XOR<MeetingEntryUpdateManyMutationInput, MeetingEntryUncheckedUpdateManyInput>
    /**
     * Filter which MeetingEntries to update
     */
    where?: MeetingEntryWhereInput
  }

  /**
   * MeetingEntry upsert
   */
  export type MeetingEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingEntry to update in case it exists.
     */
    where: MeetingEntryWhereUniqueInput
    /**
     * In case the MeetingEntry found by the `where` argument doesn't exist, create a new MeetingEntry with this data.
     */
    create: XOR<MeetingEntryCreateInput, MeetingEntryUncheckedCreateInput>
    /**
     * In case the MeetingEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingEntryUpdateInput, MeetingEntryUncheckedUpdateInput>
  }

  /**
   * MeetingEntry delete
   */
  export type MeetingEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
    /**
     * Filter which MeetingEntry to delete.
     */
    where: MeetingEntryWhereUniqueInput
  }

  /**
   * MeetingEntry deleteMany
   */
  export type MeetingEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingEntries to delete
     */
    where?: MeetingEntryWhereInput
  }

  /**
   * MeetingEntry without action
   */
  export type MeetingEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingEntry
     */
    select?: MeetingEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingEntryInclude<ExtArgs> | null
  }


  /**
   * Model Streak
   */

  export type AggregateStreak = {
    _count: StreakCountAggregateOutputType | null
    _avg: StreakAvgAggregateOutputType | null
    _sum: StreakSumAggregateOutputType | null
    _min: StreakMinAggregateOutputType | null
    _max: StreakMaxAggregateOutputType | null
  }

  export type StreakAvgAggregateOutputType = {
    currentCount: number | null
    longestCount: number | null
  }

  export type StreakSumAggregateOutputType = {
    currentCount: number | null
    longestCount: number | null
  }

  export type StreakMinAggregateOutputType = {
    relationshipId: string | null
    currentCount: number | null
    longestCount: number | null
    lastCompletedDate: Date | null
  }

  export type StreakMaxAggregateOutputType = {
    relationshipId: string | null
    currentCount: number | null
    longestCount: number | null
    lastCompletedDate: Date | null
  }

  export type StreakCountAggregateOutputType = {
    relationshipId: number
    currentCount: number
    longestCount: number
    lastCompletedDate: number
    _all: number
  }


  export type StreakAvgAggregateInputType = {
    currentCount?: true
    longestCount?: true
  }

  export type StreakSumAggregateInputType = {
    currentCount?: true
    longestCount?: true
  }

  export type StreakMinAggregateInputType = {
    relationshipId?: true
    currentCount?: true
    longestCount?: true
    lastCompletedDate?: true
  }

  export type StreakMaxAggregateInputType = {
    relationshipId?: true
    currentCount?: true
    longestCount?: true
    lastCompletedDate?: true
  }

  export type StreakCountAggregateInputType = {
    relationshipId?: true
    currentCount?: true
    longestCount?: true
    lastCompletedDate?: true
    _all?: true
  }

  export type StreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streak to aggregate.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Streaks
    **/
    _count?: true | StreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreakMaxAggregateInputType
  }

  export type GetStreakAggregateType<T extends StreakAggregateArgs> = {
        [P in keyof T & keyof AggregateStreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreak[P]>
      : GetScalarType<T[P], AggregateStreak[P]>
  }




  export type StreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreakWhereInput
    orderBy?: StreakOrderByWithAggregationInput | StreakOrderByWithAggregationInput[]
    by: StreakScalarFieldEnum[] | StreakScalarFieldEnum
    having?: StreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreakCountAggregateInputType | true
    _avg?: StreakAvgAggregateInputType
    _sum?: StreakSumAggregateInputType
    _min?: StreakMinAggregateInputType
    _max?: StreakMaxAggregateInputType
  }

  export type StreakGroupByOutputType = {
    relationshipId: string
    currentCount: number
    longestCount: number
    lastCompletedDate: Date | null
    _count: StreakCountAggregateOutputType | null
    _avg: StreakAvgAggregateOutputType | null
    _sum: StreakSumAggregateOutputType | null
    _min: StreakMinAggregateOutputType | null
    _max: StreakMaxAggregateOutputType | null
  }

  type GetStreakGroupByPayload<T extends StreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreakGroupByOutputType[P]>
            : GetScalarType<T[P], StreakGroupByOutputType[P]>
        }
      >
    >


  export type StreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    relationshipId?: boolean
    currentCount?: boolean
    longestCount?: boolean
    lastCompletedDate?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streak"]>

  export type StreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    relationshipId?: boolean
    currentCount?: boolean
    longestCount?: boolean
    lastCompletedDate?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streak"]>

  export type StreakSelectScalar = {
    relationshipId?: boolean
    currentCount?: boolean
    longestCount?: boolean
    lastCompletedDate?: boolean
  }

  export type StreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }
  export type StreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }

  export type $StreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Streak"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      relationshipId: string
      currentCount: number
      longestCount: number
      lastCompletedDate: Date | null
    }, ExtArgs["result"]["streak"]>
    composites: {}
  }

  type StreakGetPayload<S extends boolean | null | undefined | StreakDefaultArgs> = $Result.GetResult<Prisma.$StreakPayload, S>

  type StreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StreakFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StreakCountAggregateInputType | true
    }

  export interface StreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Streak'], meta: { name: 'Streak' } }
    /**
     * Find zero or one Streak that matches the filter.
     * @param {StreakFindUniqueArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreakFindUniqueArgs>(args: SelectSubset<T, StreakFindUniqueArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Streak that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StreakFindUniqueOrThrowArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreakFindUniqueOrThrowArgs>(args: SelectSubset<T, StreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Streak that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakFindFirstArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreakFindFirstArgs>(args?: SelectSubset<T, StreakFindFirstArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Streak that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakFindFirstOrThrowArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreakFindFirstOrThrowArgs>(args?: SelectSubset<T, StreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Streaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Streaks
     * const streaks = await prisma.streak.findMany()
     * 
     * // Get first 10 Streaks
     * const streaks = await prisma.streak.findMany({ take: 10 })
     * 
     * // Only select the `relationshipId`
     * const streakWithRelationshipIdOnly = await prisma.streak.findMany({ select: { relationshipId: true } })
     * 
     */
    findMany<T extends StreakFindManyArgs>(args?: SelectSubset<T, StreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Streak.
     * @param {StreakCreateArgs} args - Arguments to create a Streak.
     * @example
     * // Create one Streak
     * const Streak = await prisma.streak.create({
     *   data: {
     *     // ... data to create a Streak
     *   }
     * })
     * 
     */
    create<T extends StreakCreateArgs>(args: SelectSubset<T, StreakCreateArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Streaks.
     * @param {StreakCreateManyArgs} args - Arguments to create many Streaks.
     * @example
     * // Create many Streaks
     * const streak = await prisma.streak.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreakCreateManyArgs>(args?: SelectSubset<T, StreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Streaks and returns the data saved in the database.
     * @param {StreakCreateManyAndReturnArgs} args - Arguments to create many Streaks.
     * @example
     * // Create many Streaks
     * const streak = await prisma.streak.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Streaks and only return the `relationshipId`
     * const streakWithRelationshipIdOnly = await prisma.streak.createManyAndReturn({ 
     *   select: { relationshipId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreakCreateManyAndReturnArgs>(args?: SelectSubset<T, StreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Streak.
     * @param {StreakDeleteArgs} args - Arguments to delete one Streak.
     * @example
     * // Delete one Streak
     * const Streak = await prisma.streak.delete({
     *   where: {
     *     // ... filter to delete one Streak
     *   }
     * })
     * 
     */
    delete<T extends StreakDeleteArgs>(args: SelectSubset<T, StreakDeleteArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Streak.
     * @param {StreakUpdateArgs} args - Arguments to update one Streak.
     * @example
     * // Update one Streak
     * const streak = await prisma.streak.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreakUpdateArgs>(args: SelectSubset<T, StreakUpdateArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Streaks.
     * @param {StreakDeleteManyArgs} args - Arguments to filter Streaks to delete.
     * @example
     * // Delete a few Streaks
     * const { count } = await prisma.streak.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreakDeleteManyArgs>(args?: SelectSubset<T, StreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Streaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Streaks
     * const streak = await prisma.streak.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreakUpdateManyArgs>(args: SelectSubset<T, StreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Streak.
     * @param {StreakUpsertArgs} args - Arguments to update or create a Streak.
     * @example
     * // Update or create a Streak
     * const streak = await prisma.streak.upsert({
     *   create: {
     *     // ... data to create a Streak
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Streak we want to update
     *   }
     * })
     */
    upsert<T extends StreakUpsertArgs>(args: SelectSubset<T, StreakUpsertArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Streaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakCountArgs} args - Arguments to filter Streaks to count.
     * @example
     * // Count the number of Streaks
     * const count = await prisma.streak.count({
     *   where: {
     *     // ... the filter for the Streaks we want to count
     *   }
     * })
    **/
    count<T extends StreakCountArgs>(
      args?: Subset<T, StreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Streak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreakAggregateArgs>(args: Subset<T, StreakAggregateArgs>): Prisma.PrismaPromise<GetStreakAggregateType<T>>

    /**
     * Group by Streak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreakGroupByArgs['orderBy'] }
        : { orderBy?: StreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Streak model
   */
  readonly fields: StreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Streak.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Streak model
   */ 
  interface StreakFieldRefs {
    readonly relationshipId: FieldRef<"Streak", 'String'>
    readonly currentCount: FieldRef<"Streak", 'Int'>
    readonly longestCount: FieldRef<"Streak", 'Int'>
    readonly lastCompletedDate: FieldRef<"Streak", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Streak findUnique
   */
  export type StreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak findUniqueOrThrow
   */
  export type StreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak findFirst
   */
  export type StreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streaks.
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streaks.
     */
    distinct?: StreakScalarFieldEnum | StreakScalarFieldEnum[]
  }

  /**
   * Streak findFirstOrThrow
   */
  export type StreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streaks.
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streaks.
     */
    distinct?: StreakScalarFieldEnum | StreakScalarFieldEnum[]
  }

  /**
   * Streak findMany
   */
  export type StreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streaks to fetch.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Streaks.
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    distinct?: StreakScalarFieldEnum | StreakScalarFieldEnum[]
  }

  /**
   * Streak create
   */
  export type StreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * The data needed to create a Streak.
     */
    data: XOR<StreakCreateInput, StreakUncheckedCreateInput>
  }

  /**
   * Streak createMany
   */
  export type StreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Streaks.
     */
    data: StreakCreateManyInput | StreakCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Streak createManyAndReturn
   */
  export type StreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Streaks.
     */
    data: StreakCreateManyInput | StreakCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Streak update
   */
  export type StreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * The data needed to update a Streak.
     */
    data: XOR<StreakUpdateInput, StreakUncheckedUpdateInput>
    /**
     * Choose, which Streak to update.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak updateMany
   */
  export type StreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Streaks.
     */
    data: XOR<StreakUpdateManyMutationInput, StreakUncheckedUpdateManyInput>
    /**
     * Filter which Streaks to update
     */
    where?: StreakWhereInput
  }

  /**
   * Streak upsert
   */
  export type StreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * The filter to search for the Streak to update in case it exists.
     */
    where: StreakWhereUniqueInput
    /**
     * In case the Streak found by the `where` argument doesn't exist, create a new Streak with this data.
     */
    create: XOR<StreakCreateInput, StreakUncheckedCreateInput>
    /**
     * In case the Streak was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreakUpdateInput, StreakUncheckedUpdateInput>
  }

  /**
   * Streak delete
   */
  export type StreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter which Streak to delete.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak deleteMany
   */
  export type StreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streaks to delete
     */
    where?: StreakWhereInput
  }

  /**
   * Streak without action
   */
  export type StreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    relationshipId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    relationshipId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    status: $Enums.SubscriptionStatus | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    relationshipId: number
    stripeSubscriptionId: number
    stripeCustomerId: number
    status: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    relationshipId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    status?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    relationshipId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    status?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    relationshipId?: true
    stripeSubscriptionId?: true
    stripeCustomerId?: true
    status?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    userId: string
    relationshipId: string | null
    stripeSubscriptionId: string | null
    stripeCustomerId: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    relationshipId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    relationship?: boolean | Subscription$relationshipArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    relationshipId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    relationship?: boolean | Subscription$relationshipArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    relationshipId?: boolean
    stripeSubscriptionId?: boolean
    stripeCustomerId?: boolean
    status?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    relationship?: boolean | Subscription$relationshipArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    relationship?: boolean | Subscription$relationshipArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      relationship: Prisma.$RelationshipPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      relationshipId: string | null
      stripeSubscriptionId: string | null
      stripeCustomerId: string | null
      status: $Enums.SubscriptionStatus
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    relationship<T extends Subscription$relationshipArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$relationshipArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly userId: FieldRef<"Subscription", 'String'>
    readonly relationshipId: FieldRef<"Subscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"Subscription", 'String'>
    readonly stripeCustomerId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly currentPeriodEnd: FieldRef<"Subscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"Subscription", 'Boolean'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }

  /**
   * Subscription.relationship
   */
  export type Subscription$relationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relationship
     */
    select?: RelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationshipInclude<ExtArgs> | null
    where?: RelationshipWhereInput
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model BetaSignup
   */

  export type AggregateBetaSignup = {
    _count: BetaSignupCountAggregateOutputType | null
    _min: BetaSignupMinAggregateOutputType | null
    _max: BetaSignupMaxAggregateOutputType | null
  }

  export type BetaSignupMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
  }

  export type BetaSignupMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
  }

  export type BetaSignupCountAggregateOutputType = {
    id: number
    email: number
    createdAt: number
    _all: number
  }


  export type BetaSignupMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
  }

  export type BetaSignupMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
  }

  export type BetaSignupCountAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    _all?: true
  }

  export type BetaSignupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetaSignup to aggregate.
     */
    where?: BetaSignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetaSignups to fetch.
     */
    orderBy?: BetaSignupOrderByWithRelationInput | BetaSignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BetaSignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetaSignups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetaSignups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BetaSignups
    **/
    _count?: true | BetaSignupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BetaSignupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BetaSignupMaxAggregateInputType
  }

  export type GetBetaSignupAggregateType<T extends BetaSignupAggregateArgs> = {
        [P in keyof T & keyof AggregateBetaSignup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBetaSignup[P]>
      : GetScalarType<T[P], AggregateBetaSignup[P]>
  }




  export type BetaSignupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BetaSignupWhereInput
    orderBy?: BetaSignupOrderByWithAggregationInput | BetaSignupOrderByWithAggregationInput[]
    by: BetaSignupScalarFieldEnum[] | BetaSignupScalarFieldEnum
    having?: BetaSignupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BetaSignupCountAggregateInputType | true
    _min?: BetaSignupMinAggregateInputType
    _max?: BetaSignupMaxAggregateInputType
  }

  export type BetaSignupGroupByOutputType = {
    id: string
    email: string
    createdAt: Date
    _count: BetaSignupCountAggregateOutputType | null
    _min: BetaSignupMinAggregateOutputType | null
    _max: BetaSignupMaxAggregateOutputType | null
  }

  type GetBetaSignupGroupByPayload<T extends BetaSignupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BetaSignupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BetaSignupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BetaSignupGroupByOutputType[P]>
            : GetScalarType<T[P], BetaSignupGroupByOutputType[P]>
        }
      >
    >


  export type BetaSignupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["betaSignup"]>

  export type BetaSignupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["betaSignup"]>

  export type BetaSignupSelectScalar = {
    id?: boolean
    email?: boolean
    createdAt?: boolean
  }


  export type $BetaSignupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BetaSignup"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      createdAt: Date
    }, ExtArgs["result"]["betaSignup"]>
    composites: {}
  }

  type BetaSignupGetPayload<S extends boolean | null | undefined | BetaSignupDefaultArgs> = $Result.GetResult<Prisma.$BetaSignupPayload, S>

  type BetaSignupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BetaSignupFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BetaSignupCountAggregateInputType | true
    }

  export interface BetaSignupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BetaSignup'], meta: { name: 'BetaSignup' } }
    /**
     * Find zero or one BetaSignup that matches the filter.
     * @param {BetaSignupFindUniqueArgs} args - Arguments to find a BetaSignup
     * @example
     * // Get one BetaSignup
     * const betaSignup = await prisma.betaSignup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BetaSignupFindUniqueArgs>(args: SelectSubset<T, BetaSignupFindUniqueArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BetaSignup that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BetaSignupFindUniqueOrThrowArgs} args - Arguments to find a BetaSignup
     * @example
     * // Get one BetaSignup
     * const betaSignup = await prisma.betaSignup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BetaSignupFindUniqueOrThrowArgs>(args: SelectSubset<T, BetaSignupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BetaSignup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupFindFirstArgs} args - Arguments to find a BetaSignup
     * @example
     * // Get one BetaSignup
     * const betaSignup = await prisma.betaSignup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BetaSignupFindFirstArgs>(args?: SelectSubset<T, BetaSignupFindFirstArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BetaSignup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupFindFirstOrThrowArgs} args - Arguments to find a BetaSignup
     * @example
     * // Get one BetaSignup
     * const betaSignup = await prisma.betaSignup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BetaSignupFindFirstOrThrowArgs>(args?: SelectSubset<T, BetaSignupFindFirstOrThrowArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BetaSignups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BetaSignups
     * const betaSignups = await prisma.betaSignup.findMany()
     * 
     * // Get first 10 BetaSignups
     * const betaSignups = await prisma.betaSignup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const betaSignupWithIdOnly = await prisma.betaSignup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BetaSignupFindManyArgs>(args?: SelectSubset<T, BetaSignupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BetaSignup.
     * @param {BetaSignupCreateArgs} args - Arguments to create a BetaSignup.
     * @example
     * // Create one BetaSignup
     * const BetaSignup = await prisma.betaSignup.create({
     *   data: {
     *     // ... data to create a BetaSignup
     *   }
     * })
     * 
     */
    create<T extends BetaSignupCreateArgs>(args: SelectSubset<T, BetaSignupCreateArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BetaSignups.
     * @param {BetaSignupCreateManyArgs} args - Arguments to create many BetaSignups.
     * @example
     * // Create many BetaSignups
     * const betaSignup = await prisma.betaSignup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BetaSignupCreateManyArgs>(args?: SelectSubset<T, BetaSignupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BetaSignups and returns the data saved in the database.
     * @param {BetaSignupCreateManyAndReturnArgs} args - Arguments to create many BetaSignups.
     * @example
     * // Create many BetaSignups
     * const betaSignup = await prisma.betaSignup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BetaSignups and only return the `id`
     * const betaSignupWithIdOnly = await prisma.betaSignup.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BetaSignupCreateManyAndReturnArgs>(args?: SelectSubset<T, BetaSignupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BetaSignup.
     * @param {BetaSignupDeleteArgs} args - Arguments to delete one BetaSignup.
     * @example
     * // Delete one BetaSignup
     * const BetaSignup = await prisma.betaSignup.delete({
     *   where: {
     *     // ... filter to delete one BetaSignup
     *   }
     * })
     * 
     */
    delete<T extends BetaSignupDeleteArgs>(args: SelectSubset<T, BetaSignupDeleteArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BetaSignup.
     * @param {BetaSignupUpdateArgs} args - Arguments to update one BetaSignup.
     * @example
     * // Update one BetaSignup
     * const betaSignup = await prisma.betaSignup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BetaSignupUpdateArgs>(args: SelectSubset<T, BetaSignupUpdateArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BetaSignups.
     * @param {BetaSignupDeleteManyArgs} args - Arguments to filter BetaSignups to delete.
     * @example
     * // Delete a few BetaSignups
     * const { count } = await prisma.betaSignup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BetaSignupDeleteManyArgs>(args?: SelectSubset<T, BetaSignupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BetaSignups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BetaSignups
     * const betaSignup = await prisma.betaSignup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BetaSignupUpdateManyArgs>(args: SelectSubset<T, BetaSignupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BetaSignup.
     * @param {BetaSignupUpsertArgs} args - Arguments to update or create a BetaSignup.
     * @example
     * // Update or create a BetaSignup
     * const betaSignup = await prisma.betaSignup.upsert({
     *   create: {
     *     // ... data to create a BetaSignup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BetaSignup we want to update
     *   }
     * })
     */
    upsert<T extends BetaSignupUpsertArgs>(args: SelectSubset<T, BetaSignupUpsertArgs<ExtArgs>>): Prisma__BetaSignupClient<$Result.GetResult<Prisma.$BetaSignupPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BetaSignups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupCountArgs} args - Arguments to filter BetaSignups to count.
     * @example
     * // Count the number of BetaSignups
     * const count = await prisma.betaSignup.count({
     *   where: {
     *     // ... the filter for the BetaSignups we want to count
     *   }
     * })
    **/
    count<T extends BetaSignupCountArgs>(
      args?: Subset<T, BetaSignupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BetaSignupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BetaSignup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BetaSignupAggregateArgs>(args: Subset<T, BetaSignupAggregateArgs>): Prisma.PrismaPromise<GetBetaSignupAggregateType<T>>

    /**
     * Group by BetaSignup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BetaSignupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BetaSignupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BetaSignupGroupByArgs['orderBy'] }
        : { orderBy?: BetaSignupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BetaSignupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBetaSignupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BetaSignup model
   */
  readonly fields: BetaSignupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BetaSignup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BetaSignupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BetaSignup model
   */ 
  interface BetaSignupFieldRefs {
    readonly id: FieldRef<"BetaSignup", 'String'>
    readonly email: FieldRef<"BetaSignup", 'String'>
    readonly createdAt: FieldRef<"BetaSignup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BetaSignup findUnique
   */
  export type BetaSignupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * Filter, which BetaSignup to fetch.
     */
    where: BetaSignupWhereUniqueInput
  }

  /**
   * BetaSignup findUniqueOrThrow
   */
  export type BetaSignupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * Filter, which BetaSignup to fetch.
     */
    where: BetaSignupWhereUniqueInput
  }

  /**
   * BetaSignup findFirst
   */
  export type BetaSignupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * Filter, which BetaSignup to fetch.
     */
    where?: BetaSignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetaSignups to fetch.
     */
    orderBy?: BetaSignupOrderByWithRelationInput | BetaSignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetaSignups.
     */
    cursor?: BetaSignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetaSignups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetaSignups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetaSignups.
     */
    distinct?: BetaSignupScalarFieldEnum | BetaSignupScalarFieldEnum[]
  }

  /**
   * BetaSignup findFirstOrThrow
   */
  export type BetaSignupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * Filter, which BetaSignup to fetch.
     */
    where?: BetaSignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetaSignups to fetch.
     */
    orderBy?: BetaSignupOrderByWithRelationInput | BetaSignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BetaSignups.
     */
    cursor?: BetaSignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetaSignups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetaSignups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BetaSignups.
     */
    distinct?: BetaSignupScalarFieldEnum | BetaSignupScalarFieldEnum[]
  }

  /**
   * BetaSignup findMany
   */
  export type BetaSignupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * Filter, which BetaSignups to fetch.
     */
    where?: BetaSignupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BetaSignups to fetch.
     */
    orderBy?: BetaSignupOrderByWithRelationInput | BetaSignupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BetaSignups.
     */
    cursor?: BetaSignupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BetaSignups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BetaSignups.
     */
    skip?: number
    distinct?: BetaSignupScalarFieldEnum | BetaSignupScalarFieldEnum[]
  }

  /**
   * BetaSignup create
   */
  export type BetaSignupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * The data needed to create a BetaSignup.
     */
    data: XOR<BetaSignupCreateInput, BetaSignupUncheckedCreateInput>
  }

  /**
   * BetaSignup createMany
   */
  export type BetaSignupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BetaSignups.
     */
    data: BetaSignupCreateManyInput | BetaSignupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetaSignup createManyAndReturn
   */
  export type BetaSignupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BetaSignups.
     */
    data: BetaSignupCreateManyInput | BetaSignupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BetaSignup update
   */
  export type BetaSignupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * The data needed to update a BetaSignup.
     */
    data: XOR<BetaSignupUpdateInput, BetaSignupUncheckedUpdateInput>
    /**
     * Choose, which BetaSignup to update.
     */
    where: BetaSignupWhereUniqueInput
  }

  /**
   * BetaSignup updateMany
   */
  export type BetaSignupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BetaSignups.
     */
    data: XOR<BetaSignupUpdateManyMutationInput, BetaSignupUncheckedUpdateManyInput>
    /**
     * Filter which BetaSignups to update
     */
    where?: BetaSignupWhereInput
  }

  /**
   * BetaSignup upsert
   */
  export type BetaSignupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * The filter to search for the BetaSignup to update in case it exists.
     */
    where: BetaSignupWhereUniqueInput
    /**
     * In case the BetaSignup found by the `where` argument doesn't exist, create a new BetaSignup with this data.
     */
    create: XOR<BetaSignupCreateInput, BetaSignupUncheckedCreateInput>
    /**
     * In case the BetaSignup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BetaSignupUpdateInput, BetaSignupUncheckedUpdateInput>
  }

  /**
   * BetaSignup delete
   */
  export type BetaSignupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
    /**
     * Filter which BetaSignup to delete.
     */
    where: BetaSignupWhereUniqueInput
  }

  /**
   * BetaSignup deleteMany
   */
  export type BetaSignupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BetaSignups to delete
     */
    where?: BetaSignupWhereInput
  }

  /**
   * BetaSignup without action
   */
  export type BetaSignupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BetaSignup
     */
    select?: BetaSignupSelect<ExtArgs> | null
  }


  /**
   * Model QuizSession
   */

  export type AggregateQuizSession = {
    _count: QuizSessionCountAggregateOutputType | null
    _min: QuizSessionMinAggregateOutputType | null
    _max: QuizSessionMaxAggregateOutputType | null
  }

  export type QuizSessionMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    sessionDate: Date | null
    state: $Enums.QuizState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizSessionMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    sessionDate: Date | null
    state: $Enums.QuizState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizSessionCountAggregateOutputType = {
    id: number
    relationshipId: number
    sessionDate: number
    state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizSessionMinAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizSessionMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizSessionCountAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSession to aggregate.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizSessions
    **/
    _count?: true | QuizSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizSessionMaxAggregateInputType
  }

  export type GetQuizSessionAggregateType<T extends QuizSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizSession[P]>
      : GetScalarType<T[P], AggregateQuizSession[P]>
  }




  export type QuizSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizSessionWhereInput
    orderBy?: QuizSessionOrderByWithAggregationInput | QuizSessionOrderByWithAggregationInput[]
    by: QuizSessionScalarFieldEnum[] | QuizSessionScalarFieldEnum
    having?: QuizSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizSessionCountAggregateInputType | true
    _min?: QuizSessionMinAggregateInputType
    _max?: QuizSessionMaxAggregateInputType
  }

  export type QuizSessionGroupByOutputType = {
    id: string
    relationshipId: string
    sessionDate: Date
    state: $Enums.QuizState
    createdAt: Date
    updatedAt: Date
    _count: QuizSessionCountAggregateOutputType | null
    _min: QuizSessionMinAggregateOutputType | null
    _max: QuizSessionMaxAggregateOutputType | null
  }

  type GetQuizSessionGroupByPayload<T extends QuizSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizSessionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizSessionGroupByOutputType[P]>
        }
      >
    >


  export type QuizSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    participations?: boolean | QuizSession$participationsArgs<ExtArgs>
    _count?: boolean | QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizSession"]>

  export type QuizSessionSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    participations?: boolean | QuizSession$participationsArgs<ExtArgs>
    _count?: boolean | QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }

  export type $QuizSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizSession"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      participations: Prisma.$QuizParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      sessionDate: Date
      state: $Enums.QuizState
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizSession"]>
    composites: {}
  }

  type QuizSessionGetPayload<S extends boolean | null | undefined | QuizSessionDefaultArgs> = $Result.GetResult<Prisma.$QuizSessionPayload, S>

  type QuizSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizSessionCountAggregateInputType | true
    }

  export interface QuizSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizSession'], meta: { name: 'QuizSession' } }
    /**
     * Find zero or one QuizSession that matches the filter.
     * @param {QuizSessionFindUniqueArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizSessionFindUniqueArgs>(args: SelectSubset<T, QuizSessionFindUniqueArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuizSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizSessionFindUniqueOrThrowArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuizSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindFirstArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizSessionFindFirstArgs>(args?: SelectSubset<T, QuizSessionFindFirstArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuizSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindFirstOrThrowArgs} args - Arguments to find a QuizSession
     * @example
     * // Get one QuizSession
     * const quizSession = await prisma.quizSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuizSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizSessions
     * const quizSessions = await prisma.quizSession.findMany()
     * 
     * // Get first 10 QuizSessions
     * const quizSessions = await prisma.quizSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizSessionFindManyArgs>(args?: SelectSubset<T, QuizSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuizSession.
     * @param {QuizSessionCreateArgs} args - Arguments to create a QuizSession.
     * @example
     * // Create one QuizSession
     * const QuizSession = await prisma.quizSession.create({
     *   data: {
     *     // ... data to create a QuizSession
     *   }
     * })
     * 
     */
    create<T extends QuizSessionCreateArgs>(args: SelectSubset<T, QuizSessionCreateArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuizSessions.
     * @param {QuizSessionCreateManyArgs} args - Arguments to create many QuizSessions.
     * @example
     * // Create many QuizSessions
     * const quizSession = await prisma.quizSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizSessionCreateManyArgs>(args?: SelectSubset<T, QuizSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizSessions and returns the data saved in the database.
     * @param {QuizSessionCreateManyAndReturnArgs} args - Arguments to create many QuizSessions.
     * @example
     * // Create many QuizSessions
     * const quizSession = await prisma.quizSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizSessions and only return the `id`
     * const quizSessionWithIdOnly = await prisma.quizSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuizSession.
     * @param {QuizSessionDeleteArgs} args - Arguments to delete one QuizSession.
     * @example
     * // Delete one QuizSession
     * const QuizSession = await prisma.quizSession.delete({
     *   where: {
     *     // ... filter to delete one QuizSession
     *   }
     * })
     * 
     */
    delete<T extends QuizSessionDeleteArgs>(args: SelectSubset<T, QuizSessionDeleteArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuizSession.
     * @param {QuizSessionUpdateArgs} args - Arguments to update one QuizSession.
     * @example
     * // Update one QuizSession
     * const quizSession = await prisma.quizSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizSessionUpdateArgs>(args: SelectSubset<T, QuizSessionUpdateArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuizSessions.
     * @param {QuizSessionDeleteManyArgs} args - Arguments to filter QuizSessions to delete.
     * @example
     * // Delete a few QuizSessions
     * const { count } = await prisma.quizSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizSessionDeleteManyArgs>(args?: SelectSubset<T, QuizSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizSessions
     * const quizSession = await prisma.quizSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizSessionUpdateManyArgs>(args: SelectSubset<T, QuizSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizSession.
     * @param {QuizSessionUpsertArgs} args - Arguments to update or create a QuizSession.
     * @example
     * // Update or create a QuizSession
     * const quizSession = await prisma.quizSession.upsert({
     *   create: {
     *     // ... data to create a QuizSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizSession we want to update
     *   }
     * })
     */
    upsert<T extends QuizSessionUpsertArgs>(args: SelectSubset<T, QuizSessionUpsertArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuizSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionCountArgs} args - Arguments to filter QuizSessions to count.
     * @example
     * // Count the number of QuizSessions
     * const count = await prisma.quizSession.count({
     *   where: {
     *     // ... the filter for the QuizSessions we want to count
     *   }
     * })
    **/
    count<T extends QuizSessionCountArgs>(
      args?: Subset<T, QuizSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizSessionAggregateArgs>(args: Subset<T, QuizSessionAggregateArgs>): Prisma.PrismaPromise<GetQuizSessionAggregateType<T>>

    /**
     * Group by QuizSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizSessionGroupByArgs['orderBy'] }
        : { orderBy?: QuizSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizSession model
   */
  readonly fields: QuizSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participations<T extends QuizSession$participationsArgs<ExtArgs> = {}>(args?: Subset<T, QuizSession$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizSession model
   */ 
  interface QuizSessionFieldRefs {
    readonly id: FieldRef<"QuizSession", 'String'>
    readonly relationshipId: FieldRef<"QuizSession", 'String'>
    readonly sessionDate: FieldRef<"QuizSession", 'DateTime'>
    readonly state: FieldRef<"QuizSession", 'QuizState'>
    readonly createdAt: FieldRef<"QuizSession", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizSession findUnique
   */
  export type QuizSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession findUniqueOrThrow
   */
  export type QuizSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession findFirst
   */
  export type QuizSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSessions.
     */
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession findFirstOrThrow
   */
  export type QuizSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSession to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizSessions.
     */
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession findMany
   */
  export type QuizSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter, which QuizSessions to fetch.
     */
    where?: QuizSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizSessions to fetch.
     */
    orderBy?: QuizSessionOrderByWithRelationInput | QuizSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizSessions.
     */
    cursor?: QuizSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizSessions.
     */
    skip?: number
    distinct?: QuizSessionScalarFieldEnum | QuizSessionScalarFieldEnum[]
  }

  /**
   * QuizSession create
   */
  export type QuizSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizSession.
     */
    data: XOR<QuizSessionCreateInput, QuizSessionUncheckedCreateInput>
  }

  /**
   * QuizSession createMany
   */
  export type QuizSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizSessions.
     */
    data: QuizSessionCreateManyInput | QuizSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizSession createManyAndReturn
   */
  export type QuizSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuizSessions.
     */
    data: QuizSessionCreateManyInput | QuizSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizSession update
   */
  export type QuizSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizSession.
     */
    data: XOR<QuizSessionUpdateInput, QuizSessionUncheckedUpdateInput>
    /**
     * Choose, which QuizSession to update.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession updateMany
   */
  export type QuizSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizSessions.
     */
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyInput>
    /**
     * Filter which QuizSessions to update
     */
    where?: QuizSessionWhereInput
  }

  /**
   * QuizSession upsert
   */
  export type QuizSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizSession to update in case it exists.
     */
    where: QuizSessionWhereUniqueInput
    /**
     * In case the QuizSession found by the `where` argument doesn't exist, create a new QuizSession with this data.
     */
    create: XOR<QuizSessionCreateInput, QuizSessionUncheckedCreateInput>
    /**
     * In case the QuizSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizSessionUpdateInput, QuizSessionUncheckedUpdateInput>
  }

  /**
   * QuizSession delete
   */
  export type QuizSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
    /**
     * Filter which QuizSession to delete.
     */
    where: QuizSessionWhereUniqueInput
  }

  /**
   * QuizSession deleteMany
   */
  export type QuizSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizSessions to delete
     */
    where?: QuizSessionWhereInput
  }

  /**
   * QuizSession.participations
   */
  export type QuizSession$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    where?: QuizParticipationWhereInput
    orderBy?: QuizParticipationOrderByWithRelationInput | QuizParticipationOrderByWithRelationInput[]
    cursor?: QuizParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizParticipationScalarFieldEnum | QuizParticipationScalarFieldEnum[]
  }

  /**
   * QuizSession without action
   */
  export type QuizSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizSession
     */
    select?: QuizSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizSessionInclude<ExtArgs> | null
  }


  /**
   * Model QuizParticipation
   */

  export type AggregateQuizParticipation = {
    _count: QuizParticipationCountAggregateOutputType | null
    _min: QuizParticipationMinAggregateOutputType | null
    _max: QuizParticipationMaxAggregateOutputType | null
  }

  export type QuizParticipationMinAggregateOutputType = {
    id: string | null
    quizSessionId: string | null
    userId: string | null
    answerIndices: string | null
    guessIndices: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizParticipationMaxAggregateOutputType = {
    id: string | null
    quizSessionId: string | null
    userId: string | null
    answerIndices: string | null
    guessIndices: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizParticipationCountAggregateOutputType = {
    id: number
    quizSessionId: number
    userId: number
    answerIndices: number
    guessIndices: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizParticipationMinAggregateInputType = {
    id?: true
    quizSessionId?: true
    userId?: true
    answerIndices?: true
    guessIndices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizParticipationMaxAggregateInputType = {
    id?: true
    quizSessionId?: true
    userId?: true
    answerIndices?: true
    guessIndices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizParticipationCountAggregateInputType = {
    id?: true
    quizSessionId?: true
    userId?: true
    answerIndices?: true
    guessIndices?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizParticipation to aggregate.
     */
    where?: QuizParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizParticipations to fetch.
     */
    orderBy?: QuizParticipationOrderByWithRelationInput | QuizParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizParticipations
    **/
    _count?: true | QuizParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizParticipationMaxAggregateInputType
  }

  export type GetQuizParticipationAggregateType<T extends QuizParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizParticipation[P]>
      : GetScalarType<T[P], AggregateQuizParticipation[P]>
  }




  export type QuizParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizParticipationWhereInput
    orderBy?: QuizParticipationOrderByWithAggregationInput | QuizParticipationOrderByWithAggregationInput[]
    by: QuizParticipationScalarFieldEnum[] | QuizParticipationScalarFieldEnum
    having?: QuizParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizParticipationCountAggregateInputType | true
    _min?: QuizParticipationMinAggregateInputType
    _max?: QuizParticipationMaxAggregateInputType
  }

  export type QuizParticipationGroupByOutputType = {
    id: string
    quizSessionId: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt: Date
    updatedAt: Date
    _count: QuizParticipationCountAggregateOutputType | null
    _min: QuizParticipationMinAggregateOutputType | null
    _max: QuizParticipationMaxAggregateOutputType | null
  }

  type GetQuizParticipationGroupByPayload<T extends QuizParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], QuizParticipationGroupByOutputType[P]>
        }
      >
    >


  export type QuizParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizSessionId?: boolean
    userId?: boolean
    answerIndices?: boolean
    guessIndices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizSession?: boolean | QuizSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizParticipation"]>

  export type QuizParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizSessionId?: boolean
    userId?: boolean
    answerIndices?: boolean
    guessIndices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizSession?: boolean | QuizSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizParticipation"]>

  export type QuizParticipationSelectScalar = {
    id?: boolean
    quizSessionId?: boolean
    userId?: boolean
    answerIndices?: boolean
    guessIndices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizSession?: boolean | QuizSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizSession?: boolean | QuizSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizParticipation"
    objects: {
      quizSession: Prisma.$QuizSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizSessionId: string
      userId: string
      answerIndices: string
      guessIndices: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizParticipation"]>
    composites: {}
  }

  type QuizParticipationGetPayload<S extends boolean | null | undefined | QuizParticipationDefaultArgs> = $Result.GetResult<Prisma.$QuizParticipationPayload, S>

  type QuizParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizParticipationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizParticipationCountAggregateInputType | true
    }

  export interface QuizParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizParticipation'], meta: { name: 'QuizParticipation' } }
    /**
     * Find zero or one QuizParticipation that matches the filter.
     * @param {QuizParticipationFindUniqueArgs} args - Arguments to find a QuizParticipation
     * @example
     * // Get one QuizParticipation
     * const quizParticipation = await prisma.quizParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizParticipationFindUniqueArgs>(args: SelectSubset<T, QuizParticipationFindUniqueArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuizParticipation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizParticipationFindUniqueOrThrowArgs} args - Arguments to find a QuizParticipation
     * @example
     * // Get one QuizParticipation
     * const quizParticipation = await prisma.quizParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuizParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationFindFirstArgs} args - Arguments to find a QuizParticipation
     * @example
     * // Get one QuizParticipation
     * const quizParticipation = await prisma.quizParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizParticipationFindFirstArgs>(args?: SelectSubset<T, QuizParticipationFindFirstArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuizParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationFindFirstOrThrowArgs} args - Arguments to find a QuizParticipation
     * @example
     * // Get one QuizParticipation
     * const quizParticipation = await prisma.quizParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuizParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizParticipations
     * const quizParticipations = await prisma.quizParticipation.findMany()
     * 
     * // Get first 10 QuizParticipations
     * const quizParticipations = await prisma.quizParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizParticipationWithIdOnly = await prisma.quizParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizParticipationFindManyArgs>(args?: SelectSubset<T, QuizParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuizParticipation.
     * @param {QuizParticipationCreateArgs} args - Arguments to create a QuizParticipation.
     * @example
     * // Create one QuizParticipation
     * const QuizParticipation = await prisma.quizParticipation.create({
     *   data: {
     *     // ... data to create a QuizParticipation
     *   }
     * })
     * 
     */
    create<T extends QuizParticipationCreateArgs>(args: SelectSubset<T, QuizParticipationCreateArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuizParticipations.
     * @param {QuizParticipationCreateManyArgs} args - Arguments to create many QuizParticipations.
     * @example
     * // Create many QuizParticipations
     * const quizParticipation = await prisma.quizParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizParticipationCreateManyArgs>(args?: SelectSubset<T, QuizParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizParticipations and returns the data saved in the database.
     * @param {QuizParticipationCreateManyAndReturnArgs} args - Arguments to create many QuizParticipations.
     * @example
     * // Create many QuizParticipations
     * const quizParticipation = await prisma.quizParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizParticipations and only return the `id`
     * const quizParticipationWithIdOnly = await prisma.quizParticipation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuizParticipation.
     * @param {QuizParticipationDeleteArgs} args - Arguments to delete one QuizParticipation.
     * @example
     * // Delete one QuizParticipation
     * const QuizParticipation = await prisma.quizParticipation.delete({
     *   where: {
     *     // ... filter to delete one QuizParticipation
     *   }
     * })
     * 
     */
    delete<T extends QuizParticipationDeleteArgs>(args: SelectSubset<T, QuizParticipationDeleteArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuizParticipation.
     * @param {QuizParticipationUpdateArgs} args - Arguments to update one QuizParticipation.
     * @example
     * // Update one QuizParticipation
     * const quizParticipation = await prisma.quizParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizParticipationUpdateArgs>(args: SelectSubset<T, QuizParticipationUpdateArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuizParticipations.
     * @param {QuizParticipationDeleteManyArgs} args - Arguments to filter QuizParticipations to delete.
     * @example
     * // Delete a few QuizParticipations
     * const { count } = await prisma.quizParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizParticipationDeleteManyArgs>(args?: SelectSubset<T, QuizParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizParticipations
     * const quizParticipation = await prisma.quizParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizParticipationUpdateManyArgs>(args: SelectSubset<T, QuizParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizParticipation.
     * @param {QuizParticipationUpsertArgs} args - Arguments to update or create a QuizParticipation.
     * @example
     * // Update or create a QuizParticipation
     * const quizParticipation = await prisma.quizParticipation.upsert({
     *   create: {
     *     // ... data to create a QuizParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizParticipation we want to update
     *   }
     * })
     */
    upsert<T extends QuizParticipationUpsertArgs>(args: SelectSubset<T, QuizParticipationUpsertArgs<ExtArgs>>): Prisma__QuizParticipationClient<$Result.GetResult<Prisma.$QuizParticipationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuizParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationCountArgs} args - Arguments to filter QuizParticipations to count.
     * @example
     * // Count the number of QuizParticipations
     * const count = await prisma.quizParticipation.count({
     *   where: {
     *     // ... the filter for the QuizParticipations we want to count
     *   }
     * })
    **/
    count<T extends QuizParticipationCountArgs>(
      args?: Subset<T, QuizParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizParticipationAggregateArgs>(args: Subset<T, QuizParticipationAggregateArgs>): Prisma.PrismaPromise<GetQuizParticipationAggregateType<T>>

    /**
     * Group by QuizParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizParticipationGroupByArgs['orderBy'] }
        : { orderBy?: QuizParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizParticipation model
   */
  readonly fields: QuizParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizSession<T extends QuizSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizSessionDefaultArgs<ExtArgs>>): Prisma__QuizSessionClient<$Result.GetResult<Prisma.$QuizSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizParticipation model
   */ 
  interface QuizParticipationFieldRefs {
    readonly id: FieldRef<"QuizParticipation", 'String'>
    readonly quizSessionId: FieldRef<"QuizParticipation", 'String'>
    readonly userId: FieldRef<"QuizParticipation", 'String'>
    readonly answerIndices: FieldRef<"QuizParticipation", 'String'>
    readonly guessIndices: FieldRef<"QuizParticipation", 'String'>
    readonly createdAt: FieldRef<"QuizParticipation", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizParticipation findUnique
   */
  export type QuizParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * Filter, which QuizParticipation to fetch.
     */
    where: QuizParticipationWhereUniqueInput
  }

  /**
   * QuizParticipation findUniqueOrThrow
   */
  export type QuizParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * Filter, which QuizParticipation to fetch.
     */
    where: QuizParticipationWhereUniqueInput
  }

  /**
   * QuizParticipation findFirst
   */
  export type QuizParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * Filter, which QuizParticipation to fetch.
     */
    where?: QuizParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizParticipations to fetch.
     */
    orderBy?: QuizParticipationOrderByWithRelationInput | QuizParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizParticipations.
     */
    cursor?: QuizParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizParticipations.
     */
    distinct?: QuizParticipationScalarFieldEnum | QuizParticipationScalarFieldEnum[]
  }

  /**
   * QuizParticipation findFirstOrThrow
   */
  export type QuizParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * Filter, which QuizParticipation to fetch.
     */
    where?: QuizParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizParticipations to fetch.
     */
    orderBy?: QuizParticipationOrderByWithRelationInput | QuizParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizParticipations.
     */
    cursor?: QuizParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizParticipations.
     */
    distinct?: QuizParticipationScalarFieldEnum | QuizParticipationScalarFieldEnum[]
  }

  /**
   * QuizParticipation findMany
   */
  export type QuizParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * Filter, which QuizParticipations to fetch.
     */
    where?: QuizParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizParticipations to fetch.
     */
    orderBy?: QuizParticipationOrderByWithRelationInput | QuizParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizParticipations.
     */
    cursor?: QuizParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizParticipations.
     */
    skip?: number
    distinct?: QuizParticipationScalarFieldEnum | QuizParticipationScalarFieldEnum[]
  }

  /**
   * QuizParticipation create
   */
  export type QuizParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizParticipation.
     */
    data: XOR<QuizParticipationCreateInput, QuizParticipationUncheckedCreateInput>
  }

  /**
   * QuizParticipation createMany
   */
  export type QuizParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizParticipations.
     */
    data: QuizParticipationCreateManyInput | QuizParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizParticipation createManyAndReturn
   */
  export type QuizParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuizParticipations.
     */
    data: QuizParticipationCreateManyInput | QuizParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizParticipation update
   */
  export type QuizParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizParticipation.
     */
    data: XOR<QuizParticipationUpdateInput, QuizParticipationUncheckedUpdateInput>
    /**
     * Choose, which QuizParticipation to update.
     */
    where: QuizParticipationWhereUniqueInput
  }

  /**
   * QuizParticipation updateMany
   */
  export type QuizParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizParticipations.
     */
    data: XOR<QuizParticipationUpdateManyMutationInput, QuizParticipationUncheckedUpdateManyInput>
    /**
     * Filter which QuizParticipations to update
     */
    where?: QuizParticipationWhereInput
  }

  /**
   * QuizParticipation upsert
   */
  export type QuizParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizParticipation to update in case it exists.
     */
    where: QuizParticipationWhereUniqueInput
    /**
     * In case the QuizParticipation found by the `where` argument doesn't exist, create a new QuizParticipation with this data.
     */
    create: XOR<QuizParticipationCreateInput, QuizParticipationUncheckedCreateInput>
    /**
     * In case the QuizParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizParticipationUpdateInput, QuizParticipationUncheckedUpdateInput>
  }

  /**
   * QuizParticipation delete
   */
  export type QuizParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
    /**
     * Filter which QuizParticipation to delete.
     */
    where: QuizParticipationWhereUniqueInput
  }

  /**
   * QuizParticipation deleteMany
   */
  export type QuizParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizParticipations to delete
     */
    where?: QuizParticipationWhereInput
  }

  /**
   * QuizParticipation without action
   */
  export type QuizParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizParticipation
     */
    select?: QuizParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizParticipationInclude<ExtArgs> | null
  }


  /**
   * Model AgreementSession
   */

  export type AggregateAgreementSession = {
    _count: AgreementSessionCountAggregateOutputType | null
    _min: AgreementSessionMinAggregateOutputType | null
    _max: AgreementSessionMaxAggregateOutputType | null
  }

  export type AgreementSessionMinAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    sessionDate: Date | null
    state: $Enums.AgreementState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgreementSessionMaxAggregateOutputType = {
    id: string | null
    relationshipId: string | null
    sessionDate: Date | null
    state: $Enums.AgreementState | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgreementSessionCountAggregateOutputType = {
    id: number
    relationshipId: number
    sessionDate: number
    state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgreementSessionMinAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgreementSessionMaxAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgreementSessionCountAggregateInputType = {
    id?: true
    relationshipId?: true
    sessionDate?: true
    state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgreementSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementSession to aggregate.
     */
    where?: AgreementSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementSessions to fetch.
     */
    orderBy?: AgreementSessionOrderByWithRelationInput | AgreementSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementSessions
    **/
    _count?: true | AgreementSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementSessionMaxAggregateInputType
  }

  export type GetAgreementSessionAggregateType<T extends AgreementSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementSession[P]>
      : GetScalarType<T[P], AggregateAgreementSession[P]>
  }




  export type AgreementSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementSessionWhereInput
    orderBy?: AgreementSessionOrderByWithAggregationInput | AgreementSessionOrderByWithAggregationInput[]
    by: AgreementSessionScalarFieldEnum[] | AgreementSessionScalarFieldEnum
    having?: AgreementSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementSessionCountAggregateInputType | true
    _min?: AgreementSessionMinAggregateInputType
    _max?: AgreementSessionMaxAggregateInputType
  }

  export type AgreementSessionGroupByOutputType = {
    id: string
    relationshipId: string
    sessionDate: Date
    state: $Enums.AgreementState
    createdAt: Date
    updatedAt: Date
    _count: AgreementSessionCountAggregateOutputType | null
    _min: AgreementSessionMinAggregateOutputType | null
    _max: AgreementSessionMaxAggregateOutputType | null
  }

  type GetAgreementSessionGroupByPayload<T extends AgreementSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementSessionGroupByOutputType[P]>
        }
      >
    >


  export type AgreementSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    participations?: boolean | AgreementSession$participationsArgs<ExtArgs>
    _count?: boolean | AgreementSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreementSession"]>

  export type AgreementSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreementSession"]>

  export type AgreementSessionSelectScalar = {
    id?: boolean
    relationshipId?: boolean
    sessionDate?: boolean
    state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgreementSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
    participations?: boolean | AgreementSession$participationsArgs<ExtArgs>
    _count?: boolean | AgreementSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgreementSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relationship?: boolean | RelationshipDefaultArgs<ExtArgs>
  }

  export type $AgreementSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgreementSession"
    objects: {
      relationship: Prisma.$RelationshipPayload<ExtArgs>
      participations: Prisma.$AgreementParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      relationshipId: string
      sessionDate: Date
      state: $Enums.AgreementState
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agreementSession"]>
    composites: {}
  }

  type AgreementSessionGetPayload<S extends boolean | null | undefined | AgreementSessionDefaultArgs> = $Result.GetResult<Prisma.$AgreementSessionPayload, S>

  type AgreementSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgreementSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgreementSessionCountAggregateInputType | true
    }

  export interface AgreementSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgreementSession'], meta: { name: 'AgreementSession' } }
    /**
     * Find zero or one AgreementSession that matches the filter.
     * @param {AgreementSessionFindUniqueArgs} args - Arguments to find a AgreementSession
     * @example
     * // Get one AgreementSession
     * const agreementSession = await prisma.agreementSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgreementSessionFindUniqueArgs>(args: SelectSubset<T, AgreementSessionFindUniqueArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AgreementSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgreementSessionFindUniqueOrThrowArgs} args - Arguments to find a AgreementSession
     * @example
     * // Get one AgreementSession
     * const agreementSession = await prisma.agreementSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgreementSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgreementSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AgreementSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionFindFirstArgs} args - Arguments to find a AgreementSession
     * @example
     * // Get one AgreementSession
     * const agreementSession = await prisma.agreementSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgreementSessionFindFirstArgs>(args?: SelectSubset<T, AgreementSessionFindFirstArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AgreementSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionFindFirstOrThrowArgs} args - Arguments to find a AgreementSession
     * @example
     * // Get one AgreementSession
     * const agreementSession = await prisma.agreementSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgreementSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgreementSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AgreementSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementSessions
     * const agreementSessions = await prisma.agreementSession.findMany()
     * 
     * // Get first 10 AgreementSessions
     * const agreementSessions = await prisma.agreementSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementSessionWithIdOnly = await prisma.agreementSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgreementSessionFindManyArgs>(args?: SelectSubset<T, AgreementSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AgreementSession.
     * @param {AgreementSessionCreateArgs} args - Arguments to create a AgreementSession.
     * @example
     * // Create one AgreementSession
     * const AgreementSession = await prisma.agreementSession.create({
     *   data: {
     *     // ... data to create a AgreementSession
     *   }
     * })
     * 
     */
    create<T extends AgreementSessionCreateArgs>(args: SelectSubset<T, AgreementSessionCreateArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AgreementSessions.
     * @param {AgreementSessionCreateManyArgs} args - Arguments to create many AgreementSessions.
     * @example
     * // Create many AgreementSessions
     * const agreementSession = await prisma.agreementSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgreementSessionCreateManyArgs>(args?: SelectSubset<T, AgreementSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgreementSessions and returns the data saved in the database.
     * @param {AgreementSessionCreateManyAndReturnArgs} args - Arguments to create many AgreementSessions.
     * @example
     * // Create many AgreementSessions
     * const agreementSession = await prisma.agreementSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgreementSessions and only return the `id`
     * const agreementSessionWithIdOnly = await prisma.agreementSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgreementSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AgreementSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AgreementSession.
     * @param {AgreementSessionDeleteArgs} args - Arguments to delete one AgreementSession.
     * @example
     * // Delete one AgreementSession
     * const AgreementSession = await prisma.agreementSession.delete({
     *   where: {
     *     // ... filter to delete one AgreementSession
     *   }
     * })
     * 
     */
    delete<T extends AgreementSessionDeleteArgs>(args: SelectSubset<T, AgreementSessionDeleteArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AgreementSession.
     * @param {AgreementSessionUpdateArgs} args - Arguments to update one AgreementSession.
     * @example
     * // Update one AgreementSession
     * const agreementSession = await prisma.agreementSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgreementSessionUpdateArgs>(args: SelectSubset<T, AgreementSessionUpdateArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AgreementSessions.
     * @param {AgreementSessionDeleteManyArgs} args - Arguments to filter AgreementSessions to delete.
     * @example
     * // Delete a few AgreementSessions
     * const { count } = await prisma.agreementSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgreementSessionDeleteManyArgs>(args?: SelectSubset<T, AgreementSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementSessions
     * const agreementSession = await prisma.agreementSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgreementSessionUpdateManyArgs>(args: SelectSubset<T, AgreementSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementSession.
     * @param {AgreementSessionUpsertArgs} args - Arguments to update or create a AgreementSession.
     * @example
     * // Update or create a AgreementSession
     * const agreementSession = await prisma.agreementSession.upsert({
     *   create: {
     *     // ... data to create a AgreementSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementSession we want to update
     *   }
     * })
     */
    upsert<T extends AgreementSessionUpsertArgs>(args: SelectSubset<T, AgreementSessionUpsertArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AgreementSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionCountArgs} args - Arguments to filter AgreementSessions to count.
     * @example
     * // Count the number of AgreementSessions
     * const count = await prisma.agreementSession.count({
     *   where: {
     *     // ... the filter for the AgreementSessions we want to count
     *   }
     * })
    **/
    count<T extends AgreementSessionCountArgs>(
      args?: Subset<T, AgreementSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementSessionAggregateArgs>(args: Subset<T, AgreementSessionAggregateArgs>): Prisma.PrismaPromise<GetAgreementSessionAggregateType<T>>

    /**
     * Group by AgreementSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementSessionGroupByArgs['orderBy'] }
        : { orderBy?: AgreementSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgreementSession model
   */
  readonly fields: AgreementSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgreementSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relationship<T extends RelationshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationshipDefaultArgs<ExtArgs>>): Prisma__RelationshipClient<$Result.GetResult<Prisma.$RelationshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    participations<T extends AgreementSession$participationsArgs<ExtArgs> = {}>(args?: Subset<T, AgreementSession$participationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgreementSession model
   */ 
  interface AgreementSessionFieldRefs {
    readonly id: FieldRef<"AgreementSession", 'String'>
    readonly relationshipId: FieldRef<"AgreementSession", 'String'>
    readonly sessionDate: FieldRef<"AgreementSession", 'DateTime'>
    readonly state: FieldRef<"AgreementSession", 'AgreementState'>
    readonly createdAt: FieldRef<"AgreementSession", 'DateTime'>
    readonly updatedAt: FieldRef<"AgreementSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgreementSession findUnique
   */
  export type AgreementSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgreementSession to fetch.
     */
    where: AgreementSessionWhereUniqueInput
  }

  /**
   * AgreementSession findUniqueOrThrow
   */
  export type AgreementSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgreementSession to fetch.
     */
    where: AgreementSessionWhereUniqueInput
  }

  /**
   * AgreementSession findFirst
   */
  export type AgreementSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgreementSession to fetch.
     */
    where?: AgreementSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementSessions to fetch.
     */
    orderBy?: AgreementSessionOrderByWithRelationInput | AgreementSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementSessions.
     */
    cursor?: AgreementSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementSessions.
     */
    distinct?: AgreementSessionScalarFieldEnum | AgreementSessionScalarFieldEnum[]
  }

  /**
   * AgreementSession findFirstOrThrow
   */
  export type AgreementSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgreementSession to fetch.
     */
    where?: AgreementSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementSessions to fetch.
     */
    orderBy?: AgreementSessionOrderByWithRelationInput | AgreementSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementSessions.
     */
    cursor?: AgreementSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementSessions.
     */
    distinct?: AgreementSessionScalarFieldEnum | AgreementSessionScalarFieldEnum[]
  }

  /**
   * AgreementSession findMany
   */
  export type AgreementSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * Filter, which AgreementSessions to fetch.
     */
    where?: AgreementSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementSessions to fetch.
     */
    orderBy?: AgreementSessionOrderByWithRelationInput | AgreementSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementSessions.
     */
    cursor?: AgreementSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementSessions.
     */
    skip?: number
    distinct?: AgreementSessionScalarFieldEnum | AgreementSessionScalarFieldEnum[]
  }

  /**
   * AgreementSession create
   */
  export type AgreementSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgreementSession.
     */
    data: XOR<AgreementSessionCreateInput, AgreementSessionUncheckedCreateInput>
  }

  /**
   * AgreementSession createMany
   */
  export type AgreementSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgreementSessions.
     */
    data: AgreementSessionCreateManyInput | AgreementSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgreementSession createManyAndReturn
   */
  export type AgreementSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AgreementSessions.
     */
    data: AgreementSessionCreateManyInput | AgreementSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgreementSession update
   */
  export type AgreementSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgreementSession.
     */
    data: XOR<AgreementSessionUpdateInput, AgreementSessionUncheckedUpdateInput>
    /**
     * Choose, which AgreementSession to update.
     */
    where: AgreementSessionWhereUniqueInput
  }

  /**
   * AgreementSession updateMany
   */
  export type AgreementSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgreementSessions.
     */
    data: XOR<AgreementSessionUpdateManyMutationInput, AgreementSessionUncheckedUpdateManyInput>
    /**
     * Filter which AgreementSessions to update
     */
    where?: AgreementSessionWhereInput
  }

  /**
   * AgreementSession upsert
   */
  export type AgreementSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgreementSession to update in case it exists.
     */
    where: AgreementSessionWhereUniqueInput
    /**
     * In case the AgreementSession found by the `where` argument doesn't exist, create a new AgreementSession with this data.
     */
    create: XOR<AgreementSessionCreateInput, AgreementSessionUncheckedCreateInput>
    /**
     * In case the AgreementSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementSessionUpdateInput, AgreementSessionUncheckedUpdateInput>
  }

  /**
   * AgreementSession delete
   */
  export type AgreementSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
    /**
     * Filter which AgreementSession to delete.
     */
    where: AgreementSessionWhereUniqueInput
  }

  /**
   * AgreementSession deleteMany
   */
  export type AgreementSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementSessions to delete
     */
    where?: AgreementSessionWhereInput
  }

  /**
   * AgreementSession.participations
   */
  export type AgreementSession$participationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    where?: AgreementParticipationWhereInput
    orderBy?: AgreementParticipationOrderByWithRelationInput | AgreementParticipationOrderByWithRelationInput[]
    cursor?: AgreementParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgreementParticipationScalarFieldEnum | AgreementParticipationScalarFieldEnum[]
  }

  /**
   * AgreementSession without action
   */
  export type AgreementSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementSession
     */
    select?: AgreementSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementSessionInclude<ExtArgs> | null
  }


  /**
   * Model AgreementParticipation
   */

  export type AggregateAgreementParticipation = {
    _count: AgreementParticipationCountAggregateOutputType | null
    _min: AgreementParticipationMinAggregateOutputType | null
    _max: AgreementParticipationMaxAggregateOutputType | null
  }

  export type AgreementParticipationMinAggregateOutputType = {
    id: string | null
    agreementSessionId: string | null
    userId: string | null
    answerIndices: string | null
    guessIndices: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgreementParticipationMaxAggregateOutputType = {
    id: string | null
    agreementSessionId: string | null
    userId: string | null
    answerIndices: string | null
    guessIndices: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgreementParticipationCountAggregateOutputType = {
    id: number
    agreementSessionId: number
    userId: number
    answerIndices: number
    guessIndices: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgreementParticipationMinAggregateInputType = {
    id?: true
    agreementSessionId?: true
    userId?: true
    answerIndices?: true
    guessIndices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgreementParticipationMaxAggregateInputType = {
    id?: true
    agreementSessionId?: true
    userId?: true
    answerIndices?: true
    guessIndices?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgreementParticipationCountAggregateInputType = {
    id?: true
    agreementSessionId?: true
    userId?: true
    answerIndices?: true
    guessIndices?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgreementParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementParticipation to aggregate.
     */
    where?: AgreementParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementParticipations to fetch.
     */
    orderBy?: AgreementParticipationOrderByWithRelationInput | AgreementParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementParticipations
    **/
    _count?: true | AgreementParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementParticipationMaxAggregateInputType
  }

  export type GetAgreementParticipationAggregateType<T extends AgreementParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementParticipation[P]>
      : GetScalarType<T[P], AggregateAgreementParticipation[P]>
  }




  export type AgreementParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementParticipationWhereInput
    orderBy?: AgreementParticipationOrderByWithAggregationInput | AgreementParticipationOrderByWithAggregationInput[]
    by: AgreementParticipationScalarFieldEnum[] | AgreementParticipationScalarFieldEnum
    having?: AgreementParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementParticipationCountAggregateInputType | true
    _min?: AgreementParticipationMinAggregateInputType
    _max?: AgreementParticipationMaxAggregateInputType
  }

  export type AgreementParticipationGroupByOutputType = {
    id: string
    agreementSessionId: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt: Date
    updatedAt: Date
    _count: AgreementParticipationCountAggregateOutputType | null
    _min: AgreementParticipationMinAggregateOutputType | null
    _max: AgreementParticipationMaxAggregateOutputType | null
  }

  type GetAgreementParticipationGroupByPayload<T extends AgreementParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementParticipationGroupByOutputType[P]>
        }
      >
    >


  export type AgreementParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreementSessionId?: boolean
    userId?: boolean
    answerIndices?: boolean
    guessIndices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agreementSession?: boolean | AgreementSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreementParticipation"]>

  export type AgreementParticipationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agreementSessionId?: boolean
    userId?: boolean
    answerIndices?: boolean
    guessIndices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agreementSession?: boolean | AgreementSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreementParticipation"]>

  export type AgreementParticipationSelectScalar = {
    id?: boolean
    agreementSessionId?: boolean
    userId?: boolean
    answerIndices?: boolean
    guessIndices?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgreementParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreementSession?: boolean | AgreementSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AgreementParticipationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreementSession?: boolean | AgreementSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AgreementParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgreementParticipation"
    objects: {
      agreementSession: Prisma.$AgreementSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agreementSessionId: string
      userId: string
      answerIndices: string
      guessIndices: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agreementParticipation"]>
    composites: {}
  }

  type AgreementParticipationGetPayload<S extends boolean | null | undefined | AgreementParticipationDefaultArgs> = $Result.GetResult<Prisma.$AgreementParticipationPayload, S>

  type AgreementParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgreementParticipationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgreementParticipationCountAggregateInputType | true
    }

  export interface AgreementParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgreementParticipation'], meta: { name: 'AgreementParticipation' } }
    /**
     * Find zero or one AgreementParticipation that matches the filter.
     * @param {AgreementParticipationFindUniqueArgs} args - Arguments to find a AgreementParticipation
     * @example
     * // Get one AgreementParticipation
     * const agreementParticipation = await prisma.agreementParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgreementParticipationFindUniqueArgs>(args: SelectSubset<T, AgreementParticipationFindUniqueArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AgreementParticipation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgreementParticipationFindUniqueOrThrowArgs} args - Arguments to find a AgreementParticipation
     * @example
     * // Get one AgreementParticipation
     * const agreementParticipation = await prisma.agreementParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgreementParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, AgreementParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AgreementParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationFindFirstArgs} args - Arguments to find a AgreementParticipation
     * @example
     * // Get one AgreementParticipation
     * const agreementParticipation = await prisma.agreementParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgreementParticipationFindFirstArgs>(args?: SelectSubset<T, AgreementParticipationFindFirstArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AgreementParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationFindFirstOrThrowArgs} args - Arguments to find a AgreementParticipation
     * @example
     * // Get one AgreementParticipation
     * const agreementParticipation = await prisma.agreementParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgreementParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, AgreementParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AgreementParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementParticipations
     * const agreementParticipations = await prisma.agreementParticipation.findMany()
     * 
     * // Get first 10 AgreementParticipations
     * const agreementParticipations = await prisma.agreementParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementParticipationWithIdOnly = await prisma.agreementParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgreementParticipationFindManyArgs>(args?: SelectSubset<T, AgreementParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AgreementParticipation.
     * @param {AgreementParticipationCreateArgs} args - Arguments to create a AgreementParticipation.
     * @example
     * // Create one AgreementParticipation
     * const AgreementParticipation = await prisma.agreementParticipation.create({
     *   data: {
     *     // ... data to create a AgreementParticipation
     *   }
     * })
     * 
     */
    create<T extends AgreementParticipationCreateArgs>(args: SelectSubset<T, AgreementParticipationCreateArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AgreementParticipations.
     * @param {AgreementParticipationCreateManyArgs} args - Arguments to create many AgreementParticipations.
     * @example
     * // Create many AgreementParticipations
     * const agreementParticipation = await prisma.agreementParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgreementParticipationCreateManyArgs>(args?: SelectSubset<T, AgreementParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgreementParticipations and returns the data saved in the database.
     * @param {AgreementParticipationCreateManyAndReturnArgs} args - Arguments to create many AgreementParticipations.
     * @example
     * // Create many AgreementParticipations
     * const agreementParticipation = await prisma.agreementParticipation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgreementParticipations and only return the `id`
     * const agreementParticipationWithIdOnly = await prisma.agreementParticipation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgreementParticipationCreateManyAndReturnArgs>(args?: SelectSubset<T, AgreementParticipationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AgreementParticipation.
     * @param {AgreementParticipationDeleteArgs} args - Arguments to delete one AgreementParticipation.
     * @example
     * // Delete one AgreementParticipation
     * const AgreementParticipation = await prisma.agreementParticipation.delete({
     *   where: {
     *     // ... filter to delete one AgreementParticipation
     *   }
     * })
     * 
     */
    delete<T extends AgreementParticipationDeleteArgs>(args: SelectSubset<T, AgreementParticipationDeleteArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AgreementParticipation.
     * @param {AgreementParticipationUpdateArgs} args - Arguments to update one AgreementParticipation.
     * @example
     * // Update one AgreementParticipation
     * const agreementParticipation = await prisma.agreementParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgreementParticipationUpdateArgs>(args: SelectSubset<T, AgreementParticipationUpdateArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AgreementParticipations.
     * @param {AgreementParticipationDeleteManyArgs} args - Arguments to filter AgreementParticipations to delete.
     * @example
     * // Delete a few AgreementParticipations
     * const { count } = await prisma.agreementParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgreementParticipationDeleteManyArgs>(args?: SelectSubset<T, AgreementParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementParticipations
     * const agreementParticipation = await prisma.agreementParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgreementParticipationUpdateManyArgs>(args: SelectSubset<T, AgreementParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementParticipation.
     * @param {AgreementParticipationUpsertArgs} args - Arguments to update or create a AgreementParticipation.
     * @example
     * // Update or create a AgreementParticipation
     * const agreementParticipation = await prisma.agreementParticipation.upsert({
     *   create: {
     *     // ... data to create a AgreementParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementParticipation we want to update
     *   }
     * })
     */
    upsert<T extends AgreementParticipationUpsertArgs>(args: SelectSubset<T, AgreementParticipationUpsertArgs<ExtArgs>>): Prisma__AgreementParticipationClient<$Result.GetResult<Prisma.$AgreementParticipationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AgreementParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationCountArgs} args - Arguments to filter AgreementParticipations to count.
     * @example
     * // Count the number of AgreementParticipations
     * const count = await prisma.agreementParticipation.count({
     *   where: {
     *     // ... the filter for the AgreementParticipations we want to count
     *   }
     * })
    **/
    count<T extends AgreementParticipationCountArgs>(
      args?: Subset<T, AgreementParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementParticipationAggregateArgs>(args: Subset<T, AgreementParticipationAggregateArgs>): Prisma.PrismaPromise<GetAgreementParticipationAggregateType<T>>

    /**
     * Group by AgreementParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementParticipationGroupByArgs['orderBy'] }
        : { orderBy?: AgreementParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgreementParticipation model
   */
  readonly fields: AgreementParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgreementParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agreementSession<T extends AgreementSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgreementSessionDefaultArgs<ExtArgs>>): Prisma__AgreementSessionClient<$Result.GetResult<Prisma.$AgreementSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgreementParticipation model
   */ 
  interface AgreementParticipationFieldRefs {
    readonly id: FieldRef<"AgreementParticipation", 'String'>
    readonly agreementSessionId: FieldRef<"AgreementParticipation", 'String'>
    readonly userId: FieldRef<"AgreementParticipation", 'String'>
    readonly answerIndices: FieldRef<"AgreementParticipation", 'String'>
    readonly guessIndices: FieldRef<"AgreementParticipation", 'String'>
    readonly createdAt: FieldRef<"AgreementParticipation", 'DateTime'>
    readonly updatedAt: FieldRef<"AgreementParticipation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgreementParticipation findUnique
   */
  export type AgreementParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * Filter, which AgreementParticipation to fetch.
     */
    where: AgreementParticipationWhereUniqueInput
  }

  /**
   * AgreementParticipation findUniqueOrThrow
   */
  export type AgreementParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * Filter, which AgreementParticipation to fetch.
     */
    where: AgreementParticipationWhereUniqueInput
  }

  /**
   * AgreementParticipation findFirst
   */
  export type AgreementParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * Filter, which AgreementParticipation to fetch.
     */
    where?: AgreementParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementParticipations to fetch.
     */
    orderBy?: AgreementParticipationOrderByWithRelationInput | AgreementParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementParticipations.
     */
    cursor?: AgreementParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementParticipations.
     */
    distinct?: AgreementParticipationScalarFieldEnum | AgreementParticipationScalarFieldEnum[]
  }

  /**
   * AgreementParticipation findFirstOrThrow
   */
  export type AgreementParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * Filter, which AgreementParticipation to fetch.
     */
    where?: AgreementParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementParticipations to fetch.
     */
    orderBy?: AgreementParticipationOrderByWithRelationInput | AgreementParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementParticipations.
     */
    cursor?: AgreementParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementParticipations.
     */
    distinct?: AgreementParticipationScalarFieldEnum | AgreementParticipationScalarFieldEnum[]
  }

  /**
   * AgreementParticipation findMany
   */
  export type AgreementParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * Filter, which AgreementParticipations to fetch.
     */
    where?: AgreementParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementParticipations to fetch.
     */
    orderBy?: AgreementParticipationOrderByWithRelationInput | AgreementParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementParticipations.
     */
    cursor?: AgreementParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementParticipations.
     */
    skip?: number
    distinct?: AgreementParticipationScalarFieldEnum | AgreementParticipationScalarFieldEnum[]
  }

  /**
   * AgreementParticipation create
   */
  export type AgreementParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a AgreementParticipation.
     */
    data: XOR<AgreementParticipationCreateInput, AgreementParticipationUncheckedCreateInput>
  }

  /**
   * AgreementParticipation createMany
   */
  export type AgreementParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgreementParticipations.
     */
    data: AgreementParticipationCreateManyInput | AgreementParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgreementParticipation createManyAndReturn
   */
  export type AgreementParticipationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AgreementParticipations.
     */
    data: AgreementParticipationCreateManyInput | AgreementParticipationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgreementParticipation update
   */
  export type AgreementParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a AgreementParticipation.
     */
    data: XOR<AgreementParticipationUpdateInput, AgreementParticipationUncheckedUpdateInput>
    /**
     * Choose, which AgreementParticipation to update.
     */
    where: AgreementParticipationWhereUniqueInput
  }

  /**
   * AgreementParticipation updateMany
   */
  export type AgreementParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgreementParticipations.
     */
    data: XOR<AgreementParticipationUpdateManyMutationInput, AgreementParticipationUncheckedUpdateManyInput>
    /**
     * Filter which AgreementParticipations to update
     */
    where?: AgreementParticipationWhereInput
  }

  /**
   * AgreementParticipation upsert
   */
  export type AgreementParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the AgreementParticipation to update in case it exists.
     */
    where: AgreementParticipationWhereUniqueInput
    /**
     * In case the AgreementParticipation found by the `where` argument doesn't exist, create a new AgreementParticipation with this data.
     */
    create: XOR<AgreementParticipationCreateInput, AgreementParticipationUncheckedCreateInput>
    /**
     * In case the AgreementParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementParticipationUpdateInput, AgreementParticipationUncheckedUpdateInput>
  }

  /**
   * AgreementParticipation delete
   */
  export type AgreementParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
    /**
     * Filter which AgreementParticipation to delete.
     */
    where: AgreementParticipationWhereUniqueInput
  }

  /**
   * AgreementParticipation deleteMany
   */
  export type AgreementParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementParticipations to delete
     */
    where?: AgreementParticipationWhereInput
  }

  /**
   * AgreementParticipation without action
   */
  export type AgreementParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementParticipation
     */
    select?: AgreementParticipationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementParticipationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    name: 'name',
    image: 'image',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const RelationshipScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelationshipScalarFieldEnum = (typeof RelationshipScalarFieldEnum)[keyof typeof RelationshipScalarFieldEnum]


  export const RelationshipMemberScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    userId: 'userId',
    role: 'role',
    leftAt: 'leftAt',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RelationshipMemberScalarFieldEnum = (typeof RelationshipMemberScalarFieldEnum)[keyof typeof RelationshipMemberScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    code: 'code',
    relationshipId: 'relationshipId',
    invitedBy: 'invitedBy',
    email: 'email',
    status: 'status',
    expiresAt: 'expiresAt',
    claimedBy: 'claimedBy',
    claimedAt: 'claimedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const PromptScalarFieldEnum: {
    id: 'id',
    text: 'text',
    momentText: 'momentText',
    type: 'type',
    category: 'category',
    tone: 'tone',
    isPremium: 'isPremium',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromptScalarFieldEnum = (typeof PromptScalarFieldEnum)[keyof typeof PromptScalarFieldEnum]


  export const DailySessionScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    sessionDate: 'sessionDate',
    promptId: 'promptId',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailySessionScalarFieldEnum = (typeof DailySessionScalarFieldEnum)[keyof typeof DailySessionScalarFieldEnum]


  export const ResponseScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResponseScalarFieldEnum = (typeof ResponseScalarFieldEnum)[keyof typeof ResponseScalarFieldEnum]


  export const ResponseValidationScalarFieldEnum: {
    id: 'id',
    responseId: 'responseId',
    userId: 'userId',
    reactions: 'reactions',
    acknowledgment: 'acknowledgment'
  };

  export type ResponseValidationScalarFieldEnum = (typeof ResponseValidationScalarFieldEnum)[keyof typeof ResponseValidationScalarFieldEnum]


  export const ReflectionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    content: 'content',
    reaction: 'reaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReflectionScalarFieldEnum = (typeof ReflectionScalarFieldEnum)[keyof typeof ReflectionScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    weekKey: 'weekKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const MeetingEntryScalarFieldEnum: {
    id: 'id',
    meetingId: 'meetingId',
    userId: 'userId',
    wins: 'wins',
    stressors: 'stressors',
    request: 'request',
    plan: 'plan',
    appreciation: 'appreciation',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingEntryScalarFieldEnum = (typeof MeetingEntryScalarFieldEnum)[keyof typeof MeetingEntryScalarFieldEnum]


  export const StreakScalarFieldEnum: {
    relationshipId: 'relationshipId',
    currentCount: 'currentCount',
    longestCount: 'longestCount',
    lastCompletedDate: 'lastCompletedDate'
  };

  export type StreakScalarFieldEnum = (typeof StreakScalarFieldEnum)[keyof typeof StreakScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    relationshipId: 'relationshipId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripeCustomerId: 'stripeCustomerId',
    status: 'status',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const BetaSignupScalarFieldEnum: {
    id: 'id',
    email: 'email',
    createdAt: 'createdAt'
  };

  export type BetaSignupScalarFieldEnum = (typeof BetaSignupScalarFieldEnum)[keyof typeof BetaSignupScalarFieldEnum]


  export const QuizSessionScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    sessionDate: 'sessionDate',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizSessionScalarFieldEnum = (typeof QuizSessionScalarFieldEnum)[keyof typeof QuizSessionScalarFieldEnum]


  export const QuizParticipationScalarFieldEnum: {
    id: 'id',
    quizSessionId: 'quizSessionId',
    userId: 'userId',
    answerIndices: 'answerIndices',
    guessIndices: 'guessIndices',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizParticipationScalarFieldEnum = (typeof QuizParticipationScalarFieldEnum)[keyof typeof QuizParticipationScalarFieldEnum]


  export const AgreementSessionScalarFieldEnum: {
    id: 'id',
    relationshipId: 'relationshipId',
    sessionDate: 'sessionDate',
    state: 'state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgreementSessionScalarFieldEnum = (typeof AgreementSessionScalarFieldEnum)[keyof typeof AgreementSessionScalarFieldEnum]


  export const AgreementParticipationScalarFieldEnum: {
    id: 'id',
    agreementSessionId: 'agreementSessionId',
    userId: 'userId',
    answerIndices: 'answerIndices',
    guessIndices: 'guessIndices',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgreementParticipationScalarFieldEnum = (typeof AgreementParticipationScalarFieldEnum)[keyof typeof AgreementParticipationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'RelationshipStatus'
   */
  export type EnumRelationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipStatus'>
    


  /**
   * Reference to a field of type 'RelationshipStatus[]'
   */
  export type ListEnumRelationshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipStatus[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'PromptType'
   */
  export type EnumPromptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptType'>
    


  /**
   * Reference to a field of type 'PromptType[]'
   */
  export type ListEnumPromptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptType[]'>
    


  /**
   * Reference to a field of type 'PromptCategory'
   */
  export type EnumPromptCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptCategory'>
    


  /**
   * Reference to a field of type 'PromptCategory[]'
   */
  export type ListEnumPromptCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptCategory[]'>
    


  /**
   * Reference to a field of type 'PromptTone'
   */
  export type EnumPromptToneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptTone'>
    


  /**
   * Reference to a field of type 'PromptTone[]'
   */
  export type ListEnumPromptToneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptTone[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SessionState'
   */
  export type EnumSessionStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionState'>
    


  /**
   * Reference to a field of type 'SessionState[]'
   */
  export type ListEnumSessionStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionState[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'QuizState'
   */
  export type EnumQuizStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuizState'>
    


  /**
   * Reference to a field of type 'QuizState[]'
   */
  export type ListEnumQuizStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuizState[]'>
    


  /**
   * Reference to a field of type 'AgreementState'
   */
  export type EnumAgreementStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementState'>
    


  /**
   * Reference to a field of type 'AgreementState[]'
   */
  export type ListEnumAgreementStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgreementState[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    relationshipMembers?: RelationshipMemberListRelationFilter
    invitesSent?: InviteListRelationFilter
    responses?: ResponseListRelationFilter
    reflections?: ReflectionListRelationFilter
    responseValidations?: ResponseValidationListRelationFilter
    quizParticipations?: QuizParticipationListRelationFilter
    agreementParticipations?: AgreementParticipationListRelationFilter
    meetingEntries?: MeetingEntryListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    relationshipMembers?: RelationshipMemberOrderByRelationAggregateInput
    invitesSent?: InviteOrderByRelationAggregateInput
    responses?: ResponseOrderByRelationAggregateInput
    reflections?: ReflectionOrderByRelationAggregateInput
    responseValidations?: ResponseValidationOrderByRelationAggregateInput
    quizParticipations?: QuizParticipationOrderByRelationAggregateInput
    agreementParticipations?: AgreementParticipationOrderByRelationAggregateInput
    meetingEntries?: MeetingEntryOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    relationshipMembers?: RelationshipMemberListRelationFilter
    invitesSent?: InviteListRelationFilter
    responses?: ResponseListRelationFilter
    reflections?: ReflectionListRelationFilter
    responseValidations?: ResponseValidationListRelationFilter
    quizParticipations?: QuizParticipationListRelationFilter
    agreementParticipations?: AgreementParticipationListRelationFilter
    meetingEntries?: MeetingEntryListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type RelationshipWhereInput = {
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    id?: StringFilter<"Relationship"> | string
    name?: StringNullableFilter<"Relationship"> | string | null
    status?: EnumRelationshipStatusFilter<"Relationship"> | $Enums.RelationshipStatus
    createdAt?: DateTimeFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeFilter<"Relationship"> | Date | string
    members?: RelationshipMemberListRelationFilter
    invites?: InviteListRelationFilter
    dailySessions?: DailySessionListRelationFilter
    quizSessions?: QuizSessionListRelationFilter
    agreementSessions?: AgreementSessionListRelationFilter
    meetings?: MeetingListRelationFilter
    streak?: XOR<StreakNullableRelationFilter, StreakWhereInput> | null
    subscriptions?: SubscriptionListRelationFilter
  }

  export type RelationshipOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: RelationshipMemberOrderByRelationAggregateInput
    invites?: InviteOrderByRelationAggregateInput
    dailySessions?: DailySessionOrderByRelationAggregateInput
    quizSessions?: QuizSessionOrderByRelationAggregateInput
    agreementSessions?: AgreementSessionOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    streak?: StreakOrderByWithRelationInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type RelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RelationshipWhereInput | RelationshipWhereInput[]
    OR?: RelationshipWhereInput[]
    NOT?: RelationshipWhereInput | RelationshipWhereInput[]
    name?: StringNullableFilter<"Relationship"> | string | null
    status?: EnumRelationshipStatusFilter<"Relationship"> | $Enums.RelationshipStatus
    createdAt?: DateTimeFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeFilter<"Relationship"> | Date | string
    members?: RelationshipMemberListRelationFilter
    invites?: InviteListRelationFilter
    dailySessions?: DailySessionListRelationFilter
    quizSessions?: QuizSessionListRelationFilter
    agreementSessions?: AgreementSessionListRelationFilter
    meetings?: MeetingListRelationFilter
    streak?: XOR<StreakNullableRelationFilter, StreakWhereInput> | null
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type RelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RelationshipCountOrderByAggregateInput
    _max?: RelationshipMaxOrderByAggregateInput
    _min?: RelationshipMinOrderByAggregateInput
  }

  export type RelationshipScalarWhereWithAggregatesInput = {
    AND?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    OR?: RelationshipScalarWhereWithAggregatesInput[]
    NOT?: RelationshipScalarWhereWithAggregatesInput | RelationshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Relationship"> | string
    name?: StringNullableWithAggregatesFilter<"Relationship"> | string | null
    status?: EnumRelationshipStatusWithAggregatesFilter<"Relationship"> | $Enums.RelationshipStatus
    createdAt?: DateTimeWithAggregatesFilter<"Relationship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Relationship"> | Date | string
  }

  export type RelationshipMemberWhereInput = {
    AND?: RelationshipMemberWhereInput | RelationshipMemberWhereInput[]
    OR?: RelationshipMemberWhereInput[]
    NOT?: RelationshipMemberWhereInput | RelationshipMemberWhereInput[]
    id?: StringFilter<"RelationshipMember"> | string
    relationshipId?: StringFilter<"RelationshipMember"> | string
    userId?: StringFilter<"RelationshipMember"> | string
    role?: StringNullableFilter<"RelationshipMember"> | string | null
    leftAt?: DateTimeNullableFilter<"RelationshipMember"> | Date | string | null
    joinedAt?: DateTimeNullableFilter<"RelationshipMember"> | Date | string | null
    createdAt?: DateTimeFilter<"RelationshipMember"> | Date | string
    updatedAt?: DateTimeFilter<"RelationshipMember"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RelationshipMemberOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RelationshipMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relationshipId_userId?: RelationshipMemberRelationshipIdUserIdCompoundUniqueInput
    AND?: RelationshipMemberWhereInput | RelationshipMemberWhereInput[]
    OR?: RelationshipMemberWhereInput[]
    NOT?: RelationshipMemberWhereInput | RelationshipMemberWhereInput[]
    relationshipId?: StringFilter<"RelationshipMember"> | string
    userId?: StringFilter<"RelationshipMember"> | string
    role?: StringNullableFilter<"RelationshipMember"> | string | null
    leftAt?: DateTimeNullableFilter<"RelationshipMember"> | Date | string | null
    joinedAt?: DateTimeNullableFilter<"RelationshipMember"> | Date | string | null
    createdAt?: DateTimeFilter<"RelationshipMember"> | Date | string
    updatedAt?: DateTimeFilter<"RelationshipMember"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "relationshipId_userId">

  export type RelationshipMemberOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    userId?: SortOrder
    role?: SortOrderInput | SortOrder
    leftAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RelationshipMemberCountOrderByAggregateInput
    _max?: RelationshipMemberMaxOrderByAggregateInput
    _min?: RelationshipMemberMinOrderByAggregateInput
  }

  export type RelationshipMemberScalarWhereWithAggregatesInput = {
    AND?: RelationshipMemberScalarWhereWithAggregatesInput | RelationshipMemberScalarWhereWithAggregatesInput[]
    OR?: RelationshipMemberScalarWhereWithAggregatesInput[]
    NOT?: RelationshipMemberScalarWhereWithAggregatesInput | RelationshipMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RelationshipMember"> | string
    relationshipId?: StringWithAggregatesFilter<"RelationshipMember"> | string
    userId?: StringWithAggregatesFilter<"RelationshipMember"> | string
    role?: StringNullableWithAggregatesFilter<"RelationshipMember"> | string | null
    leftAt?: DateTimeNullableWithAggregatesFilter<"RelationshipMember"> | Date | string | null
    joinedAt?: DateTimeNullableWithAggregatesFilter<"RelationshipMember"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RelationshipMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RelationshipMember"> | Date | string
  }

  export type InviteWhereInput = {
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    id?: StringFilter<"Invite"> | string
    code?: StringFilter<"Invite"> | string
    relationshipId?: StringFilter<"Invite"> | string
    invitedBy?: StringFilter<"Invite"> | string
    email?: StringNullableFilter<"Invite"> | string | null
    status?: EnumInviteStatusFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    claimedBy?: StringNullableFilter<"Invite"> | string | null
    claimedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    updatedAt?: DateTimeFilter<"Invite"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InviteOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    relationshipId?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    claimedBy?: SortOrderInput | SortOrder
    claimedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type InviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    relationshipId?: StringFilter<"Invite"> | string
    invitedBy?: StringFilter<"Invite"> | string
    email?: StringNullableFilter<"Invite"> | string | null
    status?: EnumInviteStatusFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    claimedBy?: StringNullableFilter<"Invite"> | string | null
    claimedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    updatedAt?: DateTimeFilter<"Invite"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type InviteOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    relationshipId?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    claimedBy?: SortOrderInput | SortOrder
    claimedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InviteCountOrderByAggregateInput
    _max?: InviteMaxOrderByAggregateInput
    _min?: InviteMinOrderByAggregateInput
  }

  export type InviteScalarWhereWithAggregatesInput = {
    AND?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    OR?: InviteScalarWhereWithAggregatesInput[]
    NOT?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invite"> | string
    code?: StringWithAggregatesFilter<"Invite"> | string
    relationshipId?: StringWithAggregatesFilter<"Invite"> | string
    invitedBy?: StringWithAggregatesFilter<"Invite"> | string
    email?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    status?: EnumInviteStatusWithAggregatesFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Invite"> | Date | string | null
    claimedBy?: StringNullableWithAggregatesFilter<"Invite"> | string | null
    claimedAt?: DateTimeNullableWithAggregatesFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invite"> | Date | string
  }

  export type PromptWhereInput = {
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    id?: StringFilter<"Prompt"> | string
    text?: StringFilter<"Prompt"> | string
    momentText?: StringNullableFilter<"Prompt"> | string | null
    type?: EnumPromptTypeFilter<"Prompt"> | $Enums.PromptType
    category?: EnumPromptCategoryFilter<"Prompt"> | $Enums.PromptCategory
    tone?: EnumPromptToneNullableFilter<"Prompt"> | $Enums.PromptTone | null
    isPremium?: BoolFilter<"Prompt"> | boolean
    active?: BoolFilter<"Prompt"> | boolean
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    dailySessions?: DailySessionListRelationFilter
  }

  export type PromptOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    momentText?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    tone?: SortOrderInput | SortOrder
    isPremium?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dailySessions?: DailySessionOrderByRelationAggregateInput
  }

  export type PromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromptWhereInput | PromptWhereInput[]
    OR?: PromptWhereInput[]
    NOT?: PromptWhereInput | PromptWhereInput[]
    text?: StringFilter<"Prompt"> | string
    momentText?: StringNullableFilter<"Prompt"> | string | null
    type?: EnumPromptTypeFilter<"Prompt"> | $Enums.PromptType
    category?: EnumPromptCategoryFilter<"Prompt"> | $Enums.PromptCategory
    tone?: EnumPromptToneNullableFilter<"Prompt"> | $Enums.PromptTone | null
    isPremium?: BoolFilter<"Prompt"> | boolean
    active?: BoolFilter<"Prompt"> | boolean
    createdAt?: DateTimeFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeFilter<"Prompt"> | Date | string
    dailySessions?: DailySessionListRelationFilter
  }, "id">

  export type PromptOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    momentText?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    tone?: SortOrderInput | SortOrder
    isPremium?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromptCountOrderByAggregateInput
    _max?: PromptMaxOrderByAggregateInput
    _min?: PromptMinOrderByAggregateInput
  }

  export type PromptScalarWhereWithAggregatesInput = {
    AND?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    OR?: PromptScalarWhereWithAggregatesInput[]
    NOT?: PromptScalarWhereWithAggregatesInput | PromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prompt"> | string
    text?: StringWithAggregatesFilter<"Prompt"> | string
    momentText?: StringNullableWithAggregatesFilter<"Prompt"> | string | null
    type?: EnumPromptTypeWithAggregatesFilter<"Prompt"> | $Enums.PromptType
    category?: EnumPromptCategoryWithAggregatesFilter<"Prompt"> | $Enums.PromptCategory
    tone?: EnumPromptToneNullableWithAggregatesFilter<"Prompt"> | $Enums.PromptTone | null
    isPremium?: BoolWithAggregatesFilter<"Prompt"> | boolean
    active?: BoolWithAggregatesFilter<"Prompt"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prompt"> | Date | string
  }

  export type DailySessionWhereInput = {
    AND?: DailySessionWhereInput | DailySessionWhereInput[]
    OR?: DailySessionWhereInput[]
    NOT?: DailySessionWhereInput | DailySessionWhereInput[]
    id?: StringFilter<"DailySession"> | string
    relationshipId?: StringFilter<"DailySession"> | string
    sessionDate?: DateTimeFilter<"DailySession"> | Date | string
    promptId?: StringNullableFilter<"DailySession"> | string | null
    state?: EnumSessionStateFilter<"DailySession"> | $Enums.SessionState
    createdAt?: DateTimeFilter<"DailySession"> | Date | string
    updatedAt?: DateTimeFilter<"DailySession"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    prompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    responses?: ResponseListRelationFilter
    reflections?: ReflectionListRelationFilter
  }

  export type DailySessionOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    promptId?: SortOrderInput | SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    prompt?: PromptOrderByWithRelationInput
    responses?: ResponseOrderByRelationAggregateInput
    reflections?: ReflectionOrderByRelationAggregateInput
  }

  export type DailySessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relationshipId_sessionDate?: DailySessionRelationshipIdSessionDateCompoundUniqueInput
    AND?: DailySessionWhereInput | DailySessionWhereInput[]
    OR?: DailySessionWhereInput[]
    NOT?: DailySessionWhereInput | DailySessionWhereInput[]
    relationshipId?: StringFilter<"DailySession"> | string
    sessionDate?: DateTimeFilter<"DailySession"> | Date | string
    promptId?: StringNullableFilter<"DailySession"> | string | null
    state?: EnumSessionStateFilter<"DailySession"> | $Enums.SessionState
    createdAt?: DateTimeFilter<"DailySession"> | Date | string
    updatedAt?: DateTimeFilter<"DailySession"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    prompt?: XOR<PromptNullableRelationFilter, PromptWhereInput> | null
    responses?: ResponseListRelationFilter
    reflections?: ReflectionListRelationFilter
  }, "id" | "relationshipId_sessionDate">

  export type DailySessionOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    promptId?: SortOrderInput | SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailySessionCountOrderByAggregateInput
    _max?: DailySessionMaxOrderByAggregateInput
    _min?: DailySessionMinOrderByAggregateInput
  }

  export type DailySessionScalarWhereWithAggregatesInput = {
    AND?: DailySessionScalarWhereWithAggregatesInput | DailySessionScalarWhereWithAggregatesInput[]
    OR?: DailySessionScalarWhereWithAggregatesInput[]
    NOT?: DailySessionScalarWhereWithAggregatesInput | DailySessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailySession"> | string
    relationshipId?: StringWithAggregatesFilter<"DailySession"> | string
    sessionDate?: DateTimeWithAggregatesFilter<"DailySession"> | Date | string
    promptId?: StringNullableWithAggregatesFilter<"DailySession"> | string | null
    state?: EnumSessionStateWithAggregatesFilter<"DailySession"> | $Enums.SessionState
    createdAt?: DateTimeWithAggregatesFilter<"DailySession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailySession"> | Date | string
  }

  export type ResponseWhereInput = {
    AND?: ResponseWhereInput | ResponseWhereInput[]
    OR?: ResponseWhereInput[]
    NOT?: ResponseWhereInput | ResponseWhereInput[]
    id?: StringFilter<"Response"> | string
    sessionId?: StringFilter<"Response"> | string
    userId?: StringFilter<"Response"> | string
    content?: StringNullableFilter<"Response"> | string | null
    createdAt?: DateTimeFilter<"Response"> | Date | string
    updatedAt?: DateTimeFilter<"Response"> | Date | string
    session?: XOR<DailySessionRelationFilter, DailySessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    validations?: ResponseValidationListRelationFilter
  }

  export type ResponseOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: DailySessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    validations?: ResponseValidationOrderByRelationAggregateInput
  }

  export type ResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_userId?: ResponseSessionIdUserIdCompoundUniqueInput
    AND?: ResponseWhereInput | ResponseWhereInput[]
    OR?: ResponseWhereInput[]
    NOT?: ResponseWhereInput | ResponseWhereInput[]
    sessionId?: StringFilter<"Response"> | string
    userId?: StringFilter<"Response"> | string
    content?: StringNullableFilter<"Response"> | string | null
    createdAt?: DateTimeFilter<"Response"> | Date | string
    updatedAt?: DateTimeFilter<"Response"> | Date | string
    session?: XOR<DailySessionRelationFilter, DailySessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    validations?: ResponseValidationListRelationFilter
  }, "id" | "sessionId_userId">

  export type ResponseOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResponseCountOrderByAggregateInput
    _max?: ResponseMaxOrderByAggregateInput
    _min?: ResponseMinOrderByAggregateInput
  }

  export type ResponseScalarWhereWithAggregatesInput = {
    AND?: ResponseScalarWhereWithAggregatesInput | ResponseScalarWhereWithAggregatesInput[]
    OR?: ResponseScalarWhereWithAggregatesInput[]
    NOT?: ResponseScalarWhereWithAggregatesInput | ResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Response"> | string
    sessionId?: StringWithAggregatesFilter<"Response"> | string
    userId?: StringWithAggregatesFilter<"Response"> | string
    content?: StringNullableWithAggregatesFilter<"Response"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Response"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Response"> | Date | string
  }

  export type ResponseValidationWhereInput = {
    AND?: ResponseValidationWhereInput | ResponseValidationWhereInput[]
    OR?: ResponseValidationWhereInput[]
    NOT?: ResponseValidationWhereInput | ResponseValidationWhereInput[]
    id?: StringFilter<"ResponseValidation"> | string
    responseId?: StringFilter<"ResponseValidation"> | string
    userId?: StringFilter<"ResponseValidation"> | string
    reactions?: StringNullableFilter<"ResponseValidation"> | string | null
    acknowledgment?: StringNullableFilter<"ResponseValidation"> | string | null
    response?: XOR<ResponseRelationFilter, ResponseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ResponseValidationOrderByWithRelationInput = {
    id?: SortOrder
    responseId?: SortOrder
    userId?: SortOrder
    reactions?: SortOrderInput | SortOrder
    acknowledgment?: SortOrderInput | SortOrder
    response?: ResponseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ResponseValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    responseId_userId?: ResponseValidationResponseIdUserIdCompoundUniqueInput
    AND?: ResponseValidationWhereInput | ResponseValidationWhereInput[]
    OR?: ResponseValidationWhereInput[]
    NOT?: ResponseValidationWhereInput | ResponseValidationWhereInput[]
    responseId?: StringFilter<"ResponseValidation"> | string
    userId?: StringFilter<"ResponseValidation"> | string
    reactions?: StringNullableFilter<"ResponseValidation"> | string | null
    acknowledgment?: StringNullableFilter<"ResponseValidation"> | string | null
    response?: XOR<ResponseRelationFilter, ResponseWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "responseId_userId">

  export type ResponseValidationOrderByWithAggregationInput = {
    id?: SortOrder
    responseId?: SortOrder
    userId?: SortOrder
    reactions?: SortOrderInput | SortOrder
    acknowledgment?: SortOrderInput | SortOrder
    _count?: ResponseValidationCountOrderByAggregateInput
    _max?: ResponseValidationMaxOrderByAggregateInput
    _min?: ResponseValidationMinOrderByAggregateInput
  }

  export type ResponseValidationScalarWhereWithAggregatesInput = {
    AND?: ResponseValidationScalarWhereWithAggregatesInput | ResponseValidationScalarWhereWithAggregatesInput[]
    OR?: ResponseValidationScalarWhereWithAggregatesInput[]
    NOT?: ResponseValidationScalarWhereWithAggregatesInput | ResponseValidationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResponseValidation"> | string
    responseId?: StringWithAggregatesFilter<"ResponseValidation"> | string
    userId?: StringWithAggregatesFilter<"ResponseValidation"> | string
    reactions?: StringNullableWithAggregatesFilter<"ResponseValidation"> | string | null
    acknowledgment?: StringNullableWithAggregatesFilter<"ResponseValidation"> | string | null
  }

  export type ReflectionWhereInput = {
    AND?: ReflectionWhereInput | ReflectionWhereInput[]
    OR?: ReflectionWhereInput[]
    NOT?: ReflectionWhereInput | ReflectionWhereInput[]
    id?: StringFilter<"Reflection"> | string
    sessionId?: StringFilter<"Reflection"> | string
    userId?: StringFilter<"Reflection"> | string
    content?: StringNullableFilter<"Reflection"> | string | null
    reaction?: StringNullableFilter<"Reflection"> | string | null
    createdAt?: DateTimeFilter<"Reflection"> | Date | string
    updatedAt?: DateTimeFilter<"Reflection"> | Date | string
    session?: XOR<DailySessionRelationFilter, DailySessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReflectionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    reaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: DailySessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReflectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_userId?: ReflectionSessionIdUserIdCompoundUniqueInput
    AND?: ReflectionWhereInput | ReflectionWhereInput[]
    OR?: ReflectionWhereInput[]
    NOT?: ReflectionWhereInput | ReflectionWhereInput[]
    sessionId?: StringFilter<"Reflection"> | string
    userId?: StringFilter<"Reflection"> | string
    content?: StringNullableFilter<"Reflection"> | string | null
    reaction?: StringNullableFilter<"Reflection"> | string | null
    createdAt?: DateTimeFilter<"Reflection"> | Date | string
    updatedAt?: DateTimeFilter<"Reflection"> | Date | string
    session?: XOR<DailySessionRelationFilter, DailySessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionId_userId">

  export type ReflectionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrderInput | SortOrder
    reaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReflectionCountOrderByAggregateInput
    _max?: ReflectionMaxOrderByAggregateInput
    _min?: ReflectionMinOrderByAggregateInput
  }

  export type ReflectionScalarWhereWithAggregatesInput = {
    AND?: ReflectionScalarWhereWithAggregatesInput | ReflectionScalarWhereWithAggregatesInput[]
    OR?: ReflectionScalarWhereWithAggregatesInput[]
    NOT?: ReflectionScalarWhereWithAggregatesInput | ReflectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reflection"> | string
    sessionId?: StringWithAggregatesFilter<"Reflection"> | string
    userId?: StringWithAggregatesFilter<"Reflection"> | string
    content?: StringNullableWithAggregatesFilter<"Reflection"> | string | null
    reaction?: StringNullableWithAggregatesFilter<"Reflection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reflection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Reflection"> | Date | string
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: StringFilter<"Meeting"> | string
    relationshipId?: StringFilter<"Meeting"> | string
    weekKey?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    entries?: MeetingEntryListRelationFilter
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    entries?: MeetingEntryOrderByRelationAggregateInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relationshipId_weekKey?: MeetingRelationshipIdWeekKeyCompoundUniqueInput
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    relationshipId?: StringFilter<"Meeting"> | string
    weekKey?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    entries?: MeetingEntryListRelationFilter
  }, "id" | "relationshipId_weekKey">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meeting"> | string
    relationshipId?: StringWithAggregatesFilter<"Meeting"> | string
    weekKey?: StringWithAggregatesFilter<"Meeting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
  }

  export type MeetingEntryWhereInput = {
    AND?: MeetingEntryWhereInput | MeetingEntryWhereInput[]
    OR?: MeetingEntryWhereInput[]
    NOT?: MeetingEntryWhereInput | MeetingEntryWhereInput[]
    id?: StringFilter<"MeetingEntry"> | string
    meetingId?: StringFilter<"MeetingEntry"> | string
    userId?: StringFilter<"MeetingEntry"> | string
    wins?: StringNullableFilter<"MeetingEntry"> | string | null
    stressors?: StringNullableFilter<"MeetingEntry"> | string | null
    request?: StringNullableFilter<"MeetingEntry"> | string | null
    plan?: StringNullableFilter<"MeetingEntry"> | string | null
    appreciation?: StringNullableFilter<"MeetingEntry"> | string | null
    createdAt?: DateTimeFilter<"MeetingEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingEntry"> | Date | string
    meeting?: XOR<MeetingRelationFilter, MeetingWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MeetingEntryOrderByWithRelationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    wins?: SortOrderInput | SortOrder
    stressors?: SortOrderInput | SortOrder
    request?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    appreciation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meeting?: MeetingOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MeetingEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    meetingId_userId?: MeetingEntryMeetingIdUserIdCompoundUniqueInput
    AND?: MeetingEntryWhereInput | MeetingEntryWhereInput[]
    OR?: MeetingEntryWhereInput[]
    NOT?: MeetingEntryWhereInput | MeetingEntryWhereInput[]
    meetingId?: StringFilter<"MeetingEntry"> | string
    userId?: StringFilter<"MeetingEntry"> | string
    wins?: StringNullableFilter<"MeetingEntry"> | string | null
    stressors?: StringNullableFilter<"MeetingEntry"> | string | null
    request?: StringNullableFilter<"MeetingEntry"> | string | null
    plan?: StringNullableFilter<"MeetingEntry"> | string | null
    appreciation?: StringNullableFilter<"MeetingEntry"> | string | null
    createdAt?: DateTimeFilter<"MeetingEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingEntry"> | Date | string
    meeting?: XOR<MeetingRelationFilter, MeetingWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "meetingId_userId">

  export type MeetingEntryOrderByWithAggregationInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    wins?: SortOrderInput | SortOrder
    stressors?: SortOrderInput | SortOrder
    request?: SortOrderInput | SortOrder
    plan?: SortOrderInput | SortOrder
    appreciation?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingEntryCountOrderByAggregateInput
    _max?: MeetingEntryMaxOrderByAggregateInput
    _min?: MeetingEntryMinOrderByAggregateInput
  }

  export type MeetingEntryScalarWhereWithAggregatesInput = {
    AND?: MeetingEntryScalarWhereWithAggregatesInput | MeetingEntryScalarWhereWithAggregatesInput[]
    OR?: MeetingEntryScalarWhereWithAggregatesInput[]
    NOT?: MeetingEntryScalarWhereWithAggregatesInput | MeetingEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeetingEntry"> | string
    meetingId?: StringWithAggregatesFilter<"MeetingEntry"> | string
    userId?: StringWithAggregatesFilter<"MeetingEntry"> | string
    wins?: StringNullableWithAggregatesFilter<"MeetingEntry"> | string | null
    stressors?: StringNullableWithAggregatesFilter<"MeetingEntry"> | string | null
    request?: StringNullableWithAggregatesFilter<"MeetingEntry"> | string | null
    plan?: StringNullableWithAggregatesFilter<"MeetingEntry"> | string | null
    appreciation?: StringNullableWithAggregatesFilter<"MeetingEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MeetingEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MeetingEntry"> | Date | string
  }

  export type StreakWhereInput = {
    AND?: StreakWhereInput | StreakWhereInput[]
    OR?: StreakWhereInput[]
    NOT?: StreakWhereInput | StreakWhereInput[]
    relationshipId?: StringFilter<"Streak"> | string
    currentCount?: IntFilter<"Streak"> | number
    longestCount?: IntFilter<"Streak"> | number
    lastCompletedDate?: DateTimeNullableFilter<"Streak"> | Date | string | null
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
  }

  export type StreakOrderByWithRelationInput = {
    relationshipId?: SortOrder
    currentCount?: SortOrder
    longestCount?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    relationship?: RelationshipOrderByWithRelationInput
  }

  export type StreakWhereUniqueInput = Prisma.AtLeast<{
    relationshipId?: string
    AND?: StreakWhereInput | StreakWhereInput[]
    OR?: StreakWhereInput[]
    NOT?: StreakWhereInput | StreakWhereInput[]
    currentCount?: IntFilter<"Streak"> | number
    longestCount?: IntFilter<"Streak"> | number
    lastCompletedDate?: DateTimeNullableFilter<"Streak"> | Date | string | null
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
  }, "relationshipId">

  export type StreakOrderByWithAggregationInput = {
    relationshipId?: SortOrder
    currentCount?: SortOrder
    longestCount?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    _count?: StreakCountOrderByAggregateInput
    _avg?: StreakAvgOrderByAggregateInput
    _max?: StreakMaxOrderByAggregateInput
    _min?: StreakMinOrderByAggregateInput
    _sum?: StreakSumOrderByAggregateInput
  }

  export type StreakScalarWhereWithAggregatesInput = {
    AND?: StreakScalarWhereWithAggregatesInput | StreakScalarWhereWithAggregatesInput[]
    OR?: StreakScalarWhereWithAggregatesInput[]
    NOT?: StreakScalarWhereWithAggregatesInput | StreakScalarWhereWithAggregatesInput[]
    relationshipId?: StringWithAggregatesFilter<"Streak"> | string
    currentCount?: IntWithAggregatesFilter<"Streak"> | number
    longestCount?: IntWithAggregatesFilter<"Streak"> | number
    lastCompletedDate?: DateTimeNullableWithAggregatesFilter<"Streak"> | Date | string | null
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    relationshipId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    relationship?: XOR<RelationshipNullableRelationFilter, RelationshipWhereInput> | null
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    relationshipId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    relationship?: RelationshipOrderByWithRelationInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeSubscriptionId?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    userId?: StringFilter<"Subscription"> | string
    relationshipId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    relationship?: XOR<RelationshipNullableRelationFilter, RelationshipWhereInput> | null
  }, "id" | "stripeSubscriptionId">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    relationshipId?: SortOrderInput | SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    userId?: StringWithAggregatesFilter<"Subscription"> | string
    relationshipId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"Subscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type BetaSignupWhereInput = {
    AND?: BetaSignupWhereInput | BetaSignupWhereInput[]
    OR?: BetaSignupWhereInput[]
    NOT?: BetaSignupWhereInput | BetaSignupWhereInput[]
    id?: StringFilter<"BetaSignup"> | string
    email?: StringFilter<"BetaSignup"> | string
    createdAt?: DateTimeFilter<"BetaSignup"> | Date | string
  }

  export type BetaSignupOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type BetaSignupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: BetaSignupWhereInput | BetaSignupWhereInput[]
    OR?: BetaSignupWhereInput[]
    NOT?: BetaSignupWhereInput | BetaSignupWhereInput[]
    createdAt?: DateTimeFilter<"BetaSignup"> | Date | string
  }, "id" | "email">

  export type BetaSignupOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    _count?: BetaSignupCountOrderByAggregateInput
    _max?: BetaSignupMaxOrderByAggregateInput
    _min?: BetaSignupMinOrderByAggregateInput
  }

  export type BetaSignupScalarWhereWithAggregatesInput = {
    AND?: BetaSignupScalarWhereWithAggregatesInput | BetaSignupScalarWhereWithAggregatesInput[]
    OR?: BetaSignupScalarWhereWithAggregatesInput[]
    NOT?: BetaSignupScalarWhereWithAggregatesInput | BetaSignupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BetaSignup"> | string
    email?: StringWithAggregatesFilter<"BetaSignup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BetaSignup"> | Date | string
  }

  export type QuizSessionWhereInput = {
    AND?: QuizSessionWhereInput | QuizSessionWhereInput[]
    OR?: QuizSessionWhereInput[]
    NOT?: QuizSessionWhereInput | QuizSessionWhereInput[]
    id?: StringFilter<"QuizSession"> | string
    relationshipId?: StringFilter<"QuizSession"> | string
    sessionDate?: DateTimeFilter<"QuizSession"> | Date | string
    state?: EnumQuizStateFilter<"QuizSession"> | $Enums.QuizState
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSession"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    participations?: QuizParticipationListRelationFilter
  }

  export type QuizSessionOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    participations?: QuizParticipationOrderByRelationAggregateInput
  }

  export type QuizSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relationshipId_sessionDate?: QuizSessionRelationshipIdSessionDateCompoundUniqueInput
    AND?: QuizSessionWhereInput | QuizSessionWhereInput[]
    OR?: QuizSessionWhereInput[]
    NOT?: QuizSessionWhereInput | QuizSessionWhereInput[]
    relationshipId?: StringFilter<"QuizSession"> | string
    sessionDate?: DateTimeFilter<"QuizSession"> | Date | string
    state?: EnumQuizStateFilter<"QuizSession"> | $Enums.QuizState
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSession"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    participations?: QuizParticipationListRelationFilter
  }, "id" | "relationshipId_sessionDate">

  export type QuizSessionOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizSessionCountOrderByAggregateInput
    _max?: QuizSessionMaxOrderByAggregateInput
    _min?: QuizSessionMinOrderByAggregateInput
  }

  export type QuizSessionScalarWhereWithAggregatesInput = {
    AND?: QuizSessionScalarWhereWithAggregatesInput | QuizSessionScalarWhereWithAggregatesInput[]
    OR?: QuizSessionScalarWhereWithAggregatesInput[]
    NOT?: QuizSessionScalarWhereWithAggregatesInput | QuizSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizSession"> | string
    relationshipId?: StringWithAggregatesFilter<"QuizSession"> | string
    sessionDate?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    state?: EnumQuizStateWithAggregatesFilter<"QuizSession"> | $Enums.QuizState
    createdAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizSession"> | Date | string
  }

  export type QuizParticipationWhereInput = {
    AND?: QuizParticipationWhereInput | QuizParticipationWhereInput[]
    OR?: QuizParticipationWhereInput[]
    NOT?: QuizParticipationWhereInput | QuizParticipationWhereInput[]
    id?: StringFilter<"QuizParticipation"> | string
    quizSessionId?: StringFilter<"QuizParticipation"> | string
    userId?: StringFilter<"QuizParticipation"> | string
    answerIndices?: StringFilter<"QuizParticipation"> | string
    guessIndices?: StringFilter<"QuizParticipation"> | string
    createdAt?: DateTimeFilter<"QuizParticipation"> | Date | string
    updatedAt?: DateTimeFilter<"QuizParticipation"> | Date | string
    quizSession?: XOR<QuizSessionRelationFilter, QuizSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type QuizParticipationOrderByWithRelationInput = {
    id?: SortOrder
    quizSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizSession?: QuizSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type QuizParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quizSessionId_userId?: QuizParticipationQuizSessionIdUserIdCompoundUniqueInput
    AND?: QuizParticipationWhereInput | QuizParticipationWhereInput[]
    OR?: QuizParticipationWhereInput[]
    NOT?: QuizParticipationWhereInput | QuizParticipationWhereInput[]
    quizSessionId?: StringFilter<"QuizParticipation"> | string
    userId?: StringFilter<"QuizParticipation"> | string
    answerIndices?: StringFilter<"QuizParticipation"> | string
    guessIndices?: StringFilter<"QuizParticipation"> | string
    createdAt?: DateTimeFilter<"QuizParticipation"> | Date | string
    updatedAt?: DateTimeFilter<"QuizParticipation"> | Date | string
    quizSession?: XOR<QuizSessionRelationFilter, QuizSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "quizSessionId_userId">

  export type QuizParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    quizSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizParticipationCountOrderByAggregateInput
    _max?: QuizParticipationMaxOrderByAggregateInput
    _min?: QuizParticipationMinOrderByAggregateInput
  }

  export type QuizParticipationScalarWhereWithAggregatesInput = {
    AND?: QuizParticipationScalarWhereWithAggregatesInput | QuizParticipationScalarWhereWithAggregatesInput[]
    OR?: QuizParticipationScalarWhereWithAggregatesInput[]
    NOT?: QuizParticipationScalarWhereWithAggregatesInput | QuizParticipationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizParticipation"> | string
    quizSessionId?: StringWithAggregatesFilter<"QuizParticipation"> | string
    userId?: StringWithAggregatesFilter<"QuizParticipation"> | string
    answerIndices?: StringWithAggregatesFilter<"QuizParticipation"> | string
    guessIndices?: StringWithAggregatesFilter<"QuizParticipation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizParticipation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizParticipation"> | Date | string
  }

  export type AgreementSessionWhereInput = {
    AND?: AgreementSessionWhereInput | AgreementSessionWhereInput[]
    OR?: AgreementSessionWhereInput[]
    NOT?: AgreementSessionWhereInput | AgreementSessionWhereInput[]
    id?: StringFilter<"AgreementSession"> | string
    relationshipId?: StringFilter<"AgreementSession"> | string
    sessionDate?: DateTimeFilter<"AgreementSession"> | Date | string
    state?: EnumAgreementStateFilter<"AgreementSession"> | $Enums.AgreementState
    createdAt?: DateTimeFilter<"AgreementSession"> | Date | string
    updatedAt?: DateTimeFilter<"AgreementSession"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    participations?: AgreementParticipationListRelationFilter
  }

  export type AgreementSessionOrderByWithRelationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    relationship?: RelationshipOrderByWithRelationInput
    participations?: AgreementParticipationOrderByRelationAggregateInput
  }

  export type AgreementSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    relationshipId_sessionDate?: AgreementSessionRelationshipIdSessionDateCompoundUniqueInput
    AND?: AgreementSessionWhereInput | AgreementSessionWhereInput[]
    OR?: AgreementSessionWhereInput[]
    NOT?: AgreementSessionWhereInput | AgreementSessionWhereInput[]
    relationshipId?: StringFilter<"AgreementSession"> | string
    sessionDate?: DateTimeFilter<"AgreementSession"> | Date | string
    state?: EnumAgreementStateFilter<"AgreementSession"> | $Enums.AgreementState
    createdAt?: DateTimeFilter<"AgreementSession"> | Date | string
    updatedAt?: DateTimeFilter<"AgreementSession"> | Date | string
    relationship?: XOR<RelationshipRelationFilter, RelationshipWhereInput>
    participations?: AgreementParticipationListRelationFilter
  }, "id" | "relationshipId_sessionDate">

  export type AgreementSessionOrderByWithAggregationInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgreementSessionCountOrderByAggregateInput
    _max?: AgreementSessionMaxOrderByAggregateInput
    _min?: AgreementSessionMinOrderByAggregateInput
  }

  export type AgreementSessionScalarWhereWithAggregatesInput = {
    AND?: AgreementSessionScalarWhereWithAggregatesInput | AgreementSessionScalarWhereWithAggregatesInput[]
    OR?: AgreementSessionScalarWhereWithAggregatesInput[]
    NOT?: AgreementSessionScalarWhereWithAggregatesInput | AgreementSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgreementSession"> | string
    relationshipId?: StringWithAggregatesFilter<"AgreementSession"> | string
    sessionDate?: DateTimeWithAggregatesFilter<"AgreementSession"> | Date | string
    state?: EnumAgreementStateWithAggregatesFilter<"AgreementSession"> | $Enums.AgreementState
    createdAt?: DateTimeWithAggregatesFilter<"AgreementSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgreementSession"> | Date | string
  }

  export type AgreementParticipationWhereInput = {
    AND?: AgreementParticipationWhereInput | AgreementParticipationWhereInput[]
    OR?: AgreementParticipationWhereInput[]
    NOT?: AgreementParticipationWhereInput | AgreementParticipationWhereInput[]
    id?: StringFilter<"AgreementParticipation"> | string
    agreementSessionId?: StringFilter<"AgreementParticipation"> | string
    userId?: StringFilter<"AgreementParticipation"> | string
    answerIndices?: StringFilter<"AgreementParticipation"> | string
    guessIndices?: StringFilter<"AgreementParticipation"> | string
    createdAt?: DateTimeFilter<"AgreementParticipation"> | Date | string
    updatedAt?: DateTimeFilter<"AgreementParticipation"> | Date | string
    agreementSession?: XOR<AgreementSessionRelationFilter, AgreementSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AgreementParticipationOrderByWithRelationInput = {
    id?: SortOrder
    agreementSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agreementSession?: AgreementSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AgreementParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    agreementSessionId_userId?: AgreementParticipationAgreementSessionIdUserIdCompoundUniqueInput
    AND?: AgreementParticipationWhereInput | AgreementParticipationWhereInput[]
    OR?: AgreementParticipationWhereInput[]
    NOT?: AgreementParticipationWhereInput | AgreementParticipationWhereInput[]
    agreementSessionId?: StringFilter<"AgreementParticipation"> | string
    userId?: StringFilter<"AgreementParticipation"> | string
    answerIndices?: StringFilter<"AgreementParticipation"> | string
    guessIndices?: StringFilter<"AgreementParticipation"> | string
    createdAt?: DateTimeFilter<"AgreementParticipation"> | Date | string
    updatedAt?: DateTimeFilter<"AgreementParticipation"> | Date | string
    agreementSession?: XOR<AgreementSessionRelationFilter, AgreementSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "agreementSessionId_userId">

  export type AgreementParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    agreementSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgreementParticipationCountOrderByAggregateInput
    _max?: AgreementParticipationMaxOrderByAggregateInput
    _min?: AgreementParticipationMinOrderByAggregateInput
  }

  export type AgreementParticipationScalarWhereWithAggregatesInput = {
    AND?: AgreementParticipationScalarWhereWithAggregatesInput | AgreementParticipationScalarWhereWithAggregatesInput[]
    OR?: AgreementParticipationScalarWhereWithAggregatesInput[]
    NOT?: AgreementParticipationScalarWhereWithAggregatesInput | AgreementParticipationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgreementParticipation"> | string
    agreementSessionId?: StringWithAggregatesFilter<"AgreementParticipation"> | string
    userId?: StringWithAggregatesFilter<"AgreementParticipation"> | string
    answerIndices?: StringWithAggregatesFilter<"AgreementParticipation"> | string
    guessIndices?: StringWithAggregatesFilter<"AgreementParticipation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgreementParticipation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgreementParticipation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipCreateInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipCreateManyInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelationshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberCreateInput = {
    id?: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutRelationshipMembersInput
  }

  export type RelationshipMemberUncheckedCreateInput = {
    id?: string
    relationshipId: string
    userId: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelationshipMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutRelationshipMembersNestedInput
  }

  export type RelationshipMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberCreateManyInput = {
    id?: string
    relationshipId: string
    userId: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelationshipMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateInput = {
    id?: string
    code: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutInvitesInput
    sender: UserCreateNestedOneWithoutInvitesSentInput
  }

  export type InviteUncheckedCreateInput = {
    id?: string
    code: string
    relationshipId: string
    invitedBy: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutInvitesNestedInput
    sender?: UserUpdateOneRequiredWithoutInvitesSentNestedInput
  }

  export type InviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteCreateManyInput = {
    id?: string
    code: string
    relationshipId: string
    invitedBy: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptCreateInput = {
    id?: string
    text: string
    momentText?: string | null
    type: $Enums.PromptType
    category: $Enums.PromptCategory
    tone?: $Enums.PromptTone | null
    isPremium?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dailySessions?: DailySessionCreateNestedManyWithoutPromptInput
  }

  export type PromptUncheckedCreateInput = {
    id?: string
    text: string
    momentText?: string | null
    type: $Enums.PromptType
    category: $Enums.PromptCategory
    tone?: $Enums.PromptTone | null
    isPremium?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutPromptInput
  }

  export type PromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    momentText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    category?: EnumPromptCategoryFieldUpdateOperationsInput | $Enums.PromptCategory
    tone?: NullableEnumPromptToneFieldUpdateOperationsInput | $Enums.PromptTone | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailySessions?: DailySessionUpdateManyWithoutPromptNestedInput
  }

  export type PromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    momentText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    category?: EnumPromptCategoryFieldUpdateOperationsInput | $Enums.PromptCategory
    tone?: NullableEnumPromptToneFieldUpdateOperationsInput | $Enums.PromptTone | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dailySessions?: DailySessionUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type PromptCreateManyInput = {
    id?: string
    text: string
    momentText?: string | null
    type: $Enums.PromptType
    category: $Enums.PromptCategory
    tone?: $Enums.PromptTone | null
    isPremium?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    momentText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    category?: EnumPromptCategoryFieldUpdateOperationsInput | $Enums.PromptCategory
    tone?: NullableEnumPromptToneFieldUpdateOperationsInput | $Enums.PromptTone | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    momentText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    category?: EnumPromptCategoryFieldUpdateOperationsInput | $Enums.PromptCategory
    tone?: NullableEnumPromptToneFieldUpdateOperationsInput | $Enums.PromptTone | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailySessionCreateInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutDailySessionsInput
    prompt?: PromptCreateNestedOneWithoutDailySessionsInput
    responses?: ResponseCreateNestedManyWithoutSessionInput
    reflections?: ReflectionCreateNestedManyWithoutSessionInput
  }

  export type DailySessionUncheckedCreateInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    promptId?: string | null
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: ResponseUncheckedCreateNestedManyWithoutSessionInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DailySessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutDailySessionsNestedInput
    prompt?: PromptUpdateOneWithoutDailySessionsNestedInput
    responses?: ResponseUpdateManyWithoutSessionNestedInput
    reflections?: ReflectionUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: ResponseUncheckedUpdateManyWithoutSessionNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionCreateManyInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    promptId?: string | null
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailySessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailySessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseCreateInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DailySessionCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutResponsesInput
    validations?: ResponseValidationCreateNestedManyWithoutResponseInput
  }

  export type ResponseUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validations?: ResponseValidationUncheckedCreateNestedManyWithoutResponseInput
  }

  export type ResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DailySessionUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutResponsesNestedInput
    validations?: ResponseValidationUpdateManyWithoutResponseNestedInput
  }

  export type ResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validations?: ResponseValidationUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type ResponseCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseValidationCreateInput = {
    id?: string
    reactions?: string | null
    acknowledgment?: string | null
    response: ResponseCreateNestedOneWithoutValidationsInput
    user: UserCreateNestedOneWithoutResponseValidationsInput
  }

  export type ResponseValidationUncheckedCreateInput = {
    id?: string
    responseId: string
    userId: string
    reactions?: string | null
    acknowledgment?: string | null
  }

  export type ResponseValidationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: ResponseUpdateOneRequiredWithoutValidationsNestedInput
    user?: UserUpdateOneRequiredWithoutResponseValidationsNestedInput
  }

  export type ResponseValidationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseValidationCreateManyInput = {
    id?: string
    responseId: string
    userId: string
    reactions?: string | null
    acknowledgment?: string | null
  }

  export type ResponseValidationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseValidationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReflectionCreateInput = {
    id?: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DailySessionCreateNestedOneWithoutReflectionsInput
    user: UserCreateNestedOneWithoutReflectionsInput
  }

  export type ReflectionUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReflectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DailySessionUpdateOneRequiredWithoutReflectionsNestedInput
    user?: UserUpdateOneRequiredWithoutReflectionsNestedInput
  }

  export type ReflectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReflectionCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReflectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReflectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateInput = {
    id?: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutMeetingsInput
    entries?: MeetingEntryCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: string
    relationshipId: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: MeetingEntryUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutMeetingsNestedInput
    entries?: MeetingEntryUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: MeetingEntryUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingCreateManyInput = {
    id?: string
    relationshipId: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingEntryCreateInput = {
    id?: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutEntriesInput
    user: UserCreateNestedOneWithoutMeetingEntriesInput
  }

  export type MeetingEntryUncheckedCreateInput = {
    id?: string
    meetingId: string
    userId: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutEntriesNestedInput
    user?: UserUpdateOneRequiredWithoutMeetingEntriesNestedInput
  }

  export type MeetingEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingEntryCreateManyInput = {
    id?: string
    meetingId: string
    userId: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakCreateInput = {
    currentCount?: number
    longestCount?: number
    lastCompletedDate?: Date | string | null
    relationship: RelationshipCreateNestedOneWithoutStreakInput
  }

  export type StreakUncheckedCreateInput = {
    relationshipId: string
    currentCount?: number
    longestCount?: number
    lastCompletedDate?: Date | string | null
  }

  export type StreakUpdateInput = {
    currentCount?: IntFieldUpdateOperationsInput | number
    longestCount?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationship?: RelationshipUpdateOneRequiredWithoutStreakNestedInput
  }

  export type StreakUncheckedUpdateInput = {
    relationshipId?: StringFieldUpdateOperationsInput | string
    currentCount?: IntFieldUpdateOperationsInput | number
    longestCount?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StreakCreateManyInput = {
    relationshipId: string
    currentCount?: number
    longestCount?: number
    lastCompletedDate?: Date | string | null
  }

  export type StreakUpdateManyMutationInput = {
    currentCount?: IntFieldUpdateOperationsInput | number
    longestCount?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StreakUncheckedUpdateManyInput = {
    relationshipId?: StringFieldUpdateOperationsInput | string
    currentCount?: IntFieldUpdateOperationsInput | number
    longestCount?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionCreateInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
    relationship?: RelationshipCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    relationshipId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
    relationship?: RelationshipUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    relationshipId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    userId: string
    relationshipId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    relationshipId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetaSignupCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string
  }

  export type BetaSignupUncheckedCreateInput = {
    id?: string
    email: string
    createdAt?: Date | string
  }

  export type BetaSignupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetaSignupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetaSignupCreateManyInput = {
    id?: string
    email: string
    createdAt?: Date | string
  }

  export type BetaSignupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BetaSignupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionCreateInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutQuizSessionsInput
    participations?: QuizParticipationCreateNestedManyWithoutQuizSessionInput
  }

  export type QuizSessionUncheckedCreateInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: QuizParticipationUncheckedCreateNestedManyWithoutQuizSessionInput
  }

  export type QuizSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutQuizSessionsNestedInput
    participations?: QuizParticipationUpdateManyWithoutQuizSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: QuizParticipationUncheckedUpdateManyWithoutQuizSessionNestedInput
  }

  export type QuizSessionCreateManyInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizParticipationCreateInput = {
    id?: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quizSession: QuizSessionCreateNestedOneWithoutParticipationsInput
    user: UserCreateNestedOneWithoutQuizParticipationsInput
  }

  export type QuizParticipationUncheckedCreateInput = {
    id?: string
    quizSessionId: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizSession?: QuizSessionUpdateOneRequiredWithoutParticipationsNestedInput
    user?: UserUpdateOneRequiredWithoutQuizParticipationsNestedInput
  }

  export type QuizParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizSessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizParticipationCreateManyInput = {
    id?: string
    quizSessionId: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizSessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementSessionCreateInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutAgreementSessionsInput
    participations?: AgreementParticipationCreateNestedManyWithoutAgreementSessionInput
  }

  export type AgreementSessionUncheckedCreateInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: AgreementParticipationUncheckedCreateNestedManyWithoutAgreementSessionInput
  }

  export type AgreementSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutAgreementSessionsNestedInput
    participations?: AgreementParticipationUpdateManyWithoutAgreementSessionNestedInput
  }

  export type AgreementSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: AgreementParticipationUncheckedUpdateManyWithoutAgreementSessionNestedInput
  }

  export type AgreementSessionCreateManyInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationCreateInput = {
    id?: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agreementSession: AgreementSessionCreateNestedOneWithoutParticipationsInput
    user: UserCreateNestedOneWithoutAgreementParticipationsInput
  }

  export type AgreementParticipationUncheckedCreateInput = {
    id?: string
    agreementSessionId: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreementSession?: AgreementSessionUpdateOneRequiredWithoutParticipationsNestedInput
    user?: UserUpdateOneRequiredWithoutAgreementParticipationsNestedInput
  }

  export type AgreementParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementSessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationCreateManyInput = {
    id?: string
    agreementSessionId: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementSessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type RelationshipMemberListRelationFilter = {
    every?: RelationshipMemberWhereInput
    some?: RelationshipMemberWhereInput
    none?: RelationshipMemberWhereInput
  }

  export type InviteListRelationFilter = {
    every?: InviteWhereInput
    some?: InviteWhereInput
    none?: InviteWhereInput
  }

  export type ResponseListRelationFilter = {
    every?: ResponseWhereInput
    some?: ResponseWhereInput
    none?: ResponseWhereInput
  }

  export type ReflectionListRelationFilter = {
    every?: ReflectionWhereInput
    some?: ReflectionWhereInput
    none?: ReflectionWhereInput
  }

  export type ResponseValidationListRelationFilter = {
    every?: ResponseValidationWhereInput
    some?: ResponseValidationWhereInput
    none?: ResponseValidationWhereInput
  }

  export type QuizParticipationListRelationFilter = {
    every?: QuizParticipationWhereInput
    some?: QuizParticipationWhereInput
    none?: QuizParticipationWhereInput
  }

  export type AgreementParticipationListRelationFilter = {
    every?: AgreementParticipationWhereInput
    some?: AgreementParticipationWhereInput
    none?: AgreementParticipationWhereInput
  }

  export type MeetingEntryListRelationFilter = {
    every?: MeetingEntryWhereInput
    some?: MeetingEntryWhereInput
    none?: MeetingEntryWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationshipMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReflectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResponseValidationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgreementParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    image?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumRelationshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipStatus | EnumRelationshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipStatusFilter<$PrismaModel> | $Enums.RelationshipStatus
  }

  export type DailySessionListRelationFilter = {
    every?: DailySessionWhereInput
    some?: DailySessionWhereInput
    none?: DailySessionWhereInput
  }

  export type QuizSessionListRelationFilter = {
    every?: QuizSessionWhereInput
    some?: QuizSessionWhereInput
    none?: QuizSessionWhereInput
  }

  export type AgreementSessionListRelationFilter = {
    every?: AgreementSessionWhereInput
    some?: AgreementSessionWhereInput
    none?: AgreementSessionWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type StreakNullableRelationFilter = {
    is?: StreakWhereInput | null
    isNot?: StreakWhereInput | null
  }

  export type DailySessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgreementSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRelationshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipStatus | EnumRelationshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipStatusFilter<$PrismaModel>
    _max?: NestedEnumRelationshipStatusFilter<$PrismaModel>
  }

  export type RelationshipRelationFilter = {
    is?: RelationshipWhereInput
    isNot?: RelationshipWhereInput
  }

  export type RelationshipMemberRelationshipIdUserIdCompoundUniqueInput = {
    relationshipId: string
    userId: string
  }

  export type RelationshipMemberCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    leftAt?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelationshipMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    leftAt?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RelationshipMemberMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    leftAt?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type InviteCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    relationshipId?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    relationshipId?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InviteMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    relationshipId?: SortOrder
    invitedBy?: SortOrder
    email?: SortOrder
    status?: SortOrder
    expiresAt?: SortOrder
    claimedBy?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type EnumPromptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeFilter<$PrismaModel> | $Enums.PromptType
  }

  export type EnumPromptCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptCategory | EnumPromptCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptCategoryFilter<$PrismaModel> | $Enums.PromptCategory
  }

  export type EnumPromptToneNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptTone | EnumPromptToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromptToneNullableFilter<$PrismaModel> | $Enums.PromptTone | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PromptCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    momentText?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tone?: SortOrder
    isPremium?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    momentText?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tone?: SortOrder
    isPremium?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromptMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    momentText?: SortOrder
    type?: SortOrder
    category?: SortOrder
    tone?: SortOrder
    isPremium?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPromptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptTypeFilter<$PrismaModel>
    _max?: NestedEnumPromptTypeFilter<$PrismaModel>
  }

  export type EnumPromptCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptCategory | EnumPromptCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PromptCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptCategoryFilter<$PrismaModel>
    _max?: NestedEnumPromptCategoryFilter<$PrismaModel>
  }

  export type EnumPromptToneNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptTone | EnumPromptToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromptToneNullableWithAggregatesFilter<$PrismaModel> | $Enums.PromptTone | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPromptToneNullableFilter<$PrismaModel>
    _max?: NestedEnumPromptToneNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumSessionStateFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionState | EnumSessionStateFieldRefInput<$PrismaModel>
    in?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStateFilter<$PrismaModel> | $Enums.SessionState
  }

  export type PromptNullableRelationFilter = {
    is?: PromptWhereInput | null
    isNot?: PromptWhereInput | null
  }

  export type DailySessionRelationshipIdSessionDateCompoundUniqueInput = {
    relationshipId: string
    sessionDate: Date | string
  }

  export type DailySessionCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    promptId?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailySessionMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    promptId?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailySessionMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    promptId?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSessionStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionState | EnumSessionStateFieldRefInput<$PrismaModel>
    in?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStateWithAggregatesFilter<$PrismaModel> | $Enums.SessionState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStateFilter<$PrismaModel>
    _max?: NestedEnumSessionStateFilter<$PrismaModel>
  }

  export type DailySessionRelationFilter = {
    is?: DailySessionWhereInput
    isNot?: DailySessionWhereInput
  }

  export type ResponseSessionIdUserIdCompoundUniqueInput = {
    sessionId: string
    userId: string
  }

  export type ResponseCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponseMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResponseRelationFilter = {
    is?: ResponseWhereInput
    isNot?: ResponseWhereInput
  }

  export type ResponseValidationResponseIdUserIdCompoundUniqueInput = {
    responseId: string
    userId: string
  }

  export type ResponseValidationCountOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    userId?: SortOrder
    reactions?: SortOrder
    acknowledgment?: SortOrder
  }

  export type ResponseValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    userId?: SortOrder
    reactions?: SortOrder
    acknowledgment?: SortOrder
  }

  export type ResponseValidationMinOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    userId?: SortOrder
    reactions?: SortOrder
    acknowledgment?: SortOrder
  }

  export type ReflectionSessionIdUserIdCompoundUniqueInput = {
    sessionId: string
    userId: string
  }

  export type ReflectionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReflectionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReflectionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    reaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingRelationshipIdWeekKeyCompoundUniqueInput = {
    relationshipId: string
    weekKey: string
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    weekKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingRelationFilter = {
    is?: MeetingWhereInput
    isNot?: MeetingWhereInput
  }

  export type MeetingEntryMeetingIdUserIdCompoundUniqueInput = {
    meetingId: string
    userId: string
  }

  export type MeetingEntryCountOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    wins?: SortOrder
    stressors?: SortOrder
    request?: SortOrder
    plan?: SortOrder
    appreciation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    wins?: SortOrder
    stressors?: SortOrder
    request?: SortOrder
    plan?: SortOrder
    appreciation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingEntryMinOrderByAggregateInput = {
    id?: SortOrder
    meetingId?: SortOrder
    userId?: SortOrder
    wins?: SortOrder
    stressors?: SortOrder
    request?: SortOrder
    plan?: SortOrder
    appreciation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StreakCountOrderByAggregateInput = {
    relationshipId?: SortOrder
    currentCount?: SortOrder
    longestCount?: SortOrder
    lastCompletedDate?: SortOrder
  }

  export type StreakAvgOrderByAggregateInput = {
    currentCount?: SortOrder
    longestCount?: SortOrder
  }

  export type StreakMaxOrderByAggregateInput = {
    relationshipId?: SortOrder
    currentCount?: SortOrder
    longestCount?: SortOrder
    lastCompletedDate?: SortOrder
  }

  export type StreakMinOrderByAggregateInput = {
    relationshipId?: SortOrder
    currentCount?: SortOrder
    longestCount?: SortOrder
    lastCompletedDate?: SortOrder
  }

  export type StreakSumOrderByAggregateInput = {
    currentCount?: SortOrder
    longestCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type RelationshipNullableRelationFilter = {
    is?: RelationshipWhereInput | null
    isNot?: RelationshipWhereInput | null
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    relationshipId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    relationshipId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    relationshipId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripeCustomerId?: SortOrder
    status?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type BetaSignupCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type BetaSignupMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type BetaSignupMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumQuizStateFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizState | EnumQuizStateFieldRefInput<$PrismaModel>
    in?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStateFilter<$PrismaModel> | $Enums.QuizState
  }

  export type QuizSessionRelationshipIdSessionDateCompoundUniqueInput = {
    relationshipId: string
    sessionDate: Date | string
  }

  export type QuizSessionCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSessionMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQuizStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizState | EnumQuizStateFieldRefInput<$PrismaModel>
    in?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStateWithAggregatesFilter<$PrismaModel> | $Enums.QuizState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuizStateFilter<$PrismaModel>
    _max?: NestedEnumQuizStateFilter<$PrismaModel>
  }

  export type QuizSessionRelationFilter = {
    is?: QuizSessionWhereInput
    isNot?: QuizSessionWhereInput
  }

  export type QuizParticipationQuizSessionIdUserIdCompoundUniqueInput = {
    quizSessionId: string
    userId: string
  }

  export type QuizParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    quizSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    quizSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    quizSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgreementStateFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementState | EnumAgreementStateFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStateFilter<$PrismaModel> | $Enums.AgreementState
  }

  export type AgreementSessionRelationshipIdSessionDateCompoundUniqueInput = {
    relationshipId: string
    sessionDate: Date | string
  }

  export type AgreementSessionCountOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgreementSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgreementSessionMinOrderByAggregateInput = {
    id?: SortOrder
    relationshipId?: SortOrder
    sessionDate?: SortOrder
    state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAgreementStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementState | EnumAgreementStateFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStateWithAggregatesFilter<$PrismaModel> | $Enums.AgreementState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStateFilter<$PrismaModel>
    _max?: NestedEnumAgreementStateFilter<$PrismaModel>
  }

  export type AgreementSessionRelationFilter = {
    is?: AgreementSessionWhereInput
    isNot?: AgreementSessionWhereInput
  }

  export type AgreementParticipationAgreementSessionIdUserIdCompoundUniqueInput = {
    agreementSessionId: string
    userId: string
  }

  export type AgreementParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    agreementSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgreementParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    agreementSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgreementParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    agreementSessionId?: SortOrder
    userId?: SortOrder
    answerIndices?: SortOrder
    guessIndices?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RelationshipMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<RelationshipMemberCreateWithoutUserInput, RelationshipMemberUncheckedCreateWithoutUserInput> | RelationshipMemberCreateWithoutUserInput[] | RelationshipMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutUserInput | RelationshipMemberCreateOrConnectWithoutUserInput[]
    createMany?: RelationshipMemberCreateManyUserInputEnvelope
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutSenderInput = {
    create?: XOR<InviteCreateWithoutSenderInput, InviteUncheckedCreateWithoutSenderInput> | InviteCreateWithoutSenderInput[] | InviteUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSenderInput | InviteCreateOrConnectWithoutSenderInput[]
    createMany?: InviteCreateManySenderInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type ResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<ResponseCreateWithoutUserInput, ResponseUncheckedCreateWithoutUserInput> | ResponseCreateWithoutUserInput[] | ResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutUserInput | ResponseCreateOrConnectWithoutUserInput[]
    createMany?: ResponseCreateManyUserInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ReflectionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReflectionCreateWithoutUserInput, ReflectionUncheckedCreateWithoutUserInput> | ReflectionCreateWithoutUserInput[] | ReflectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutUserInput | ReflectionCreateOrConnectWithoutUserInput[]
    createMany?: ReflectionCreateManyUserInputEnvelope
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
  }

  export type ResponseValidationCreateNestedManyWithoutUserInput = {
    create?: XOR<ResponseValidationCreateWithoutUserInput, ResponseValidationUncheckedCreateWithoutUserInput> | ResponseValidationCreateWithoutUserInput[] | ResponseValidationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutUserInput | ResponseValidationCreateOrConnectWithoutUserInput[]
    createMany?: ResponseValidationCreateManyUserInputEnvelope
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
  }

  export type QuizParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizParticipationCreateWithoutUserInput, QuizParticipationUncheckedCreateWithoutUserInput> | QuizParticipationCreateWithoutUserInput[] | QuizParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutUserInput | QuizParticipationCreateOrConnectWithoutUserInput[]
    createMany?: QuizParticipationCreateManyUserInputEnvelope
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
  }

  export type AgreementParticipationCreateNestedManyWithoutUserInput = {
    create?: XOR<AgreementParticipationCreateWithoutUserInput, AgreementParticipationUncheckedCreateWithoutUserInput> | AgreementParticipationCreateWithoutUserInput[] | AgreementParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutUserInput | AgreementParticipationCreateOrConnectWithoutUserInput[]
    createMany?: AgreementParticipationCreateManyUserInputEnvelope
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
  }

  export type MeetingEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingEntryCreateWithoutUserInput, MeetingEntryUncheckedCreateWithoutUserInput> | MeetingEntryCreateWithoutUserInput[] | MeetingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutUserInput | MeetingEntryCreateOrConnectWithoutUserInput[]
    createMany?: MeetingEntryCreateManyUserInputEnvelope
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type RelationshipMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RelationshipMemberCreateWithoutUserInput, RelationshipMemberUncheckedCreateWithoutUserInput> | RelationshipMemberCreateWithoutUserInput[] | RelationshipMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutUserInput | RelationshipMemberCreateOrConnectWithoutUserInput[]
    createMany?: RelationshipMemberCreateManyUserInputEnvelope
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<InviteCreateWithoutSenderInput, InviteUncheckedCreateWithoutSenderInput> | InviteCreateWithoutSenderInput[] | InviteUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSenderInput | InviteCreateOrConnectWithoutSenderInput[]
    createMany?: InviteCreateManySenderInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type ResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResponseCreateWithoutUserInput, ResponseUncheckedCreateWithoutUserInput> | ResponseCreateWithoutUserInput[] | ResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutUserInput | ResponseCreateOrConnectWithoutUserInput[]
    createMany?: ResponseCreateManyUserInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ReflectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReflectionCreateWithoutUserInput, ReflectionUncheckedCreateWithoutUserInput> | ReflectionCreateWithoutUserInput[] | ReflectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutUserInput | ReflectionCreateOrConnectWithoutUserInput[]
    createMany?: ReflectionCreateManyUserInputEnvelope
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
  }

  export type ResponseValidationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResponseValidationCreateWithoutUserInput, ResponseValidationUncheckedCreateWithoutUserInput> | ResponseValidationCreateWithoutUserInput[] | ResponseValidationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutUserInput | ResponseValidationCreateOrConnectWithoutUserInput[]
    createMany?: ResponseValidationCreateManyUserInputEnvelope
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
  }

  export type QuizParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizParticipationCreateWithoutUserInput, QuizParticipationUncheckedCreateWithoutUserInput> | QuizParticipationCreateWithoutUserInput[] | QuizParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutUserInput | QuizParticipationCreateOrConnectWithoutUserInput[]
    createMany?: QuizParticipationCreateManyUserInputEnvelope
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
  }

  export type AgreementParticipationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AgreementParticipationCreateWithoutUserInput, AgreementParticipationUncheckedCreateWithoutUserInput> | AgreementParticipationCreateWithoutUserInput[] | AgreementParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutUserInput | AgreementParticipationCreateOrConnectWithoutUserInput[]
    createMany?: AgreementParticipationCreateManyUserInputEnvelope
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
  }

  export type MeetingEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MeetingEntryCreateWithoutUserInput, MeetingEntryUncheckedCreateWithoutUserInput> | MeetingEntryCreateWithoutUserInput[] | MeetingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutUserInput | MeetingEntryCreateOrConnectWithoutUserInput[]
    createMany?: MeetingEntryCreateManyUserInputEnvelope
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RelationshipMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<RelationshipMemberCreateWithoutUserInput, RelationshipMemberUncheckedCreateWithoutUserInput> | RelationshipMemberCreateWithoutUserInput[] | RelationshipMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutUserInput | RelationshipMemberCreateOrConnectWithoutUserInput[]
    upsert?: RelationshipMemberUpsertWithWhereUniqueWithoutUserInput | RelationshipMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RelationshipMemberCreateManyUserInputEnvelope
    set?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    disconnect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    delete?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    update?: RelationshipMemberUpdateWithWhereUniqueWithoutUserInput | RelationshipMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RelationshipMemberUpdateManyWithWhereWithoutUserInput | RelationshipMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RelationshipMemberScalarWhereInput | RelationshipMemberScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutSenderNestedInput = {
    create?: XOR<InviteCreateWithoutSenderInput, InviteUncheckedCreateWithoutSenderInput> | InviteCreateWithoutSenderInput[] | InviteUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSenderInput | InviteCreateOrConnectWithoutSenderInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutSenderInput | InviteUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: InviteCreateManySenderInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutSenderInput | InviteUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutSenderInput | InviteUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type ResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResponseCreateWithoutUserInput, ResponseUncheckedCreateWithoutUserInput> | ResponseCreateWithoutUserInput[] | ResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutUserInput | ResponseCreateOrConnectWithoutUserInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutUserInput | ResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResponseCreateManyUserInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutUserInput | ResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutUserInput | ResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ReflectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReflectionCreateWithoutUserInput, ReflectionUncheckedCreateWithoutUserInput> | ReflectionCreateWithoutUserInput[] | ReflectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutUserInput | ReflectionCreateOrConnectWithoutUserInput[]
    upsert?: ReflectionUpsertWithWhereUniqueWithoutUserInput | ReflectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReflectionCreateManyUserInputEnvelope
    set?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    disconnect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    delete?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    update?: ReflectionUpdateWithWhereUniqueWithoutUserInput | ReflectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReflectionUpdateManyWithWhereWithoutUserInput | ReflectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReflectionScalarWhereInput | ReflectionScalarWhereInput[]
  }

  export type ResponseValidationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResponseValidationCreateWithoutUserInput, ResponseValidationUncheckedCreateWithoutUserInput> | ResponseValidationCreateWithoutUserInput[] | ResponseValidationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutUserInput | ResponseValidationCreateOrConnectWithoutUserInput[]
    upsert?: ResponseValidationUpsertWithWhereUniqueWithoutUserInput | ResponseValidationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResponseValidationCreateManyUserInputEnvelope
    set?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    disconnect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    delete?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    update?: ResponseValidationUpdateWithWhereUniqueWithoutUserInput | ResponseValidationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResponseValidationUpdateManyWithWhereWithoutUserInput | ResponseValidationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResponseValidationScalarWhereInput | ResponseValidationScalarWhereInput[]
  }

  export type QuizParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizParticipationCreateWithoutUserInput, QuizParticipationUncheckedCreateWithoutUserInput> | QuizParticipationCreateWithoutUserInput[] | QuizParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutUserInput | QuizParticipationCreateOrConnectWithoutUserInput[]
    upsert?: QuizParticipationUpsertWithWhereUniqueWithoutUserInput | QuizParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizParticipationCreateManyUserInputEnvelope
    set?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    disconnect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    delete?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    update?: QuizParticipationUpdateWithWhereUniqueWithoutUserInput | QuizParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizParticipationUpdateManyWithWhereWithoutUserInput | QuizParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizParticipationScalarWhereInput | QuizParticipationScalarWhereInput[]
  }

  export type AgreementParticipationUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgreementParticipationCreateWithoutUserInput, AgreementParticipationUncheckedCreateWithoutUserInput> | AgreementParticipationCreateWithoutUserInput[] | AgreementParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutUserInput | AgreementParticipationCreateOrConnectWithoutUserInput[]
    upsert?: AgreementParticipationUpsertWithWhereUniqueWithoutUserInput | AgreementParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgreementParticipationCreateManyUserInputEnvelope
    set?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    disconnect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    delete?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    update?: AgreementParticipationUpdateWithWhereUniqueWithoutUserInput | AgreementParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgreementParticipationUpdateManyWithWhereWithoutUserInput | AgreementParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgreementParticipationScalarWhereInput | AgreementParticipationScalarWhereInput[]
  }

  export type MeetingEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingEntryCreateWithoutUserInput, MeetingEntryUncheckedCreateWithoutUserInput> | MeetingEntryCreateWithoutUserInput[] | MeetingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutUserInput | MeetingEntryCreateOrConnectWithoutUserInput[]
    upsert?: MeetingEntryUpsertWithWhereUniqueWithoutUserInput | MeetingEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingEntryCreateManyUserInputEnvelope
    set?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    disconnect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    delete?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    update?: MeetingEntryUpdateWithWhereUniqueWithoutUserInput | MeetingEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingEntryUpdateManyWithWhereWithoutUserInput | MeetingEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingEntryScalarWhereInput | MeetingEntryScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RelationshipMemberCreateWithoutUserInput, RelationshipMemberUncheckedCreateWithoutUserInput> | RelationshipMemberCreateWithoutUserInput[] | RelationshipMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutUserInput | RelationshipMemberCreateOrConnectWithoutUserInput[]
    upsert?: RelationshipMemberUpsertWithWhereUniqueWithoutUserInput | RelationshipMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RelationshipMemberCreateManyUserInputEnvelope
    set?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    disconnect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    delete?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    update?: RelationshipMemberUpdateWithWhereUniqueWithoutUserInput | RelationshipMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RelationshipMemberUpdateManyWithWhereWithoutUserInput | RelationshipMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RelationshipMemberScalarWhereInput | RelationshipMemberScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<InviteCreateWithoutSenderInput, InviteUncheckedCreateWithoutSenderInput> | InviteCreateWithoutSenderInput[] | InviteUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutSenderInput | InviteCreateOrConnectWithoutSenderInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutSenderInput | InviteUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: InviteCreateManySenderInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutSenderInput | InviteUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutSenderInput | InviteUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type ResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResponseCreateWithoutUserInput, ResponseUncheckedCreateWithoutUserInput> | ResponseCreateWithoutUserInput[] | ResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutUserInput | ResponseCreateOrConnectWithoutUserInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutUserInput | ResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResponseCreateManyUserInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutUserInput | ResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutUserInput | ResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ReflectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReflectionCreateWithoutUserInput, ReflectionUncheckedCreateWithoutUserInput> | ReflectionCreateWithoutUserInput[] | ReflectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutUserInput | ReflectionCreateOrConnectWithoutUserInput[]
    upsert?: ReflectionUpsertWithWhereUniqueWithoutUserInput | ReflectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReflectionCreateManyUserInputEnvelope
    set?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    disconnect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    delete?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    update?: ReflectionUpdateWithWhereUniqueWithoutUserInput | ReflectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReflectionUpdateManyWithWhereWithoutUserInput | ReflectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReflectionScalarWhereInput | ReflectionScalarWhereInput[]
  }

  export type ResponseValidationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResponseValidationCreateWithoutUserInput, ResponseValidationUncheckedCreateWithoutUserInput> | ResponseValidationCreateWithoutUserInput[] | ResponseValidationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutUserInput | ResponseValidationCreateOrConnectWithoutUserInput[]
    upsert?: ResponseValidationUpsertWithWhereUniqueWithoutUserInput | ResponseValidationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResponseValidationCreateManyUserInputEnvelope
    set?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    disconnect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    delete?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    update?: ResponseValidationUpdateWithWhereUniqueWithoutUserInput | ResponseValidationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResponseValidationUpdateManyWithWhereWithoutUserInput | ResponseValidationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResponseValidationScalarWhereInput | ResponseValidationScalarWhereInput[]
  }

  export type QuizParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizParticipationCreateWithoutUserInput, QuizParticipationUncheckedCreateWithoutUserInput> | QuizParticipationCreateWithoutUserInput[] | QuizParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutUserInput | QuizParticipationCreateOrConnectWithoutUserInput[]
    upsert?: QuizParticipationUpsertWithWhereUniqueWithoutUserInput | QuizParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizParticipationCreateManyUserInputEnvelope
    set?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    disconnect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    delete?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    update?: QuizParticipationUpdateWithWhereUniqueWithoutUserInput | QuizParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizParticipationUpdateManyWithWhereWithoutUserInput | QuizParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizParticipationScalarWhereInput | QuizParticipationScalarWhereInput[]
  }

  export type AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AgreementParticipationCreateWithoutUserInput, AgreementParticipationUncheckedCreateWithoutUserInput> | AgreementParticipationCreateWithoutUserInput[] | AgreementParticipationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutUserInput | AgreementParticipationCreateOrConnectWithoutUserInput[]
    upsert?: AgreementParticipationUpsertWithWhereUniqueWithoutUserInput | AgreementParticipationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AgreementParticipationCreateManyUserInputEnvelope
    set?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    disconnect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    delete?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    update?: AgreementParticipationUpdateWithWhereUniqueWithoutUserInput | AgreementParticipationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AgreementParticipationUpdateManyWithWhereWithoutUserInput | AgreementParticipationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AgreementParticipationScalarWhereInput | AgreementParticipationScalarWhereInput[]
  }

  export type MeetingEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MeetingEntryCreateWithoutUserInput, MeetingEntryUncheckedCreateWithoutUserInput> | MeetingEntryCreateWithoutUserInput[] | MeetingEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutUserInput | MeetingEntryCreateOrConnectWithoutUserInput[]
    upsert?: MeetingEntryUpsertWithWhereUniqueWithoutUserInput | MeetingEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MeetingEntryCreateManyUserInputEnvelope
    set?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    disconnect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    delete?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    update?: MeetingEntryUpdateWithWhereUniqueWithoutUserInput | MeetingEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MeetingEntryUpdateManyWithWhereWithoutUserInput | MeetingEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MeetingEntryScalarWhereInput | MeetingEntryScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput> | SubscriptionCreateWithoutUserInput[] | SubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutUserInput | SubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutUserInput | SubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubscriptionCreateManyUserInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutUserInput | SubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutUserInput | SubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type RelationshipMemberCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<RelationshipMemberCreateWithoutRelationshipInput, RelationshipMemberUncheckedCreateWithoutRelationshipInput> | RelationshipMemberCreateWithoutRelationshipInput[] | RelationshipMemberUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutRelationshipInput | RelationshipMemberCreateOrConnectWithoutRelationshipInput[]
    createMany?: RelationshipMemberCreateManyRelationshipInputEnvelope
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<InviteCreateWithoutRelationshipInput, InviteUncheckedCreateWithoutRelationshipInput> | InviteCreateWithoutRelationshipInput[] | InviteUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutRelationshipInput | InviteCreateOrConnectWithoutRelationshipInput[]
    createMany?: InviteCreateManyRelationshipInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type DailySessionCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<DailySessionCreateWithoutRelationshipInput, DailySessionUncheckedCreateWithoutRelationshipInput> | DailySessionCreateWithoutRelationshipInput[] | DailySessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutRelationshipInput | DailySessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: DailySessionCreateManyRelationshipInputEnvelope
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
  }

  export type QuizSessionCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<QuizSessionCreateWithoutRelationshipInput, QuizSessionUncheckedCreateWithoutRelationshipInput> | QuizSessionCreateWithoutRelationshipInput[] | QuizSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutRelationshipInput | QuizSessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: QuizSessionCreateManyRelationshipInputEnvelope
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
  }

  export type AgreementSessionCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<AgreementSessionCreateWithoutRelationshipInput, AgreementSessionUncheckedCreateWithoutRelationshipInput> | AgreementSessionCreateWithoutRelationshipInput[] | AgreementSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: AgreementSessionCreateOrConnectWithoutRelationshipInput | AgreementSessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: AgreementSessionCreateManyRelationshipInputEnvelope
    connect?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<MeetingCreateWithoutRelationshipInput, MeetingUncheckedCreateWithoutRelationshipInput> | MeetingCreateWithoutRelationshipInput[] | MeetingUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutRelationshipInput | MeetingCreateOrConnectWithoutRelationshipInput[]
    createMany?: MeetingCreateManyRelationshipInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type StreakCreateNestedOneWithoutRelationshipInput = {
    create?: XOR<StreakCreateWithoutRelationshipInput, StreakUncheckedCreateWithoutRelationshipInput>
    connectOrCreate?: StreakCreateOrConnectWithoutRelationshipInput
    connect?: StreakWhereUniqueInput
  }

  export type SubscriptionCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<SubscriptionCreateWithoutRelationshipInput, SubscriptionUncheckedCreateWithoutRelationshipInput> | SubscriptionCreateWithoutRelationshipInput[] | SubscriptionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRelationshipInput | SubscriptionCreateOrConnectWithoutRelationshipInput[]
    createMany?: SubscriptionCreateManyRelationshipInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<RelationshipMemberCreateWithoutRelationshipInput, RelationshipMemberUncheckedCreateWithoutRelationshipInput> | RelationshipMemberCreateWithoutRelationshipInput[] | RelationshipMemberUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutRelationshipInput | RelationshipMemberCreateOrConnectWithoutRelationshipInput[]
    createMany?: RelationshipMemberCreateManyRelationshipInputEnvelope
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<InviteCreateWithoutRelationshipInput, InviteUncheckedCreateWithoutRelationshipInput> | InviteCreateWithoutRelationshipInput[] | InviteUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutRelationshipInput | InviteCreateOrConnectWithoutRelationshipInput[]
    createMany?: InviteCreateManyRelationshipInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type DailySessionUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<DailySessionCreateWithoutRelationshipInput, DailySessionUncheckedCreateWithoutRelationshipInput> | DailySessionCreateWithoutRelationshipInput[] | DailySessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutRelationshipInput | DailySessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: DailySessionCreateManyRelationshipInputEnvelope
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
  }

  export type QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<QuizSessionCreateWithoutRelationshipInput, QuizSessionUncheckedCreateWithoutRelationshipInput> | QuizSessionCreateWithoutRelationshipInput[] | QuizSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutRelationshipInput | QuizSessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: QuizSessionCreateManyRelationshipInputEnvelope
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
  }

  export type AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<AgreementSessionCreateWithoutRelationshipInput, AgreementSessionUncheckedCreateWithoutRelationshipInput> | AgreementSessionCreateWithoutRelationshipInput[] | AgreementSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: AgreementSessionCreateOrConnectWithoutRelationshipInput | AgreementSessionCreateOrConnectWithoutRelationshipInput[]
    createMany?: AgreementSessionCreateManyRelationshipInputEnvelope
    connect?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<MeetingCreateWithoutRelationshipInput, MeetingUncheckedCreateWithoutRelationshipInput> | MeetingCreateWithoutRelationshipInput[] | MeetingUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutRelationshipInput | MeetingCreateOrConnectWithoutRelationshipInput[]
    createMany?: MeetingCreateManyRelationshipInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type StreakUncheckedCreateNestedOneWithoutRelationshipInput = {
    create?: XOR<StreakCreateWithoutRelationshipInput, StreakUncheckedCreateWithoutRelationshipInput>
    connectOrCreate?: StreakCreateOrConnectWithoutRelationshipInput
    connect?: StreakWhereUniqueInput
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput = {
    create?: XOR<SubscriptionCreateWithoutRelationshipInput, SubscriptionUncheckedCreateWithoutRelationshipInput> | SubscriptionCreateWithoutRelationshipInput[] | SubscriptionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRelationshipInput | SubscriptionCreateOrConnectWithoutRelationshipInput[]
    createMany?: SubscriptionCreateManyRelationshipInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type EnumRelationshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.RelationshipStatus
  }

  export type RelationshipMemberUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<RelationshipMemberCreateWithoutRelationshipInput, RelationshipMemberUncheckedCreateWithoutRelationshipInput> | RelationshipMemberCreateWithoutRelationshipInput[] | RelationshipMemberUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutRelationshipInput | RelationshipMemberCreateOrConnectWithoutRelationshipInput[]
    upsert?: RelationshipMemberUpsertWithWhereUniqueWithoutRelationshipInput | RelationshipMemberUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: RelationshipMemberCreateManyRelationshipInputEnvelope
    set?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    disconnect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    delete?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    update?: RelationshipMemberUpdateWithWhereUniqueWithoutRelationshipInput | RelationshipMemberUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: RelationshipMemberUpdateManyWithWhereWithoutRelationshipInput | RelationshipMemberUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: RelationshipMemberScalarWhereInput | RelationshipMemberScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<InviteCreateWithoutRelationshipInput, InviteUncheckedCreateWithoutRelationshipInput> | InviteCreateWithoutRelationshipInput[] | InviteUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutRelationshipInput | InviteCreateOrConnectWithoutRelationshipInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutRelationshipInput | InviteUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: InviteCreateManyRelationshipInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutRelationshipInput | InviteUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutRelationshipInput | InviteUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type DailySessionUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<DailySessionCreateWithoutRelationshipInput, DailySessionUncheckedCreateWithoutRelationshipInput> | DailySessionCreateWithoutRelationshipInput[] | DailySessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutRelationshipInput | DailySessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: DailySessionUpsertWithWhereUniqueWithoutRelationshipInput | DailySessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: DailySessionCreateManyRelationshipInputEnvelope
    set?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    disconnect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    delete?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    update?: DailySessionUpdateWithWhereUniqueWithoutRelationshipInput | DailySessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: DailySessionUpdateManyWithWhereWithoutRelationshipInput | DailySessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: DailySessionScalarWhereInput | DailySessionScalarWhereInput[]
  }

  export type QuizSessionUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<QuizSessionCreateWithoutRelationshipInput, QuizSessionUncheckedCreateWithoutRelationshipInput> | QuizSessionCreateWithoutRelationshipInput[] | QuizSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutRelationshipInput | QuizSessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: QuizSessionUpsertWithWhereUniqueWithoutRelationshipInput | QuizSessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: QuizSessionCreateManyRelationshipInputEnvelope
    set?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    disconnect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    delete?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    update?: QuizSessionUpdateWithWhereUniqueWithoutRelationshipInput | QuizSessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: QuizSessionUpdateManyWithWhereWithoutRelationshipInput | QuizSessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
  }

  export type AgreementSessionUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<AgreementSessionCreateWithoutRelationshipInput, AgreementSessionUncheckedCreateWithoutRelationshipInput> | AgreementSessionCreateWithoutRelationshipInput[] | AgreementSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: AgreementSessionCreateOrConnectWithoutRelationshipInput | AgreementSessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: AgreementSessionUpsertWithWhereUniqueWithoutRelationshipInput | AgreementSessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: AgreementSessionCreateManyRelationshipInputEnvelope
    set?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    disconnect?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    delete?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    connect?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    update?: AgreementSessionUpdateWithWhereUniqueWithoutRelationshipInput | AgreementSessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: AgreementSessionUpdateManyWithWhereWithoutRelationshipInput | AgreementSessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: AgreementSessionScalarWhereInput | AgreementSessionScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<MeetingCreateWithoutRelationshipInput, MeetingUncheckedCreateWithoutRelationshipInput> | MeetingCreateWithoutRelationshipInput[] | MeetingUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutRelationshipInput | MeetingCreateOrConnectWithoutRelationshipInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutRelationshipInput | MeetingUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: MeetingCreateManyRelationshipInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutRelationshipInput | MeetingUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutRelationshipInput | MeetingUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type StreakUpdateOneWithoutRelationshipNestedInput = {
    create?: XOR<StreakCreateWithoutRelationshipInput, StreakUncheckedCreateWithoutRelationshipInput>
    connectOrCreate?: StreakCreateOrConnectWithoutRelationshipInput
    upsert?: StreakUpsertWithoutRelationshipInput
    disconnect?: StreakWhereInput | boolean
    delete?: StreakWhereInput | boolean
    connect?: StreakWhereUniqueInput
    update?: XOR<XOR<StreakUpdateToOneWithWhereWithoutRelationshipInput, StreakUpdateWithoutRelationshipInput>, StreakUncheckedUpdateWithoutRelationshipInput>
  }

  export type SubscriptionUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<SubscriptionCreateWithoutRelationshipInput, SubscriptionUncheckedCreateWithoutRelationshipInput> | SubscriptionCreateWithoutRelationshipInput[] | SubscriptionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRelationshipInput | SubscriptionCreateOrConnectWithoutRelationshipInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutRelationshipInput | SubscriptionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: SubscriptionCreateManyRelationshipInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutRelationshipInput | SubscriptionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutRelationshipInput | SubscriptionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<RelationshipMemberCreateWithoutRelationshipInput, RelationshipMemberUncheckedCreateWithoutRelationshipInput> | RelationshipMemberCreateWithoutRelationshipInput[] | RelationshipMemberUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: RelationshipMemberCreateOrConnectWithoutRelationshipInput | RelationshipMemberCreateOrConnectWithoutRelationshipInput[]
    upsert?: RelationshipMemberUpsertWithWhereUniqueWithoutRelationshipInput | RelationshipMemberUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: RelationshipMemberCreateManyRelationshipInputEnvelope
    set?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    disconnect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    delete?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    connect?: RelationshipMemberWhereUniqueInput | RelationshipMemberWhereUniqueInput[]
    update?: RelationshipMemberUpdateWithWhereUniqueWithoutRelationshipInput | RelationshipMemberUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: RelationshipMemberUpdateManyWithWhereWithoutRelationshipInput | RelationshipMemberUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: RelationshipMemberScalarWhereInput | RelationshipMemberScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<InviteCreateWithoutRelationshipInput, InviteUncheckedCreateWithoutRelationshipInput> | InviteCreateWithoutRelationshipInput[] | InviteUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutRelationshipInput | InviteCreateOrConnectWithoutRelationshipInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutRelationshipInput | InviteUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: InviteCreateManyRelationshipInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutRelationshipInput | InviteUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutRelationshipInput | InviteUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<DailySessionCreateWithoutRelationshipInput, DailySessionUncheckedCreateWithoutRelationshipInput> | DailySessionCreateWithoutRelationshipInput[] | DailySessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutRelationshipInput | DailySessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: DailySessionUpsertWithWhereUniqueWithoutRelationshipInput | DailySessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: DailySessionCreateManyRelationshipInputEnvelope
    set?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    disconnect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    delete?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    update?: DailySessionUpdateWithWhereUniqueWithoutRelationshipInput | DailySessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: DailySessionUpdateManyWithWhereWithoutRelationshipInput | DailySessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: DailySessionScalarWhereInput | DailySessionScalarWhereInput[]
  }

  export type QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<QuizSessionCreateWithoutRelationshipInput, QuizSessionUncheckedCreateWithoutRelationshipInput> | QuizSessionCreateWithoutRelationshipInput[] | QuizSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: QuizSessionCreateOrConnectWithoutRelationshipInput | QuizSessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: QuizSessionUpsertWithWhereUniqueWithoutRelationshipInput | QuizSessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: QuizSessionCreateManyRelationshipInputEnvelope
    set?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    disconnect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    delete?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    connect?: QuizSessionWhereUniqueInput | QuizSessionWhereUniqueInput[]
    update?: QuizSessionUpdateWithWhereUniqueWithoutRelationshipInput | QuizSessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: QuizSessionUpdateManyWithWhereWithoutRelationshipInput | QuizSessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
  }

  export type AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<AgreementSessionCreateWithoutRelationshipInput, AgreementSessionUncheckedCreateWithoutRelationshipInput> | AgreementSessionCreateWithoutRelationshipInput[] | AgreementSessionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: AgreementSessionCreateOrConnectWithoutRelationshipInput | AgreementSessionCreateOrConnectWithoutRelationshipInput[]
    upsert?: AgreementSessionUpsertWithWhereUniqueWithoutRelationshipInput | AgreementSessionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: AgreementSessionCreateManyRelationshipInputEnvelope
    set?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    disconnect?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    delete?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    connect?: AgreementSessionWhereUniqueInput | AgreementSessionWhereUniqueInput[]
    update?: AgreementSessionUpdateWithWhereUniqueWithoutRelationshipInput | AgreementSessionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: AgreementSessionUpdateManyWithWhereWithoutRelationshipInput | AgreementSessionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: AgreementSessionScalarWhereInput | AgreementSessionScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<MeetingCreateWithoutRelationshipInput, MeetingUncheckedCreateWithoutRelationshipInput> | MeetingCreateWithoutRelationshipInput[] | MeetingUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutRelationshipInput | MeetingCreateOrConnectWithoutRelationshipInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutRelationshipInput | MeetingUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: MeetingCreateManyRelationshipInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutRelationshipInput | MeetingUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutRelationshipInput | MeetingUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type StreakUncheckedUpdateOneWithoutRelationshipNestedInput = {
    create?: XOR<StreakCreateWithoutRelationshipInput, StreakUncheckedCreateWithoutRelationshipInput>
    connectOrCreate?: StreakCreateOrConnectWithoutRelationshipInput
    upsert?: StreakUpsertWithoutRelationshipInput
    disconnect?: StreakWhereInput | boolean
    delete?: StreakWhereInput | boolean
    connect?: StreakWhereUniqueInput
    update?: XOR<XOR<StreakUpdateToOneWithWhereWithoutRelationshipInput, StreakUpdateWithoutRelationshipInput>, StreakUncheckedUpdateWithoutRelationshipInput>
  }

  export type SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput = {
    create?: XOR<SubscriptionCreateWithoutRelationshipInput, SubscriptionUncheckedCreateWithoutRelationshipInput> | SubscriptionCreateWithoutRelationshipInput[] | SubscriptionUncheckedCreateWithoutRelationshipInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutRelationshipInput | SubscriptionCreateOrConnectWithoutRelationshipInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutRelationshipInput | SubscriptionUpsertWithWhereUniqueWithoutRelationshipInput[]
    createMany?: SubscriptionCreateManyRelationshipInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutRelationshipInput | SubscriptionUpdateWithWhereUniqueWithoutRelationshipInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutRelationshipInput | SubscriptionUpdateManyWithWhereWithoutRelationshipInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type RelationshipCreateNestedOneWithoutMembersInput = {
    create?: XOR<RelationshipCreateWithoutMembersInput, RelationshipUncheckedCreateWithoutMembersInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutMembersInput
    connect?: RelationshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRelationshipMembersInput = {
    create?: XOR<UserCreateWithoutRelationshipMembersInput, UserUncheckedCreateWithoutRelationshipMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationshipMembersInput
    connect?: UserWhereUniqueInput
  }

  export type RelationshipUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<RelationshipCreateWithoutMembersInput, RelationshipUncheckedCreateWithoutMembersInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutMembersInput
    upsert?: RelationshipUpsertWithoutMembersInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutMembersInput, RelationshipUpdateWithoutMembersInput>, RelationshipUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutRelationshipMembersNestedInput = {
    create?: XOR<UserCreateWithoutRelationshipMembersInput, UserUncheckedCreateWithoutRelationshipMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRelationshipMembersInput
    upsert?: UserUpsertWithoutRelationshipMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRelationshipMembersInput, UserUpdateWithoutRelationshipMembersInput>, UserUncheckedUpdateWithoutRelationshipMembersInput>
  }

  export type RelationshipCreateNestedOneWithoutInvitesInput = {
    create?: XOR<RelationshipCreateWithoutInvitesInput, RelationshipUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutInvitesInput
    connect?: RelationshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitesSentInput = {
    create?: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesSentInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type RelationshipUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<RelationshipCreateWithoutInvitesInput, RelationshipUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutInvitesInput
    upsert?: RelationshipUpsertWithoutInvitesInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutInvitesInput, RelationshipUpdateWithoutInvitesInput>, RelationshipUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutInvitesSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesSentInput
    upsert?: UserUpsertWithoutInvitesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitesSentInput, UserUpdateWithoutInvitesSentInput>, UserUncheckedUpdateWithoutInvitesSentInput>
  }

  export type DailySessionCreateNestedManyWithoutPromptInput = {
    create?: XOR<DailySessionCreateWithoutPromptInput, DailySessionUncheckedCreateWithoutPromptInput> | DailySessionCreateWithoutPromptInput[] | DailySessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutPromptInput | DailySessionCreateOrConnectWithoutPromptInput[]
    createMany?: DailySessionCreateManyPromptInputEnvelope
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
  }

  export type DailySessionUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<DailySessionCreateWithoutPromptInput, DailySessionUncheckedCreateWithoutPromptInput> | DailySessionCreateWithoutPromptInput[] | DailySessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutPromptInput | DailySessionCreateOrConnectWithoutPromptInput[]
    createMany?: DailySessionCreateManyPromptInputEnvelope
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
  }

  export type EnumPromptTypeFieldUpdateOperationsInput = {
    set?: $Enums.PromptType
  }

  export type EnumPromptCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PromptCategory
  }

  export type NullableEnumPromptToneFieldUpdateOperationsInput = {
    set?: $Enums.PromptTone | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DailySessionUpdateManyWithoutPromptNestedInput = {
    create?: XOR<DailySessionCreateWithoutPromptInput, DailySessionUncheckedCreateWithoutPromptInput> | DailySessionCreateWithoutPromptInput[] | DailySessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutPromptInput | DailySessionCreateOrConnectWithoutPromptInput[]
    upsert?: DailySessionUpsertWithWhereUniqueWithoutPromptInput | DailySessionUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: DailySessionCreateManyPromptInputEnvelope
    set?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    disconnect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    delete?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    update?: DailySessionUpdateWithWhereUniqueWithoutPromptInput | DailySessionUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: DailySessionUpdateManyWithWhereWithoutPromptInput | DailySessionUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: DailySessionScalarWhereInput | DailySessionScalarWhereInput[]
  }

  export type DailySessionUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<DailySessionCreateWithoutPromptInput, DailySessionUncheckedCreateWithoutPromptInput> | DailySessionCreateWithoutPromptInput[] | DailySessionUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: DailySessionCreateOrConnectWithoutPromptInput | DailySessionCreateOrConnectWithoutPromptInput[]
    upsert?: DailySessionUpsertWithWhereUniqueWithoutPromptInput | DailySessionUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: DailySessionCreateManyPromptInputEnvelope
    set?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    disconnect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    delete?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    connect?: DailySessionWhereUniqueInput | DailySessionWhereUniqueInput[]
    update?: DailySessionUpdateWithWhereUniqueWithoutPromptInput | DailySessionUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: DailySessionUpdateManyWithWhereWithoutPromptInput | DailySessionUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: DailySessionScalarWhereInput | DailySessionScalarWhereInput[]
  }

  export type RelationshipCreateNestedOneWithoutDailySessionsInput = {
    create?: XOR<RelationshipCreateWithoutDailySessionsInput, RelationshipUncheckedCreateWithoutDailySessionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutDailySessionsInput
    connect?: RelationshipWhereUniqueInput
  }

  export type PromptCreateNestedOneWithoutDailySessionsInput = {
    create?: XOR<PromptCreateWithoutDailySessionsInput, PromptUncheckedCreateWithoutDailySessionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutDailySessionsInput
    connect?: PromptWhereUniqueInput
  }

  export type ResponseCreateNestedManyWithoutSessionInput = {
    create?: XOR<ResponseCreateWithoutSessionInput, ResponseUncheckedCreateWithoutSessionInput> | ResponseCreateWithoutSessionInput[] | ResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutSessionInput | ResponseCreateOrConnectWithoutSessionInput[]
    createMany?: ResponseCreateManySessionInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ReflectionCreateNestedManyWithoutSessionInput = {
    create?: XOR<ReflectionCreateWithoutSessionInput, ReflectionUncheckedCreateWithoutSessionInput> | ReflectionCreateWithoutSessionInput[] | ReflectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutSessionInput | ReflectionCreateOrConnectWithoutSessionInput[]
    createMany?: ReflectionCreateManySessionInputEnvelope
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
  }

  export type ResponseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ResponseCreateWithoutSessionInput, ResponseUncheckedCreateWithoutSessionInput> | ResponseCreateWithoutSessionInput[] | ResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutSessionInput | ResponseCreateOrConnectWithoutSessionInput[]
    createMany?: ResponseCreateManySessionInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ReflectionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ReflectionCreateWithoutSessionInput, ReflectionUncheckedCreateWithoutSessionInput> | ReflectionCreateWithoutSessionInput[] | ReflectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutSessionInput | ReflectionCreateOrConnectWithoutSessionInput[]
    createMany?: ReflectionCreateManySessionInputEnvelope
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
  }

  export type EnumSessionStateFieldUpdateOperationsInput = {
    set?: $Enums.SessionState
  }

  export type RelationshipUpdateOneRequiredWithoutDailySessionsNestedInput = {
    create?: XOR<RelationshipCreateWithoutDailySessionsInput, RelationshipUncheckedCreateWithoutDailySessionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutDailySessionsInput
    upsert?: RelationshipUpsertWithoutDailySessionsInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutDailySessionsInput, RelationshipUpdateWithoutDailySessionsInput>, RelationshipUncheckedUpdateWithoutDailySessionsInput>
  }

  export type PromptUpdateOneWithoutDailySessionsNestedInput = {
    create?: XOR<PromptCreateWithoutDailySessionsInput, PromptUncheckedCreateWithoutDailySessionsInput>
    connectOrCreate?: PromptCreateOrConnectWithoutDailySessionsInput
    upsert?: PromptUpsertWithoutDailySessionsInput
    disconnect?: PromptWhereInput | boolean
    delete?: PromptWhereInput | boolean
    connect?: PromptWhereUniqueInput
    update?: XOR<XOR<PromptUpdateToOneWithWhereWithoutDailySessionsInput, PromptUpdateWithoutDailySessionsInput>, PromptUncheckedUpdateWithoutDailySessionsInput>
  }

  export type ResponseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ResponseCreateWithoutSessionInput, ResponseUncheckedCreateWithoutSessionInput> | ResponseCreateWithoutSessionInput[] | ResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutSessionInput | ResponseCreateOrConnectWithoutSessionInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutSessionInput | ResponseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ResponseCreateManySessionInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutSessionInput | ResponseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutSessionInput | ResponseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ReflectionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ReflectionCreateWithoutSessionInput, ReflectionUncheckedCreateWithoutSessionInput> | ReflectionCreateWithoutSessionInput[] | ReflectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutSessionInput | ReflectionCreateOrConnectWithoutSessionInput[]
    upsert?: ReflectionUpsertWithWhereUniqueWithoutSessionInput | ReflectionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ReflectionCreateManySessionInputEnvelope
    set?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    disconnect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    delete?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    update?: ReflectionUpdateWithWhereUniqueWithoutSessionInput | ReflectionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ReflectionUpdateManyWithWhereWithoutSessionInput | ReflectionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ReflectionScalarWhereInput | ReflectionScalarWhereInput[]
  }

  export type ResponseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ResponseCreateWithoutSessionInput, ResponseUncheckedCreateWithoutSessionInput> | ResponseCreateWithoutSessionInput[] | ResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutSessionInput | ResponseCreateOrConnectWithoutSessionInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutSessionInput | ResponseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ResponseCreateManySessionInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutSessionInput | ResponseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutSessionInput | ResponseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ReflectionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ReflectionCreateWithoutSessionInput, ReflectionUncheckedCreateWithoutSessionInput> | ReflectionCreateWithoutSessionInput[] | ReflectionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReflectionCreateOrConnectWithoutSessionInput | ReflectionCreateOrConnectWithoutSessionInput[]
    upsert?: ReflectionUpsertWithWhereUniqueWithoutSessionInput | ReflectionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ReflectionCreateManySessionInputEnvelope
    set?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    disconnect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    delete?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    connect?: ReflectionWhereUniqueInput | ReflectionWhereUniqueInput[]
    update?: ReflectionUpdateWithWhereUniqueWithoutSessionInput | ReflectionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ReflectionUpdateManyWithWhereWithoutSessionInput | ReflectionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ReflectionScalarWhereInput | ReflectionScalarWhereInput[]
  }

  export type DailySessionCreateNestedOneWithoutResponsesInput = {
    create?: XOR<DailySessionCreateWithoutResponsesInput, DailySessionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: DailySessionCreateOrConnectWithoutResponsesInput
    connect?: DailySessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResponsesInput = {
    create?: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type ResponseValidationCreateNestedManyWithoutResponseInput = {
    create?: XOR<ResponseValidationCreateWithoutResponseInput, ResponseValidationUncheckedCreateWithoutResponseInput> | ResponseValidationCreateWithoutResponseInput[] | ResponseValidationUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutResponseInput | ResponseValidationCreateOrConnectWithoutResponseInput[]
    createMany?: ResponseValidationCreateManyResponseInputEnvelope
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
  }

  export type ResponseValidationUncheckedCreateNestedManyWithoutResponseInput = {
    create?: XOR<ResponseValidationCreateWithoutResponseInput, ResponseValidationUncheckedCreateWithoutResponseInput> | ResponseValidationCreateWithoutResponseInput[] | ResponseValidationUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutResponseInput | ResponseValidationCreateOrConnectWithoutResponseInput[]
    createMany?: ResponseValidationCreateManyResponseInputEnvelope
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
  }

  export type DailySessionUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<DailySessionCreateWithoutResponsesInput, DailySessionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: DailySessionCreateOrConnectWithoutResponsesInput
    upsert?: DailySessionUpsertWithoutResponsesInput
    connect?: DailySessionWhereUniqueInput
    update?: XOR<XOR<DailySessionUpdateToOneWithWhereWithoutResponsesInput, DailySessionUpdateWithoutResponsesInput>, DailySessionUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsesInput
    upsert?: UserUpsertWithoutResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResponsesInput, UserUpdateWithoutResponsesInput>, UserUncheckedUpdateWithoutResponsesInput>
  }

  export type ResponseValidationUpdateManyWithoutResponseNestedInput = {
    create?: XOR<ResponseValidationCreateWithoutResponseInput, ResponseValidationUncheckedCreateWithoutResponseInput> | ResponseValidationCreateWithoutResponseInput[] | ResponseValidationUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutResponseInput | ResponseValidationCreateOrConnectWithoutResponseInput[]
    upsert?: ResponseValidationUpsertWithWhereUniqueWithoutResponseInput | ResponseValidationUpsertWithWhereUniqueWithoutResponseInput[]
    createMany?: ResponseValidationCreateManyResponseInputEnvelope
    set?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    disconnect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    delete?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    update?: ResponseValidationUpdateWithWhereUniqueWithoutResponseInput | ResponseValidationUpdateWithWhereUniqueWithoutResponseInput[]
    updateMany?: ResponseValidationUpdateManyWithWhereWithoutResponseInput | ResponseValidationUpdateManyWithWhereWithoutResponseInput[]
    deleteMany?: ResponseValidationScalarWhereInput | ResponseValidationScalarWhereInput[]
  }

  export type ResponseValidationUncheckedUpdateManyWithoutResponseNestedInput = {
    create?: XOR<ResponseValidationCreateWithoutResponseInput, ResponseValidationUncheckedCreateWithoutResponseInput> | ResponseValidationCreateWithoutResponseInput[] | ResponseValidationUncheckedCreateWithoutResponseInput[]
    connectOrCreate?: ResponseValidationCreateOrConnectWithoutResponseInput | ResponseValidationCreateOrConnectWithoutResponseInput[]
    upsert?: ResponseValidationUpsertWithWhereUniqueWithoutResponseInput | ResponseValidationUpsertWithWhereUniqueWithoutResponseInput[]
    createMany?: ResponseValidationCreateManyResponseInputEnvelope
    set?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    disconnect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    delete?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    connect?: ResponseValidationWhereUniqueInput | ResponseValidationWhereUniqueInput[]
    update?: ResponseValidationUpdateWithWhereUniqueWithoutResponseInput | ResponseValidationUpdateWithWhereUniqueWithoutResponseInput[]
    updateMany?: ResponseValidationUpdateManyWithWhereWithoutResponseInput | ResponseValidationUpdateManyWithWhereWithoutResponseInput[]
    deleteMany?: ResponseValidationScalarWhereInput | ResponseValidationScalarWhereInput[]
  }

  export type ResponseCreateNestedOneWithoutValidationsInput = {
    create?: XOR<ResponseCreateWithoutValidationsInput, ResponseUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: ResponseCreateOrConnectWithoutValidationsInput
    connect?: ResponseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResponseValidationsInput = {
    create?: XOR<UserCreateWithoutResponseValidationsInput, UserUncheckedCreateWithoutResponseValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponseValidationsInput
    connect?: UserWhereUniqueInput
  }

  export type ResponseUpdateOneRequiredWithoutValidationsNestedInput = {
    create?: XOR<ResponseCreateWithoutValidationsInput, ResponseUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: ResponseCreateOrConnectWithoutValidationsInput
    upsert?: ResponseUpsertWithoutValidationsInput
    connect?: ResponseWhereUniqueInput
    update?: XOR<XOR<ResponseUpdateToOneWithWhereWithoutValidationsInput, ResponseUpdateWithoutValidationsInput>, ResponseUncheckedUpdateWithoutValidationsInput>
  }

  export type UserUpdateOneRequiredWithoutResponseValidationsNestedInput = {
    create?: XOR<UserCreateWithoutResponseValidationsInput, UserUncheckedCreateWithoutResponseValidationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponseValidationsInput
    upsert?: UserUpsertWithoutResponseValidationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResponseValidationsInput, UserUpdateWithoutResponseValidationsInput>, UserUncheckedUpdateWithoutResponseValidationsInput>
  }

  export type DailySessionCreateNestedOneWithoutReflectionsInput = {
    create?: XOR<DailySessionCreateWithoutReflectionsInput, DailySessionUncheckedCreateWithoutReflectionsInput>
    connectOrCreate?: DailySessionCreateOrConnectWithoutReflectionsInput
    connect?: DailySessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReflectionsInput = {
    create?: XOR<UserCreateWithoutReflectionsInput, UserUncheckedCreateWithoutReflectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReflectionsInput
    connect?: UserWhereUniqueInput
  }

  export type DailySessionUpdateOneRequiredWithoutReflectionsNestedInput = {
    create?: XOR<DailySessionCreateWithoutReflectionsInput, DailySessionUncheckedCreateWithoutReflectionsInput>
    connectOrCreate?: DailySessionCreateOrConnectWithoutReflectionsInput
    upsert?: DailySessionUpsertWithoutReflectionsInput
    connect?: DailySessionWhereUniqueInput
    update?: XOR<XOR<DailySessionUpdateToOneWithWhereWithoutReflectionsInput, DailySessionUpdateWithoutReflectionsInput>, DailySessionUncheckedUpdateWithoutReflectionsInput>
  }

  export type UserUpdateOneRequiredWithoutReflectionsNestedInput = {
    create?: XOR<UserCreateWithoutReflectionsInput, UserUncheckedCreateWithoutReflectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReflectionsInput
    upsert?: UserUpsertWithoutReflectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReflectionsInput, UserUpdateWithoutReflectionsInput>, UserUncheckedUpdateWithoutReflectionsInput>
  }

  export type RelationshipCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<RelationshipCreateWithoutMeetingsInput, RelationshipUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutMeetingsInput
    connect?: RelationshipWhereUniqueInput
  }

  export type MeetingEntryCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MeetingEntryCreateWithoutMeetingInput, MeetingEntryUncheckedCreateWithoutMeetingInput> | MeetingEntryCreateWithoutMeetingInput[] | MeetingEntryUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutMeetingInput | MeetingEntryCreateOrConnectWithoutMeetingInput[]
    createMany?: MeetingEntryCreateManyMeetingInputEnvelope
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
  }

  export type MeetingEntryUncheckedCreateNestedManyWithoutMeetingInput = {
    create?: XOR<MeetingEntryCreateWithoutMeetingInput, MeetingEntryUncheckedCreateWithoutMeetingInput> | MeetingEntryCreateWithoutMeetingInput[] | MeetingEntryUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutMeetingInput | MeetingEntryCreateOrConnectWithoutMeetingInput[]
    createMany?: MeetingEntryCreateManyMeetingInputEnvelope
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
  }

  export type RelationshipUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<RelationshipCreateWithoutMeetingsInput, RelationshipUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutMeetingsInput
    upsert?: RelationshipUpsertWithoutMeetingsInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutMeetingsInput, RelationshipUpdateWithoutMeetingsInput>, RelationshipUncheckedUpdateWithoutMeetingsInput>
  }

  export type MeetingEntryUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MeetingEntryCreateWithoutMeetingInput, MeetingEntryUncheckedCreateWithoutMeetingInput> | MeetingEntryCreateWithoutMeetingInput[] | MeetingEntryUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutMeetingInput | MeetingEntryCreateOrConnectWithoutMeetingInput[]
    upsert?: MeetingEntryUpsertWithWhereUniqueWithoutMeetingInput | MeetingEntryUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MeetingEntryCreateManyMeetingInputEnvelope
    set?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    disconnect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    delete?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    update?: MeetingEntryUpdateWithWhereUniqueWithoutMeetingInput | MeetingEntryUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MeetingEntryUpdateManyWithWhereWithoutMeetingInput | MeetingEntryUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MeetingEntryScalarWhereInput | MeetingEntryScalarWhereInput[]
  }

  export type MeetingEntryUncheckedUpdateManyWithoutMeetingNestedInput = {
    create?: XOR<MeetingEntryCreateWithoutMeetingInput, MeetingEntryUncheckedCreateWithoutMeetingInput> | MeetingEntryCreateWithoutMeetingInput[] | MeetingEntryUncheckedCreateWithoutMeetingInput[]
    connectOrCreate?: MeetingEntryCreateOrConnectWithoutMeetingInput | MeetingEntryCreateOrConnectWithoutMeetingInput[]
    upsert?: MeetingEntryUpsertWithWhereUniqueWithoutMeetingInput | MeetingEntryUpsertWithWhereUniqueWithoutMeetingInput[]
    createMany?: MeetingEntryCreateManyMeetingInputEnvelope
    set?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    disconnect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    delete?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    connect?: MeetingEntryWhereUniqueInput | MeetingEntryWhereUniqueInput[]
    update?: MeetingEntryUpdateWithWhereUniqueWithoutMeetingInput | MeetingEntryUpdateWithWhereUniqueWithoutMeetingInput[]
    updateMany?: MeetingEntryUpdateManyWithWhereWithoutMeetingInput | MeetingEntryUpdateManyWithWhereWithoutMeetingInput[]
    deleteMany?: MeetingEntryScalarWhereInput | MeetingEntryScalarWhereInput[]
  }

  export type MeetingCreateNestedOneWithoutEntriesInput = {
    create?: XOR<MeetingCreateWithoutEntriesInput, MeetingUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutEntriesInput
    connect?: MeetingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeetingEntriesInput = {
    create?: XOR<UserCreateWithoutMeetingEntriesInput, UserUncheckedCreateWithoutMeetingEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type MeetingUpdateOneRequiredWithoutEntriesNestedInput = {
    create?: XOR<MeetingCreateWithoutEntriesInput, MeetingUncheckedCreateWithoutEntriesInput>
    connectOrCreate?: MeetingCreateOrConnectWithoutEntriesInput
    upsert?: MeetingUpsertWithoutEntriesInput
    connect?: MeetingWhereUniqueInput
    update?: XOR<XOR<MeetingUpdateToOneWithWhereWithoutEntriesInput, MeetingUpdateWithoutEntriesInput>, MeetingUncheckedUpdateWithoutEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutMeetingEntriesNestedInput = {
    create?: XOR<UserCreateWithoutMeetingEntriesInput, UserUncheckedCreateWithoutMeetingEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingEntriesInput
    upsert?: UserUpsertWithoutMeetingEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeetingEntriesInput, UserUpdateWithoutMeetingEntriesInput>, UserUncheckedUpdateWithoutMeetingEntriesInput>
  }

  export type RelationshipCreateNestedOneWithoutStreakInput = {
    create?: XOR<RelationshipCreateWithoutStreakInput, RelationshipUncheckedCreateWithoutStreakInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutStreakInput
    connect?: RelationshipWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RelationshipUpdateOneRequiredWithoutStreakNestedInput = {
    create?: XOR<RelationshipCreateWithoutStreakInput, RelationshipUncheckedCreateWithoutStreakInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutStreakInput
    upsert?: RelationshipUpsertWithoutStreakInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutStreakInput, RelationshipUpdateWithoutStreakInput>, RelationshipUncheckedUpdateWithoutStreakInput>
  }

  export type UserCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type RelationshipCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<RelationshipCreateWithoutSubscriptionsInput, RelationshipUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutSubscriptionsInput
    connect?: RelationshipWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type UserUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubscriptionsInput
    upsert?: UserUpsertWithoutSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubscriptionsInput, UserUpdateWithoutSubscriptionsInput>, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type RelationshipUpdateOneWithoutSubscriptionsNestedInput = {
    create?: XOR<RelationshipCreateWithoutSubscriptionsInput, RelationshipUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutSubscriptionsInput
    upsert?: RelationshipUpsertWithoutSubscriptionsInput
    disconnect?: RelationshipWhereInput | boolean
    delete?: RelationshipWhereInput | boolean
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutSubscriptionsInput, RelationshipUpdateWithoutSubscriptionsInput>, RelationshipUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type RelationshipCreateNestedOneWithoutQuizSessionsInput = {
    create?: XOR<RelationshipCreateWithoutQuizSessionsInput, RelationshipUncheckedCreateWithoutQuizSessionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutQuizSessionsInput
    connect?: RelationshipWhereUniqueInput
  }

  export type QuizParticipationCreateNestedManyWithoutQuizSessionInput = {
    create?: XOR<QuizParticipationCreateWithoutQuizSessionInput, QuizParticipationUncheckedCreateWithoutQuizSessionInput> | QuizParticipationCreateWithoutQuizSessionInput[] | QuizParticipationUncheckedCreateWithoutQuizSessionInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutQuizSessionInput | QuizParticipationCreateOrConnectWithoutQuizSessionInput[]
    createMany?: QuizParticipationCreateManyQuizSessionInputEnvelope
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
  }

  export type QuizParticipationUncheckedCreateNestedManyWithoutQuizSessionInput = {
    create?: XOR<QuizParticipationCreateWithoutQuizSessionInput, QuizParticipationUncheckedCreateWithoutQuizSessionInput> | QuizParticipationCreateWithoutQuizSessionInput[] | QuizParticipationUncheckedCreateWithoutQuizSessionInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutQuizSessionInput | QuizParticipationCreateOrConnectWithoutQuizSessionInput[]
    createMany?: QuizParticipationCreateManyQuizSessionInputEnvelope
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
  }

  export type EnumQuizStateFieldUpdateOperationsInput = {
    set?: $Enums.QuizState
  }

  export type RelationshipUpdateOneRequiredWithoutQuizSessionsNestedInput = {
    create?: XOR<RelationshipCreateWithoutQuizSessionsInput, RelationshipUncheckedCreateWithoutQuizSessionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutQuizSessionsInput
    upsert?: RelationshipUpsertWithoutQuizSessionsInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutQuizSessionsInput, RelationshipUpdateWithoutQuizSessionsInput>, RelationshipUncheckedUpdateWithoutQuizSessionsInput>
  }

  export type QuizParticipationUpdateManyWithoutQuizSessionNestedInput = {
    create?: XOR<QuizParticipationCreateWithoutQuizSessionInput, QuizParticipationUncheckedCreateWithoutQuizSessionInput> | QuizParticipationCreateWithoutQuizSessionInput[] | QuizParticipationUncheckedCreateWithoutQuizSessionInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutQuizSessionInput | QuizParticipationCreateOrConnectWithoutQuizSessionInput[]
    upsert?: QuizParticipationUpsertWithWhereUniqueWithoutQuizSessionInput | QuizParticipationUpsertWithWhereUniqueWithoutQuizSessionInput[]
    createMany?: QuizParticipationCreateManyQuizSessionInputEnvelope
    set?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    disconnect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    delete?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    update?: QuizParticipationUpdateWithWhereUniqueWithoutQuizSessionInput | QuizParticipationUpdateWithWhereUniqueWithoutQuizSessionInput[]
    updateMany?: QuizParticipationUpdateManyWithWhereWithoutQuizSessionInput | QuizParticipationUpdateManyWithWhereWithoutQuizSessionInput[]
    deleteMany?: QuizParticipationScalarWhereInput | QuizParticipationScalarWhereInput[]
  }

  export type QuizParticipationUncheckedUpdateManyWithoutQuizSessionNestedInput = {
    create?: XOR<QuizParticipationCreateWithoutQuizSessionInput, QuizParticipationUncheckedCreateWithoutQuizSessionInput> | QuizParticipationCreateWithoutQuizSessionInput[] | QuizParticipationUncheckedCreateWithoutQuizSessionInput[]
    connectOrCreate?: QuizParticipationCreateOrConnectWithoutQuizSessionInput | QuizParticipationCreateOrConnectWithoutQuizSessionInput[]
    upsert?: QuizParticipationUpsertWithWhereUniqueWithoutQuizSessionInput | QuizParticipationUpsertWithWhereUniqueWithoutQuizSessionInput[]
    createMany?: QuizParticipationCreateManyQuizSessionInputEnvelope
    set?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    disconnect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    delete?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    connect?: QuizParticipationWhereUniqueInput | QuizParticipationWhereUniqueInput[]
    update?: QuizParticipationUpdateWithWhereUniqueWithoutQuizSessionInput | QuizParticipationUpdateWithWhereUniqueWithoutQuizSessionInput[]
    updateMany?: QuizParticipationUpdateManyWithWhereWithoutQuizSessionInput | QuizParticipationUpdateManyWithWhereWithoutQuizSessionInput[]
    deleteMany?: QuizParticipationScalarWhereInput | QuizParticipationScalarWhereInput[]
  }

  export type QuizSessionCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<QuizSessionCreateWithoutParticipationsInput, QuizSessionUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutParticipationsInput
    connect?: QuizSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuizParticipationsInput = {
    create?: XOR<UserCreateWithoutQuizParticipationsInput, UserUncheckedCreateWithoutQuizParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizSessionUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<QuizSessionCreateWithoutParticipationsInput, QuizSessionUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: QuizSessionCreateOrConnectWithoutParticipationsInput
    upsert?: QuizSessionUpsertWithoutParticipationsInput
    connect?: QuizSessionWhereUniqueInput
    update?: XOR<XOR<QuizSessionUpdateToOneWithWhereWithoutParticipationsInput, QuizSessionUpdateWithoutParticipationsInput>, QuizSessionUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserUpdateOneRequiredWithoutQuizParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutQuizParticipationsInput, UserUncheckedCreateWithoutQuizParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizParticipationsInput
    upsert?: UserUpsertWithoutQuizParticipationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizParticipationsInput, UserUpdateWithoutQuizParticipationsInput>, UserUncheckedUpdateWithoutQuizParticipationsInput>
  }

  export type RelationshipCreateNestedOneWithoutAgreementSessionsInput = {
    create?: XOR<RelationshipCreateWithoutAgreementSessionsInput, RelationshipUncheckedCreateWithoutAgreementSessionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutAgreementSessionsInput
    connect?: RelationshipWhereUniqueInput
  }

  export type AgreementParticipationCreateNestedManyWithoutAgreementSessionInput = {
    create?: XOR<AgreementParticipationCreateWithoutAgreementSessionInput, AgreementParticipationUncheckedCreateWithoutAgreementSessionInput> | AgreementParticipationCreateWithoutAgreementSessionInput[] | AgreementParticipationUncheckedCreateWithoutAgreementSessionInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutAgreementSessionInput | AgreementParticipationCreateOrConnectWithoutAgreementSessionInput[]
    createMany?: AgreementParticipationCreateManyAgreementSessionInputEnvelope
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
  }

  export type AgreementParticipationUncheckedCreateNestedManyWithoutAgreementSessionInput = {
    create?: XOR<AgreementParticipationCreateWithoutAgreementSessionInput, AgreementParticipationUncheckedCreateWithoutAgreementSessionInput> | AgreementParticipationCreateWithoutAgreementSessionInput[] | AgreementParticipationUncheckedCreateWithoutAgreementSessionInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutAgreementSessionInput | AgreementParticipationCreateOrConnectWithoutAgreementSessionInput[]
    createMany?: AgreementParticipationCreateManyAgreementSessionInputEnvelope
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
  }

  export type EnumAgreementStateFieldUpdateOperationsInput = {
    set?: $Enums.AgreementState
  }

  export type RelationshipUpdateOneRequiredWithoutAgreementSessionsNestedInput = {
    create?: XOR<RelationshipCreateWithoutAgreementSessionsInput, RelationshipUncheckedCreateWithoutAgreementSessionsInput>
    connectOrCreate?: RelationshipCreateOrConnectWithoutAgreementSessionsInput
    upsert?: RelationshipUpsertWithoutAgreementSessionsInput
    connect?: RelationshipWhereUniqueInput
    update?: XOR<XOR<RelationshipUpdateToOneWithWhereWithoutAgreementSessionsInput, RelationshipUpdateWithoutAgreementSessionsInput>, RelationshipUncheckedUpdateWithoutAgreementSessionsInput>
  }

  export type AgreementParticipationUpdateManyWithoutAgreementSessionNestedInput = {
    create?: XOR<AgreementParticipationCreateWithoutAgreementSessionInput, AgreementParticipationUncheckedCreateWithoutAgreementSessionInput> | AgreementParticipationCreateWithoutAgreementSessionInput[] | AgreementParticipationUncheckedCreateWithoutAgreementSessionInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutAgreementSessionInput | AgreementParticipationCreateOrConnectWithoutAgreementSessionInput[]
    upsert?: AgreementParticipationUpsertWithWhereUniqueWithoutAgreementSessionInput | AgreementParticipationUpsertWithWhereUniqueWithoutAgreementSessionInput[]
    createMany?: AgreementParticipationCreateManyAgreementSessionInputEnvelope
    set?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    disconnect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    delete?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    update?: AgreementParticipationUpdateWithWhereUniqueWithoutAgreementSessionInput | AgreementParticipationUpdateWithWhereUniqueWithoutAgreementSessionInput[]
    updateMany?: AgreementParticipationUpdateManyWithWhereWithoutAgreementSessionInput | AgreementParticipationUpdateManyWithWhereWithoutAgreementSessionInput[]
    deleteMany?: AgreementParticipationScalarWhereInput | AgreementParticipationScalarWhereInput[]
  }

  export type AgreementParticipationUncheckedUpdateManyWithoutAgreementSessionNestedInput = {
    create?: XOR<AgreementParticipationCreateWithoutAgreementSessionInput, AgreementParticipationUncheckedCreateWithoutAgreementSessionInput> | AgreementParticipationCreateWithoutAgreementSessionInput[] | AgreementParticipationUncheckedCreateWithoutAgreementSessionInput[]
    connectOrCreate?: AgreementParticipationCreateOrConnectWithoutAgreementSessionInput | AgreementParticipationCreateOrConnectWithoutAgreementSessionInput[]
    upsert?: AgreementParticipationUpsertWithWhereUniqueWithoutAgreementSessionInput | AgreementParticipationUpsertWithWhereUniqueWithoutAgreementSessionInput[]
    createMany?: AgreementParticipationCreateManyAgreementSessionInputEnvelope
    set?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    disconnect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    delete?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    connect?: AgreementParticipationWhereUniqueInput | AgreementParticipationWhereUniqueInput[]
    update?: AgreementParticipationUpdateWithWhereUniqueWithoutAgreementSessionInput | AgreementParticipationUpdateWithWhereUniqueWithoutAgreementSessionInput[]
    updateMany?: AgreementParticipationUpdateManyWithWhereWithoutAgreementSessionInput | AgreementParticipationUpdateManyWithWhereWithoutAgreementSessionInput[]
    deleteMany?: AgreementParticipationScalarWhereInput | AgreementParticipationScalarWhereInput[]
  }

  export type AgreementSessionCreateNestedOneWithoutParticipationsInput = {
    create?: XOR<AgreementSessionCreateWithoutParticipationsInput, AgreementSessionUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: AgreementSessionCreateOrConnectWithoutParticipationsInput
    connect?: AgreementSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAgreementParticipationsInput = {
    create?: XOR<UserCreateWithoutAgreementParticipationsInput, UserUncheckedCreateWithoutAgreementParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementParticipationsInput
    connect?: UserWhereUniqueInput
  }

  export type AgreementSessionUpdateOneRequiredWithoutParticipationsNestedInput = {
    create?: XOR<AgreementSessionCreateWithoutParticipationsInput, AgreementSessionUncheckedCreateWithoutParticipationsInput>
    connectOrCreate?: AgreementSessionCreateOrConnectWithoutParticipationsInput
    upsert?: AgreementSessionUpsertWithoutParticipationsInput
    connect?: AgreementSessionWhereUniqueInput
    update?: XOR<XOR<AgreementSessionUpdateToOneWithWhereWithoutParticipationsInput, AgreementSessionUpdateWithoutParticipationsInput>, AgreementSessionUncheckedUpdateWithoutParticipationsInput>
  }

  export type UserUpdateOneRequiredWithoutAgreementParticipationsNestedInput = {
    create?: XOR<UserCreateWithoutAgreementParticipationsInput, UserUncheckedCreateWithoutAgreementParticipationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementParticipationsInput
    upsert?: UserUpsertWithoutAgreementParticipationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAgreementParticipationsInput, UserUpdateWithoutAgreementParticipationsInput>, UserUncheckedUpdateWithoutAgreementParticipationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRelationshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipStatus | EnumRelationshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipStatusFilter<$PrismaModel> | $Enums.RelationshipStatus
  }

  export type NestedEnumRelationshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipStatus | EnumRelationshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipStatus[] | ListEnumRelationshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipStatusFilter<$PrismaModel>
    _max?: NestedEnumRelationshipStatusFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedEnumPromptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeFilter<$PrismaModel> | $Enums.PromptType
  }

  export type NestedEnumPromptCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptCategory | EnumPromptCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptCategoryFilter<$PrismaModel> | $Enums.PromptCategory
  }

  export type NestedEnumPromptToneNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptTone | EnumPromptToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromptToneNullableFilter<$PrismaModel> | $Enums.PromptTone | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumPromptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptTypeFilter<$PrismaModel>
    _max?: NestedEnumPromptTypeFilter<$PrismaModel>
  }

  export type NestedEnumPromptCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptCategory | EnumPromptCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptCategory[] | ListEnumPromptCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PromptCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptCategoryFilter<$PrismaModel>
    _max?: NestedEnumPromptCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPromptToneNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptTone | EnumPromptToneFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromptTone[] | ListEnumPromptToneFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromptToneNullableWithAggregatesFilter<$PrismaModel> | $Enums.PromptTone | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPromptToneNullableFilter<$PrismaModel>
    _max?: NestedEnumPromptToneNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSessionStateFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionState | EnumSessionStateFieldRefInput<$PrismaModel>
    in?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStateFilter<$PrismaModel> | $Enums.SessionState
  }

  export type NestedEnumSessionStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionState | EnumSessionStateFieldRefInput<$PrismaModel>
    in?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionState[] | ListEnumSessionStateFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStateWithAggregatesFilter<$PrismaModel> | $Enums.SessionState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStateFilter<$PrismaModel>
    _max?: NestedEnumSessionStateFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuizStateFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizState | EnumQuizStateFieldRefInput<$PrismaModel>
    in?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStateFilter<$PrismaModel> | $Enums.QuizState
  }

  export type NestedEnumQuizStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuizState | EnumQuizStateFieldRefInput<$PrismaModel>
    in?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuizState[] | ListEnumQuizStateFieldRefInput<$PrismaModel>
    not?: NestedEnumQuizStateWithAggregatesFilter<$PrismaModel> | $Enums.QuizState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuizStateFilter<$PrismaModel>
    _max?: NestedEnumQuizStateFilter<$PrismaModel>
  }

  export type NestedEnumAgreementStateFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementState | EnumAgreementStateFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStateFilter<$PrismaModel> | $Enums.AgreementState
  }

  export type NestedEnumAgreementStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgreementState | EnumAgreementStateFieldRefInput<$PrismaModel>
    in?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.AgreementState[] | ListEnumAgreementStateFieldRefInput<$PrismaModel>
    not?: NestedEnumAgreementStateWithAggregatesFilter<$PrismaModel> | $Enums.AgreementState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAgreementStateFilter<$PrismaModel>
    _max?: NestedEnumAgreementStateFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipMemberCreateWithoutUserInput = {
    id?: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutMembersInput
  }

  export type RelationshipMemberUncheckedCreateWithoutUserInput = {
    id?: string
    relationshipId: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelationshipMemberCreateOrConnectWithoutUserInput = {
    where: RelationshipMemberWhereUniqueInput
    create: XOR<RelationshipMemberCreateWithoutUserInput, RelationshipMemberUncheckedCreateWithoutUserInput>
  }

  export type RelationshipMemberCreateManyUserInputEnvelope = {
    data: RelationshipMemberCreateManyUserInput | RelationshipMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InviteCreateWithoutSenderInput = {
    id?: string
    code: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutInvitesInput
  }

  export type InviteUncheckedCreateWithoutSenderInput = {
    id?: string
    code: string
    relationshipId: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateOrConnectWithoutSenderInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutSenderInput, InviteUncheckedCreateWithoutSenderInput>
  }

  export type InviteCreateManySenderInputEnvelope = {
    data: InviteCreateManySenderInput | InviteCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type ResponseCreateWithoutUserInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DailySessionCreateNestedOneWithoutResponsesInput
    validations?: ResponseValidationCreateNestedManyWithoutResponseInput
  }

  export type ResponseUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validations?: ResponseValidationUncheckedCreateNestedManyWithoutResponseInput
  }

  export type ResponseCreateOrConnectWithoutUserInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutUserInput, ResponseUncheckedCreateWithoutUserInput>
  }

  export type ResponseCreateManyUserInputEnvelope = {
    data: ResponseCreateManyUserInput | ResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReflectionCreateWithoutUserInput = {
    id?: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DailySessionCreateNestedOneWithoutReflectionsInput
  }

  export type ReflectionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReflectionCreateOrConnectWithoutUserInput = {
    where: ReflectionWhereUniqueInput
    create: XOR<ReflectionCreateWithoutUserInput, ReflectionUncheckedCreateWithoutUserInput>
  }

  export type ReflectionCreateManyUserInputEnvelope = {
    data: ReflectionCreateManyUserInput | ReflectionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResponseValidationCreateWithoutUserInput = {
    id?: string
    reactions?: string | null
    acknowledgment?: string | null
    response: ResponseCreateNestedOneWithoutValidationsInput
  }

  export type ResponseValidationUncheckedCreateWithoutUserInput = {
    id?: string
    responseId: string
    reactions?: string | null
    acknowledgment?: string | null
  }

  export type ResponseValidationCreateOrConnectWithoutUserInput = {
    where: ResponseValidationWhereUniqueInput
    create: XOR<ResponseValidationCreateWithoutUserInput, ResponseValidationUncheckedCreateWithoutUserInput>
  }

  export type ResponseValidationCreateManyUserInputEnvelope = {
    data: ResponseValidationCreateManyUserInput | ResponseValidationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizParticipationCreateWithoutUserInput = {
    id?: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
    quizSession: QuizSessionCreateNestedOneWithoutParticipationsInput
  }

  export type QuizParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    quizSessionId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizParticipationCreateOrConnectWithoutUserInput = {
    where: QuizParticipationWhereUniqueInput
    create: XOR<QuizParticipationCreateWithoutUserInput, QuizParticipationUncheckedCreateWithoutUserInput>
  }

  export type QuizParticipationCreateManyUserInputEnvelope = {
    data: QuizParticipationCreateManyUserInput | QuizParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AgreementParticipationCreateWithoutUserInput = {
    id?: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agreementSession: AgreementSessionCreateNestedOneWithoutParticipationsInput
  }

  export type AgreementParticipationUncheckedCreateWithoutUserInput = {
    id?: string
    agreementSessionId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementParticipationCreateOrConnectWithoutUserInput = {
    where: AgreementParticipationWhereUniqueInput
    create: XOR<AgreementParticipationCreateWithoutUserInput, AgreementParticipationUncheckedCreateWithoutUserInput>
  }

  export type AgreementParticipationCreateManyUserInputEnvelope = {
    data: AgreementParticipationCreateManyUserInput | AgreementParticipationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MeetingEntryCreateWithoutUserInput = {
    id?: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meeting: MeetingCreateNestedOneWithoutEntriesInput
  }

  export type MeetingEntryUncheckedCreateWithoutUserInput = {
    id?: string
    meetingId: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingEntryCreateOrConnectWithoutUserInput = {
    where: MeetingEntryWhereUniqueInput
    create: XOR<MeetingEntryCreateWithoutUserInput, MeetingEntryUncheckedCreateWithoutUserInput>
  }

  export type MeetingEntryCreateManyUserInputEnvelope = {
    data: MeetingEntryCreateManyUserInput | MeetingEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutUserInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship?: RelationshipCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    relationshipId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionCreateManyUserInputEnvelope = {
    data: SubscriptionCreateManyUserInput | SubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type RelationshipMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: RelationshipMemberWhereUniqueInput
    update: XOR<RelationshipMemberUpdateWithoutUserInput, RelationshipMemberUncheckedUpdateWithoutUserInput>
    create: XOR<RelationshipMemberCreateWithoutUserInput, RelationshipMemberUncheckedCreateWithoutUserInput>
  }

  export type RelationshipMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: RelationshipMemberWhereUniqueInput
    data: XOR<RelationshipMemberUpdateWithoutUserInput, RelationshipMemberUncheckedUpdateWithoutUserInput>
  }

  export type RelationshipMemberUpdateManyWithWhereWithoutUserInput = {
    where: RelationshipMemberScalarWhereInput
    data: XOR<RelationshipMemberUpdateManyMutationInput, RelationshipMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type RelationshipMemberScalarWhereInput = {
    AND?: RelationshipMemberScalarWhereInput | RelationshipMemberScalarWhereInput[]
    OR?: RelationshipMemberScalarWhereInput[]
    NOT?: RelationshipMemberScalarWhereInput | RelationshipMemberScalarWhereInput[]
    id?: StringFilter<"RelationshipMember"> | string
    relationshipId?: StringFilter<"RelationshipMember"> | string
    userId?: StringFilter<"RelationshipMember"> | string
    role?: StringNullableFilter<"RelationshipMember"> | string | null
    leftAt?: DateTimeNullableFilter<"RelationshipMember"> | Date | string | null
    joinedAt?: DateTimeNullableFilter<"RelationshipMember"> | Date | string | null
    createdAt?: DateTimeFilter<"RelationshipMember"> | Date | string
    updatedAt?: DateTimeFilter<"RelationshipMember"> | Date | string
  }

  export type InviteUpsertWithWhereUniqueWithoutSenderInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutSenderInput, InviteUncheckedUpdateWithoutSenderInput>
    create: XOR<InviteCreateWithoutSenderInput, InviteUncheckedCreateWithoutSenderInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutSenderInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutSenderInput, InviteUncheckedUpdateWithoutSenderInput>
  }

  export type InviteUpdateManyWithWhereWithoutSenderInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutSenderInput>
  }

  export type InviteScalarWhereInput = {
    AND?: InviteScalarWhereInput | InviteScalarWhereInput[]
    OR?: InviteScalarWhereInput[]
    NOT?: InviteScalarWhereInput | InviteScalarWhereInput[]
    id?: StringFilter<"Invite"> | string
    code?: StringFilter<"Invite"> | string
    relationshipId?: StringFilter<"Invite"> | string
    invitedBy?: StringFilter<"Invite"> | string
    email?: StringNullableFilter<"Invite"> | string | null
    status?: EnumInviteStatusFilter<"Invite"> | $Enums.InviteStatus
    expiresAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    claimedBy?: StringNullableFilter<"Invite"> | string | null
    claimedAt?: DateTimeNullableFilter<"Invite"> | Date | string | null
    createdAt?: DateTimeFilter<"Invite"> | Date | string
    updatedAt?: DateTimeFilter<"Invite"> | Date | string
  }

  export type ResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: ResponseWhereUniqueInput
    update: XOR<ResponseUpdateWithoutUserInput, ResponseUncheckedUpdateWithoutUserInput>
    create: XOR<ResponseCreateWithoutUserInput, ResponseUncheckedCreateWithoutUserInput>
  }

  export type ResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: ResponseWhereUniqueInput
    data: XOR<ResponseUpdateWithoutUserInput, ResponseUncheckedUpdateWithoutUserInput>
  }

  export type ResponseUpdateManyWithWhereWithoutUserInput = {
    where: ResponseScalarWhereInput
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type ResponseScalarWhereInput = {
    AND?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
    OR?: ResponseScalarWhereInput[]
    NOT?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
    id?: StringFilter<"Response"> | string
    sessionId?: StringFilter<"Response"> | string
    userId?: StringFilter<"Response"> | string
    content?: StringNullableFilter<"Response"> | string | null
    createdAt?: DateTimeFilter<"Response"> | Date | string
    updatedAt?: DateTimeFilter<"Response"> | Date | string
  }

  export type ReflectionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReflectionWhereUniqueInput
    update: XOR<ReflectionUpdateWithoutUserInput, ReflectionUncheckedUpdateWithoutUserInput>
    create: XOR<ReflectionCreateWithoutUserInput, ReflectionUncheckedCreateWithoutUserInput>
  }

  export type ReflectionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReflectionWhereUniqueInput
    data: XOR<ReflectionUpdateWithoutUserInput, ReflectionUncheckedUpdateWithoutUserInput>
  }

  export type ReflectionUpdateManyWithWhereWithoutUserInput = {
    where: ReflectionScalarWhereInput
    data: XOR<ReflectionUpdateManyMutationInput, ReflectionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReflectionScalarWhereInput = {
    AND?: ReflectionScalarWhereInput | ReflectionScalarWhereInput[]
    OR?: ReflectionScalarWhereInput[]
    NOT?: ReflectionScalarWhereInput | ReflectionScalarWhereInput[]
    id?: StringFilter<"Reflection"> | string
    sessionId?: StringFilter<"Reflection"> | string
    userId?: StringFilter<"Reflection"> | string
    content?: StringNullableFilter<"Reflection"> | string | null
    reaction?: StringNullableFilter<"Reflection"> | string | null
    createdAt?: DateTimeFilter<"Reflection"> | Date | string
    updatedAt?: DateTimeFilter<"Reflection"> | Date | string
  }

  export type ResponseValidationUpsertWithWhereUniqueWithoutUserInput = {
    where: ResponseValidationWhereUniqueInput
    update: XOR<ResponseValidationUpdateWithoutUserInput, ResponseValidationUncheckedUpdateWithoutUserInput>
    create: XOR<ResponseValidationCreateWithoutUserInput, ResponseValidationUncheckedCreateWithoutUserInput>
  }

  export type ResponseValidationUpdateWithWhereUniqueWithoutUserInput = {
    where: ResponseValidationWhereUniqueInput
    data: XOR<ResponseValidationUpdateWithoutUserInput, ResponseValidationUncheckedUpdateWithoutUserInput>
  }

  export type ResponseValidationUpdateManyWithWhereWithoutUserInput = {
    where: ResponseValidationScalarWhereInput
    data: XOR<ResponseValidationUpdateManyMutationInput, ResponseValidationUncheckedUpdateManyWithoutUserInput>
  }

  export type ResponseValidationScalarWhereInput = {
    AND?: ResponseValidationScalarWhereInput | ResponseValidationScalarWhereInput[]
    OR?: ResponseValidationScalarWhereInput[]
    NOT?: ResponseValidationScalarWhereInput | ResponseValidationScalarWhereInput[]
    id?: StringFilter<"ResponseValidation"> | string
    responseId?: StringFilter<"ResponseValidation"> | string
    userId?: StringFilter<"ResponseValidation"> | string
    reactions?: StringNullableFilter<"ResponseValidation"> | string | null
    acknowledgment?: StringNullableFilter<"ResponseValidation"> | string | null
  }

  export type QuizParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizParticipationWhereUniqueInput
    update: XOR<QuizParticipationUpdateWithoutUserInput, QuizParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<QuizParticipationCreateWithoutUserInput, QuizParticipationUncheckedCreateWithoutUserInput>
  }

  export type QuizParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizParticipationWhereUniqueInput
    data: XOR<QuizParticipationUpdateWithoutUserInput, QuizParticipationUncheckedUpdateWithoutUserInput>
  }

  export type QuizParticipationUpdateManyWithWhereWithoutUserInput = {
    where: QuizParticipationScalarWhereInput
    data: XOR<QuizParticipationUpdateManyMutationInput, QuizParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizParticipationScalarWhereInput = {
    AND?: QuizParticipationScalarWhereInput | QuizParticipationScalarWhereInput[]
    OR?: QuizParticipationScalarWhereInput[]
    NOT?: QuizParticipationScalarWhereInput | QuizParticipationScalarWhereInput[]
    id?: StringFilter<"QuizParticipation"> | string
    quizSessionId?: StringFilter<"QuizParticipation"> | string
    userId?: StringFilter<"QuizParticipation"> | string
    answerIndices?: StringFilter<"QuizParticipation"> | string
    guessIndices?: StringFilter<"QuizParticipation"> | string
    createdAt?: DateTimeFilter<"QuizParticipation"> | Date | string
    updatedAt?: DateTimeFilter<"QuizParticipation"> | Date | string
  }

  export type AgreementParticipationUpsertWithWhereUniqueWithoutUserInput = {
    where: AgreementParticipationWhereUniqueInput
    update: XOR<AgreementParticipationUpdateWithoutUserInput, AgreementParticipationUncheckedUpdateWithoutUserInput>
    create: XOR<AgreementParticipationCreateWithoutUserInput, AgreementParticipationUncheckedCreateWithoutUserInput>
  }

  export type AgreementParticipationUpdateWithWhereUniqueWithoutUserInput = {
    where: AgreementParticipationWhereUniqueInput
    data: XOR<AgreementParticipationUpdateWithoutUserInput, AgreementParticipationUncheckedUpdateWithoutUserInput>
  }

  export type AgreementParticipationUpdateManyWithWhereWithoutUserInput = {
    where: AgreementParticipationScalarWhereInput
    data: XOR<AgreementParticipationUpdateManyMutationInput, AgreementParticipationUncheckedUpdateManyWithoutUserInput>
  }

  export type AgreementParticipationScalarWhereInput = {
    AND?: AgreementParticipationScalarWhereInput | AgreementParticipationScalarWhereInput[]
    OR?: AgreementParticipationScalarWhereInput[]
    NOT?: AgreementParticipationScalarWhereInput | AgreementParticipationScalarWhereInput[]
    id?: StringFilter<"AgreementParticipation"> | string
    agreementSessionId?: StringFilter<"AgreementParticipation"> | string
    userId?: StringFilter<"AgreementParticipation"> | string
    answerIndices?: StringFilter<"AgreementParticipation"> | string
    guessIndices?: StringFilter<"AgreementParticipation"> | string
    createdAt?: DateTimeFilter<"AgreementParticipation"> | Date | string
    updatedAt?: DateTimeFilter<"AgreementParticipation"> | Date | string
  }

  export type MeetingEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: MeetingEntryWhereUniqueInput
    update: XOR<MeetingEntryUpdateWithoutUserInput, MeetingEntryUncheckedUpdateWithoutUserInput>
    create: XOR<MeetingEntryCreateWithoutUserInput, MeetingEntryUncheckedCreateWithoutUserInput>
  }

  export type MeetingEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: MeetingEntryWhereUniqueInput
    data: XOR<MeetingEntryUpdateWithoutUserInput, MeetingEntryUncheckedUpdateWithoutUserInput>
  }

  export type MeetingEntryUpdateManyWithWhereWithoutUserInput = {
    where: MeetingEntryScalarWhereInput
    data: XOR<MeetingEntryUpdateManyMutationInput, MeetingEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type MeetingEntryScalarWhereInput = {
    AND?: MeetingEntryScalarWhereInput | MeetingEntryScalarWhereInput[]
    OR?: MeetingEntryScalarWhereInput[]
    NOT?: MeetingEntryScalarWhereInput | MeetingEntryScalarWhereInput[]
    id?: StringFilter<"MeetingEntry"> | string
    meetingId?: StringFilter<"MeetingEntry"> | string
    userId?: StringFilter<"MeetingEntry"> | string
    wins?: StringNullableFilter<"MeetingEntry"> | string | null
    stressors?: StringNullableFilter<"MeetingEntry"> | string | null
    request?: StringNullableFilter<"MeetingEntry"> | string | null
    plan?: StringNullableFilter<"MeetingEntry"> | string | null
    appreciation?: StringNullableFilter<"MeetingEntry"> | string | null
    createdAt?: DateTimeFilter<"MeetingEntry"> | Date | string
    updatedAt?: DateTimeFilter<"MeetingEntry"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<SubscriptionCreateWithoutUserInput, SubscriptionUncheckedCreateWithoutUserInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutUserInput, SubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    userId?: StringFilter<"Subscription"> | string
    relationshipId?: StringNullableFilter<"Subscription"> | string | null
    stripeSubscriptionId?: StringNullableFilter<"Subscription"> | string | null
    stripeCustomerId?: StringNullableFilter<"Subscription"> | string | null
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    currentPeriodEnd?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"Subscription"> | boolean
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RelationshipMemberCreateWithoutRelationshipInput = {
    id?: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRelationshipMembersInput
  }

  export type RelationshipMemberUncheckedCreateWithoutRelationshipInput = {
    id?: string
    userId: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelationshipMemberCreateOrConnectWithoutRelationshipInput = {
    where: RelationshipMemberWhereUniqueInput
    create: XOR<RelationshipMemberCreateWithoutRelationshipInput, RelationshipMemberUncheckedCreateWithoutRelationshipInput>
  }

  export type RelationshipMemberCreateManyRelationshipInputEnvelope = {
    data: RelationshipMemberCreateManyRelationshipInput | RelationshipMemberCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type InviteCreateWithoutRelationshipInput = {
    id?: string
    code: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutInvitesSentInput
  }

  export type InviteUncheckedCreateWithoutRelationshipInput = {
    id?: string
    code: string
    invitedBy: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateOrConnectWithoutRelationshipInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutRelationshipInput, InviteUncheckedCreateWithoutRelationshipInput>
  }

  export type InviteCreateManyRelationshipInputEnvelope = {
    data: InviteCreateManyRelationshipInput | InviteCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type DailySessionCreateWithoutRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    prompt?: PromptCreateNestedOneWithoutDailySessionsInput
    responses?: ResponseCreateNestedManyWithoutSessionInput
    reflections?: ReflectionCreateNestedManyWithoutSessionInput
  }

  export type DailySessionUncheckedCreateWithoutRelationshipInput = {
    id?: string
    sessionDate: Date | string
    promptId?: string | null
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: ResponseUncheckedCreateNestedManyWithoutSessionInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DailySessionCreateOrConnectWithoutRelationshipInput = {
    where: DailySessionWhereUniqueInput
    create: XOR<DailySessionCreateWithoutRelationshipInput, DailySessionUncheckedCreateWithoutRelationshipInput>
  }

  export type DailySessionCreateManyRelationshipInputEnvelope = {
    data: DailySessionCreateManyRelationshipInput | DailySessionCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type QuizSessionCreateWithoutRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: QuizParticipationCreateNestedManyWithoutQuizSessionInput
  }

  export type QuizSessionUncheckedCreateWithoutRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: QuizParticipationUncheckedCreateNestedManyWithoutQuizSessionInput
  }

  export type QuizSessionCreateOrConnectWithoutRelationshipInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutRelationshipInput, QuizSessionUncheckedCreateWithoutRelationshipInput>
  }

  export type QuizSessionCreateManyRelationshipInputEnvelope = {
    data: QuizSessionCreateManyRelationshipInput | QuizSessionCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type AgreementSessionCreateWithoutRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: AgreementParticipationCreateNestedManyWithoutAgreementSessionInput
  }

  export type AgreementSessionUncheckedCreateWithoutRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
    participations?: AgreementParticipationUncheckedCreateNestedManyWithoutAgreementSessionInput
  }

  export type AgreementSessionCreateOrConnectWithoutRelationshipInput = {
    where: AgreementSessionWhereUniqueInput
    create: XOR<AgreementSessionCreateWithoutRelationshipInput, AgreementSessionUncheckedCreateWithoutRelationshipInput>
  }

  export type AgreementSessionCreateManyRelationshipInputEnvelope = {
    data: AgreementSessionCreateManyRelationshipInput | AgreementSessionCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type MeetingCreateWithoutRelationshipInput = {
    id?: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: MeetingEntryCreateNestedManyWithoutMeetingInput
  }

  export type MeetingUncheckedCreateWithoutRelationshipInput = {
    id?: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entries?: MeetingEntryUncheckedCreateNestedManyWithoutMeetingInput
  }

  export type MeetingCreateOrConnectWithoutRelationshipInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutRelationshipInput, MeetingUncheckedCreateWithoutRelationshipInput>
  }

  export type MeetingCreateManyRelationshipInputEnvelope = {
    data: MeetingCreateManyRelationshipInput | MeetingCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type StreakCreateWithoutRelationshipInput = {
    currentCount?: number
    longestCount?: number
    lastCompletedDate?: Date | string | null
  }

  export type StreakUncheckedCreateWithoutRelationshipInput = {
    currentCount?: number
    longestCount?: number
    lastCompletedDate?: Date | string | null
  }

  export type StreakCreateOrConnectWithoutRelationshipInput = {
    where: StreakWhereUniqueInput
    create: XOR<StreakCreateWithoutRelationshipInput, StreakUncheckedCreateWithoutRelationshipInput>
  }

  export type SubscriptionCreateWithoutRelationshipInput = {
    id?: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutRelationshipInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutRelationshipInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutRelationshipInput, SubscriptionUncheckedCreateWithoutRelationshipInput>
  }

  export type SubscriptionCreateManyRelationshipInputEnvelope = {
    data: SubscriptionCreateManyRelationshipInput | SubscriptionCreateManyRelationshipInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipMemberUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: RelationshipMemberWhereUniqueInput
    update: XOR<RelationshipMemberUpdateWithoutRelationshipInput, RelationshipMemberUncheckedUpdateWithoutRelationshipInput>
    create: XOR<RelationshipMemberCreateWithoutRelationshipInput, RelationshipMemberUncheckedCreateWithoutRelationshipInput>
  }

  export type RelationshipMemberUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: RelationshipMemberWhereUniqueInput
    data: XOR<RelationshipMemberUpdateWithoutRelationshipInput, RelationshipMemberUncheckedUpdateWithoutRelationshipInput>
  }

  export type RelationshipMemberUpdateManyWithWhereWithoutRelationshipInput = {
    where: RelationshipMemberScalarWhereInput
    data: XOR<RelationshipMemberUpdateManyMutationInput, RelationshipMemberUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type InviteUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutRelationshipInput, InviteUncheckedUpdateWithoutRelationshipInput>
    create: XOR<InviteCreateWithoutRelationshipInput, InviteUncheckedCreateWithoutRelationshipInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutRelationshipInput, InviteUncheckedUpdateWithoutRelationshipInput>
  }

  export type InviteUpdateManyWithWhereWithoutRelationshipInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type DailySessionUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: DailySessionWhereUniqueInput
    update: XOR<DailySessionUpdateWithoutRelationshipInput, DailySessionUncheckedUpdateWithoutRelationshipInput>
    create: XOR<DailySessionCreateWithoutRelationshipInput, DailySessionUncheckedCreateWithoutRelationshipInput>
  }

  export type DailySessionUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: DailySessionWhereUniqueInput
    data: XOR<DailySessionUpdateWithoutRelationshipInput, DailySessionUncheckedUpdateWithoutRelationshipInput>
  }

  export type DailySessionUpdateManyWithWhereWithoutRelationshipInput = {
    where: DailySessionScalarWhereInput
    data: XOR<DailySessionUpdateManyMutationInput, DailySessionUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type DailySessionScalarWhereInput = {
    AND?: DailySessionScalarWhereInput | DailySessionScalarWhereInput[]
    OR?: DailySessionScalarWhereInput[]
    NOT?: DailySessionScalarWhereInput | DailySessionScalarWhereInput[]
    id?: StringFilter<"DailySession"> | string
    relationshipId?: StringFilter<"DailySession"> | string
    sessionDate?: DateTimeFilter<"DailySession"> | Date | string
    promptId?: StringNullableFilter<"DailySession"> | string | null
    state?: EnumSessionStateFilter<"DailySession"> | $Enums.SessionState
    createdAt?: DateTimeFilter<"DailySession"> | Date | string
    updatedAt?: DateTimeFilter<"DailySession"> | Date | string
  }

  export type QuizSessionUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: QuizSessionWhereUniqueInput
    update: XOR<QuizSessionUpdateWithoutRelationshipInput, QuizSessionUncheckedUpdateWithoutRelationshipInput>
    create: XOR<QuizSessionCreateWithoutRelationshipInput, QuizSessionUncheckedCreateWithoutRelationshipInput>
  }

  export type QuizSessionUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: QuizSessionWhereUniqueInput
    data: XOR<QuizSessionUpdateWithoutRelationshipInput, QuizSessionUncheckedUpdateWithoutRelationshipInput>
  }

  export type QuizSessionUpdateManyWithWhereWithoutRelationshipInput = {
    where: QuizSessionScalarWhereInput
    data: XOR<QuizSessionUpdateManyMutationInput, QuizSessionUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type QuizSessionScalarWhereInput = {
    AND?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
    OR?: QuizSessionScalarWhereInput[]
    NOT?: QuizSessionScalarWhereInput | QuizSessionScalarWhereInput[]
    id?: StringFilter<"QuizSession"> | string
    relationshipId?: StringFilter<"QuizSession"> | string
    sessionDate?: DateTimeFilter<"QuizSession"> | Date | string
    state?: EnumQuizStateFilter<"QuizSession"> | $Enums.QuizState
    createdAt?: DateTimeFilter<"QuizSession"> | Date | string
    updatedAt?: DateTimeFilter<"QuizSession"> | Date | string
  }

  export type AgreementSessionUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: AgreementSessionWhereUniqueInput
    update: XOR<AgreementSessionUpdateWithoutRelationshipInput, AgreementSessionUncheckedUpdateWithoutRelationshipInput>
    create: XOR<AgreementSessionCreateWithoutRelationshipInput, AgreementSessionUncheckedCreateWithoutRelationshipInput>
  }

  export type AgreementSessionUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: AgreementSessionWhereUniqueInput
    data: XOR<AgreementSessionUpdateWithoutRelationshipInput, AgreementSessionUncheckedUpdateWithoutRelationshipInput>
  }

  export type AgreementSessionUpdateManyWithWhereWithoutRelationshipInput = {
    where: AgreementSessionScalarWhereInput
    data: XOR<AgreementSessionUpdateManyMutationInput, AgreementSessionUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type AgreementSessionScalarWhereInput = {
    AND?: AgreementSessionScalarWhereInput | AgreementSessionScalarWhereInput[]
    OR?: AgreementSessionScalarWhereInput[]
    NOT?: AgreementSessionScalarWhereInput | AgreementSessionScalarWhereInput[]
    id?: StringFilter<"AgreementSession"> | string
    relationshipId?: StringFilter<"AgreementSession"> | string
    sessionDate?: DateTimeFilter<"AgreementSession"> | Date | string
    state?: EnumAgreementStateFilter<"AgreementSession"> | $Enums.AgreementState
    createdAt?: DateTimeFilter<"AgreementSession"> | Date | string
    updatedAt?: DateTimeFilter<"AgreementSession"> | Date | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutRelationshipInput, MeetingUncheckedUpdateWithoutRelationshipInput>
    create: XOR<MeetingCreateWithoutRelationshipInput, MeetingUncheckedCreateWithoutRelationshipInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutRelationshipInput, MeetingUncheckedUpdateWithoutRelationshipInput>
  }

  export type MeetingUpdateManyWithWhereWithoutRelationshipInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: StringFilter<"Meeting"> | string
    relationshipId?: StringFilter<"Meeting"> | string
    weekKey?: StringFilter<"Meeting"> | string
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
  }

  export type StreakUpsertWithoutRelationshipInput = {
    update: XOR<StreakUpdateWithoutRelationshipInput, StreakUncheckedUpdateWithoutRelationshipInput>
    create: XOR<StreakCreateWithoutRelationshipInput, StreakUncheckedCreateWithoutRelationshipInput>
    where?: StreakWhereInput
  }

  export type StreakUpdateToOneWithWhereWithoutRelationshipInput = {
    where?: StreakWhereInput
    data: XOR<StreakUpdateWithoutRelationshipInput, StreakUncheckedUpdateWithoutRelationshipInput>
  }

  export type StreakUpdateWithoutRelationshipInput = {
    currentCount?: IntFieldUpdateOperationsInput | number
    longestCount?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StreakUncheckedUpdateWithoutRelationshipInput = {
    currentCount?: IntFieldUpdateOperationsInput | number
    longestCount?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutRelationshipInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutRelationshipInput, SubscriptionUncheckedUpdateWithoutRelationshipInput>
    create: XOR<SubscriptionCreateWithoutRelationshipInput, SubscriptionUncheckedCreateWithoutRelationshipInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutRelationshipInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutRelationshipInput, SubscriptionUncheckedUpdateWithoutRelationshipInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutRelationshipInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutRelationshipInput>
  }

  export type RelationshipCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutMembersInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutMembersInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutMembersInput, RelationshipUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutRelationshipMembersInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRelationshipMembersInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRelationshipMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRelationshipMembersInput, UserUncheckedCreateWithoutRelationshipMembersInput>
  }

  export type RelationshipUpsertWithoutMembersInput = {
    update: XOR<RelationshipUpdateWithoutMembersInput, RelationshipUncheckedUpdateWithoutMembersInput>
    create: XOR<RelationshipCreateWithoutMembersInput, RelationshipUncheckedCreateWithoutMembersInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutMembersInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutMembersInput, RelationshipUncheckedUpdateWithoutMembersInput>
  }

  export type RelationshipUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type UserUpsertWithoutRelationshipMembersInput = {
    update: XOR<UserUpdateWithoutRelationshipMembersInput, UserUncheckedUpdateWithoutRelationshipMembersInput>
    create: XOR<UserCreateWithoutRelationshipMembersInput, UserUncheckedCreateWithoutRelationshipMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRelationshipMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRelationshipMembersInput, UserUncheckedUpdateWithoutRelationshipMembersInput>
  }

  export type UserUpdateWithoutRelationshipMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRelationshipMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RelationshipCreateWithoutInvitesInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutInvitesInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutInvitesInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutInvitesInput, RelationshipUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutInvitesSentInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitesSentInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
  }

  export type RelationshipUpsertWithoutInvitesInput = {
    update: XOR<RelationshipUpdateWithoutInvitesInput, RelationshipUncheckedUpdateWithoutInvitesInput>
    create: XOR<RelationshipCreateWithoutInvitesInput, RelationshipUncheckedCreateWithoutInvitesInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutInvitesInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutInvitesInput, RelationshipUncheckedUpdateWithoutInvitesInput>
  }

  export type RelationshipUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type UserUpsertWithoutInvitesSentInput = {
    update: XOR<UserUpdateWithoutInvitesSentInput, UserUncheckedUpdateWithoutInvitesSentInput>
    create: XOR<UserCreateWithoutInvitesSentInput, UserUncheckedCreateWithoutInvitesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitesSentInput, UserUncheckedUpdateWithoutInvitesSentInput>
  }

  export type UserUpdateWithoutInvitesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitesSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DailySessionCreateWithoutPromptInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutDailySessionsInput
    responses?: ResponseCreateNestedManyWithoutSessionInput
    reflections?: ReflectionCreateNestedManyWithoutSessionInput
  }

  export type DailySessionUncheckedCreateWithoutPromptInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: ResponseUncheckedCreateNestedManyWithoutSessionInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DailySessionCreateOrConnectWithoutPromptInput = {
    where: DailySessionWhereUniqueInput
    create: XOR<DailySessionCreateWithoutPromptInput, DailySessionUncheckedCreateWithoutPromptInput>
  }

  export type DailySessionCreateManyPromptInputEnvelope = {
    data: DailySessionCreateManyPromptInput | DailySessionCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type DailySessionUpsertWithWhereUniqueWithoutPromptInput = {
    where: DailySessionWhereUniqueInput
    update: XOR<DailySessionUpdateWithoutPromptInput, DailySessionUncheckedUpdateWithoutPromptInput>
    create: XOR<DailySessionCreateWithoutPromptInput, DailySessionUncheckedCreateWithoutPromptInput>
  }

  export type DailySessionUpdateWithWhereUniqueWithoutPromptInput = {
    where: DailySessionWhereUniqueInput
    data: XOR<DailySessionUpdateWithoutPromptInput, DailySessionUncheckedUpdateWithoutPromptInput>
  }

  export type DailySessionUpdateManyWithWhereWithoutPromptInput = {
    where: DailySessionScalarWhereInput
    data: XOR<DailySessionUpdateManyMutationInput, DailySessionUncheckedUpdateManyWithoutPromptInput>
  }

  export type RelationshipCreateWithoutDailySessionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutDailySessionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutDailySessionsInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutDailySessionsInput, RelationshipUncheckedCreateWithoutDailySessionsInput>
  }

  export type PromptCreateWithoutDailySessionsInput = {
    id?: string
    text: string
    momentText?: string | null
    type: $Enums.PromptType
    category: $Enums.PromptCategory
    tone?: $Enums.PromptTone | null
    isPremium?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptUncheckedCreateWithoutDailySessionsInput = {
    id?: string
    text: string
    momentText?: string | null
    type: $Enums.PromptType
    category: $Enums.PromptCategory
    tone?: $Enums.PromptTone | null
    isPremium?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromptCreateOrConnectWithoutDailySessionsInput = {
    where: PromptWhereUniqueInput
    create: XOR<PromptCreateWithoutDailySessionsInput, PromptUncheckedCreateWithoutDailySessionsInput>
  }

  export type ResponseCreateWithoutSessionInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutResponsesInput
    validations?: ResponseValidationCreateNestedManyWithoutResponseInput
  }

  export type ResponseUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    validations?: ResponseValidationUncheckedCreateNestedManyWithoutResponseInput
  }

  export type ResponseCreateOrConnectWithoutSessionInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutSessionInput, ResponseUncheckedCreateWithoutSessionInput>
  }

  export type ResponseCreateManySessionInputEnvelope = {
    data: ResponseCreateManySessionInput | ResponseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ReflectionCreateWithoutSessionInput = {
    id?: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReflectionsInput
  }

  export type ReflectionUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReflectionCreateOrConnectWithoutSessionInput = {
    where: ReflectionWhereUniqueInput
    create: XOR<ReflectionCreateWithoutSessionInput, ReflectionUncheckedCreateWithoutSessionInput>
  }

  export type ReflectionCreateManySessionInputEnvelope = {
    data: ReflectionCreateManySessionInput | ReflectionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipUpsertWithoutDailySessionsInput = {
    update: XOR<RelationshipUpdateWithoutDailySessionsInput, RelationshipUncheckedUpdateWithoutDailySessionsInput>
    create: XOR<RelationshipCreateWithoutDailySessionsInput, RelationshipUncheckedCreateWithoutDailySessionsInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutDailySessionsInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutDailySessionsInput, RelationshipUncheckedUpdateWithoutDailySessionsInput>
  }

  export type RelationshipUpdateWithoutDailySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutDailySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type PromptUpsertWithoutDailySessionsInput = {
    update: XOR<PromptUpdateWithoutDailySessionsInput, PromptUncheckedUpdateWithoutDailySessionsInput>
    create: XOR<PromptCreateWithoutDailySessionsInput, PromptUncheckedCreateWithoutDailySessionsInput>
    where?: PromptWhereInput
  }

  export type PromptUpdateToOneWithWhereWithoutDailySessionsInput = {
    where?: PromptWhereInput
    data: XOR<PromptUpdateWithoutDailySessionsInput, PromptUncheckedUpdateWithoutDailySessionsInput>
  }

  export type PromptUpdateWithoutDailySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    momentText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    category?: EnumPromptCategoryFieldUpdateOperationsInput | $Enums.PromptCategory
    tone?: NullableEnumPromptToneFieldUpdateOperationsInput | $Enums.PromptTone | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromptUncheckedUpdateWithoutDailySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    momentText?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    category?: EnumPromptCategoryFieldUpdateOperationsInput | $Enums.PromptCategory
    tone?: NullableEnumPromptToneFieldUpdateOperationsInput | $Enums.PromptTone | null
    isPremium?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUpsertWithWhereUniqueWithoutSessionInput = {
    where: ResponseWhereUniqueInput
    update: XOR<ResponseUpdateWithoutSessionInput, ResponseUncheckedUpdateWithoutSessionInput>
    create: XOR<ResponseCreateWithoutSessionInput, ResponseUncheckedCreateWithoutSessionInput>
  }

  export type ResponseUpdateWithWhereUniqueWithoutSessionInput = {
    where: ResponseWhereUniqueInput
    data: XOR<ResponseUpdateWithoutSessionInput, ResponseUncheckedUpdateWithoutSessionInput>
  }

  export type ResponseUpdateManyWithWhereWithoutSessionInput = {
    where: ResponseScalarWhereInput
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyWithoutSessionInput>
  }

  export type ReflectionUpsertWithWhereUniqueWithoutSessionInput = {
    where: ReflectionWhereUniqueInput
    update: XOR<ReflectionUpdateWithoutSessionInput, ReflectionUncheckedUpdateWithoutSessionInput>
    create: XOR<ReflectionCreateWithoutSessionInput, ReflectionUncheckedCreateWithoutSessionInput>
  }

  export type ReflectionUpdateWithWhereUniqueWithoutSessionInput = {
    where: ReflectionWhereUniqueInput
    data: XOR<ReflectionUpdateWithoutSessionInput, ReflectionUncheckedUpdateWithoutSessionInput>
  }

  export type ReflectionUpdateManyWithWhereWithoutSessionInput = {
    where: ReflectionScalarWhereInput
    data: XOR<ReflectionUpdateManyMutationInput, ReflectionUncheckedUpdateManyWithoutSessionInput>
  }

  export type DailySessionCreateWithoutResponsesInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutDailySessionsInput
    prompt?: PromptCreateNestedOneWithoutDailySessionsInput
    reflections?: ReflectionCreateNestedManyWithoutSessionInput
  }

  export type DailySessionUncheckedCreateWithoutResponsesInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    promptId?: string | null
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    reflections?: ReflectionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DailySessionCreateOrConnectWithoutResponsesInput = {
    where: DailySessionWhereUniqueInput
    create: XOR<DailySessionCreateWithoutResponsesInput, DailySessionUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutResponsesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResponsesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
  }

  export type ResponseValidationCreateWithoutResponseInput = {
    id?: string
    reactions?: string | null
    acknowledgment?: string | null
    user: UserCreateNestedOneWithoutResponseValidationsInput
  }

  export type ResponseValidationUncheckedCreateWithoutResponseInput = {
    id?: string
    userId: string
    reactions?: string | null
    acknowledgment?: string | null
  }

  export type ResponseValidationCreateOrConnectWithoutResponseInput = {
    where: ResponseValidationWhereUniqueInput
    create: XOR<ResponseValidationCreateWithoutResponseInput, ResponseValidationUncheckedCreateWithoutResponseInput>
  }

  export type ResponseValidationCreateManyResponseInputEnvelope = {
    data: ResponseValidationCreateManyResponseInput | ResponseValidationCreateManyResponseInput[]
    skipDuplicates?: boolean
  }

  export type DailySessionUpsertWithoutResponsesInput = {
    update: XOR<DailySessionUpdateWithoutResponsesInput, DailySessionUncheckedUpdateWithoutResponsesInput>
    create: XOR<DailySessionCreateWithoutResponsesInput, DailySessionUncheckedCreateWithoutResponsesInput>
    where?: DailySessionWhereInput
  }

  export type DailySessionUpdateToOneWithWhereWithoutResponsesInput = {
    where?: DailySessionWhereInput
    data: XOR<DailySessionUpdateWithoutResponsesInput, DailySessionUncheckedUpdateWithoutResponsesInput>
  }

  export type DailySessionUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutDailySessionsNestedInput
    prompt?: PromptUpdateOneWithoutDailySessionsNestedInput
    reflections?: ReflectionUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reflections?: ReflectionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutResponsesInput = {
    update: XOR<UserUpdateWithoutResponsesInput, UserUncheckedUpdateWithoutResponsesInput>
    create: XOR<UserCreateWithoutResponsesInput, UserUncheckedCreateWithoutResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResponsesInput, UserUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResponseValidationUpsertWithWhereUniqueWithoutResponseInput = {
    where: ResponseValidationWhereUniqueInput
    update: XOR<ResponseValidationUpdateWithoutResponseInput, ResponseValidationUncheckedUpdateWithoutResponseInput>
    create: XOR<ResponseValidationCreateWithoutResponseInput, ResponseValidationUncheckedCreateWithoutResponseInput>
  }

  export type ResponseValidationUpdateWithWhereUniqueWithoutResponseInput = {
    where: ResponseValidationWhereUniqueInput
    data: XOR<ResponseValidationUpdateWithoutResponseInput, ResponseValidationUncheckedUpdateWithoutResponseInput>
  }

  export type ResponseValidationUpdateManyWithWhereWithoutResponseInput = {
    where: ResponseValidationScalarWhereInput
    data: XOR<ResponseValidationUpdateManyMutationInput, ResponseValidationUncheckedUpdateManyWithoutResponseInput>
  }

  export type ResponseCreateWithoutValidationsInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: DailySessionCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateWithoutValidationsInput = {
    id?: string
    sessionId: string
    userId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseCreateOrConnectWithoutValidationsInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutValidationsInput, ResponseUncheckedCreateWithoutValidationsInput>
  }

  export type UserCreateWithoutResponseValidationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResponseValidationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResponseValidationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponseValidationsInput, UserUncheckedCreateWithoutResponseValidationsInput>
  }

  export type ResponseUpsertWithoutValidationsInput = {
    update: XOR<ResponseUpdateWithoutValidationsInput, ResponseUncheckedUpdateWithoutValidationsInput>
    create: XOR<ResponseCreateWithoutValidationsInput, ResponseUncheckedCreateWithoutValidationsInput>
    where?: ResponseWhereInput
  }

  export type ResponseUpdateToOneWithWhereWithoutValidationsInput = {
    where?: ResponseWhereInput
    data: XOR<ResponseUpdateWithoutValidationsInput, ResponseUncheckedUpdateWithoutValidationsInput>
  }

  export type ResponseUpdateWithoutValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DailySessionUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateWithoutValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutResponseValidationsInput = {
    update: XOR<UserUpdateWithoutResponseValidationsInput, UserUncheckedUpdateWithoutResponseValidationsInput>
    create: XOR<UserCreateWithoutResponseValidationsInput, UserUncheckedCreateWithoutResponseValidationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResponseValidationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResponseValidationsInput, UserUncheckedUpdateWithoutResponseValidationsInput>
  }

  export type UserUpdateWithoutResponseValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResponseValidationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DailySessionCreateWithoutReflectionsInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutDailySessionsInput
    prompt?: PromptCreateNestedOneWithoutDailySessionsInput
    responses?: ResponseCreateNestedManyWithoutSessionInput
  }

  export type DailySessionUncheckedCreateWithoutReflectionsInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    promptId?: string | null
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: ResponseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type DailySessionCreateOrConnectWithoutReflectionsInput = {
    where: DailySessionWhereUniqueInput
    create: XOR<DailySessionCreateWithoutReflectionsInput, DailySessionUncheckedCreateWithoutReflectionsInput>
  }

  export type UserCreateWithoutReflectionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReflectionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReflectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReflectionsInput, UserUncheckedCreateWithoutReflectionsInput>
  }

  export type DailySessionUpsertWithoutReflectionsInput = {
    update: XOR<DailySessionUpdateWithoutReflectionsInput, DailySessionUncheckedUpdateWithoutReflectionsInput>
    create: XOR<DailySessionCreateWithoutReflectionsInput, DailySessionUncheckedCreateWithoutReflectionsInput>
    where?: DailySessionWhereInput
  }

  export type DailySessionUpdateToOneWithWhereWithoutReflectionsInput = {
    where?: DailySessionWhereInput
    data: XOR<DailySessionUpdateWithoutReflectionsInput, DailySessionUncheckedUpdateWithoutReflectionsInput>
  }

  export type DailySessionUpdateWithoutReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutDailySessionsNestedInput
    prompt?: PromptUpdateOneWithoutDailySessionsNestedInput
    responses?: ResponseUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateWithoutReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: ResponseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserUpsertWithoutReflectionsInput = {
    update: XOR<UserUpdateWithoutReflectionsInput, UserUncheckedUpdateWithoutReflectionsInput>
    create: XOR<UserCreateWithoutReflectionsInput, UserUncheckedCreateWithoutReflectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReflectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReflectionsInput, UserUncheckedUpdateWithoutReflectionsInput>
  }

  export type UserUpdateWithoutReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReflectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RelationshipCreateWithoutMeetingsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutMeetingsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutMeetingsInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutMeetingsInput, RelationshipUncheckedCreateWithoutMeetingsInput>
  }

  export type MeetingEntryCreateWithoutMeetingInput = {
    id?: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMeetingEntriesInput
  }

  export type MeetingEntryUncheckedCreateWithoutMeetingInput = {
    id?: string
    userId: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingEntryCreateOrConnectWithoutMeetingInput = {
    where: MeetingEntryWhereUniqueInput
    create: XOR<MeetingEntryCreateWithoutMeetingInput, MeetingEntryUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingEntryCreateManyMeetingInputEnvelope = {
    data: MeetingEntryCreateManyMeetingInput | MeetingEntryCreateManyMeetingInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipUpsertWithoutMeetingsInput = {
    update: XOR<RelationshipUpdateWithoutMeetingsInput, RelationshipUncheckedUpdateWithoutMeetingsInput>
    create: XOR<RelationshipCreateWithoutMeetingsInput, RelationshipUncheckedCreateWithoutMeetingsInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutMeetingsInput, RelationshipUncheckedUpdateWithoutMeetingsInput>
  }

  export type RelationshipUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutMeetingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type MeetingEntryUpsertWithWhereUniqueWithoutMeetingInput = {
    where: MeetingEntryWhereUniqueInput
    update: XOR<MeetingEntryUpdateWithoutMeetingInput, MeetingEntryUncheckedUpdateWithoutMeetingInput>
    create: XOR<MeetingEntryCreateWithoutMeetingInput, MeetingEntryUncheckedCreateWithoutMeetingInput>
  }

  export type MeetingEntryUpdateWithWhereUniqueWithoutMeetingInput = {
    where: MeetingEntryWhereUniqueInput
    data: XOR<MeetingEntryUpdateWithoutMeetingInput, MeetingEntryUncheckedUpdateWithoutMeetingInput>
  }

  export type MeetingEntryUpdateManyWithWhereWithoutMeetingInput = {
    where: MeetingEntryScalarWhereInput
    data: XOR<MeetingEntryUpdateManyMutationInput, MeetingEntryUncheckedUpdateManyWithoutMeetingInput>
  }

  export type MeetingCreateWithoutEntriesInput = {
    id?: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateWithoutEntriesInput = {
    id?: string
    relationshipId: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingCreateOrConnectWithoutEntriesInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutEntriesInput, MeetingUncheckedCreateWithoutEntriesInput>
  }

  export type UserCreateWithoutMeetingEntriesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMeetingEntriesInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMeetingEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeetingEntriesInput, UserUncheckedCreateWithoutMeetingEntriesInput>
  }

  export type MeetingUpsertWithoutEntriesInput = {
    update: XOR<MeetingUpdateWithoutEntriesInput, MeetingUncheckedUpdateWithoutEntriesInput>
    create: XOR<MeetingCreateWithoutEntriesInput, MeetingUncheckedCreateWithoutEntriesInput>
    where?: MeetingWhereInput
  }

  export type MeetingUpdateToOneWithWhereWithoutEntriesInput = {
    where?: MeetingWhereInput
    data: XOR<MeetingUpdateWithoutEntriesInput, MeetingUncheckedUpdateWithoutEntriesInput>
  }

  export type MeetingUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateWithoutEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutMeetingEntriesInput = {
    update: XOR<UserUpdateWithoutMeetingEntriesInput, UserUncheckedUpdateWithoutMeetingEntriesInput>
    create: XOR<UserCreateWithoutMeetingEntriesInput, UserUncheckedCreateWithoutMeetingEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeetingEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeetingEntriesInput, UserUncheckedUpdateWithoutMeetingEntriesInput>
  }

  export type UserUpdateWithoutMeetingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMeetingEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RelationshipCreateWithoutStreakInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutStreakInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutStreakInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutStreakInput, RelationshipUncheckedCreateWithoutStreakInput>
  }

  export type RelationshipUpsertWithoutStreakInput = {
    update: XOR<RelationshipUpdateWithoutStreakInput, RelationshipUncheckedUpdateWithoutStreakInput>
    create: XOR<RelationshipCreateWithoutStreakInput, RelationshipUncheckedCreateWithoutStreakInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutStreakInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutStreakInput, RelationshipUncheckedUpdateWithoutStreakInput>
  }

  export type RelationshipUpdateWithoutStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type UserCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
  }

  export type RelationshipCreateWithoutSubscriptionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutSubscriptionsInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutSubscriptionsInput, RelationshipUncheckedCreateWithoutSubscriptionsInput>
  }

  export type UserUpsertWithoutSubscriptionsInput = {
    update: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<UserCreateWithoutSubscriptionsInput, UserUncheckedCreateWithoutSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubscriptionsInput, UserUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type UserUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RelationshipUpsertWithoutSubscriptionsInput = {
    update: XOR<RelationshipUpdateWithoutSubscriptionsInput, RelationshipUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<RelationshipCreateWithoutSubscriptionsInput, RelationshipUncheckedCreateWithoutSubscriptionsInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutSubscriptionsInput, RelationshipUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type RelationshipUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
  }

  export type RelationshipCreateWithoutQuizSessionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutQuizSessionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    agreementSessions?: AgreementSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutQuizSessionsInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutQuizSessionsInput, RelationshipUncheckedCreateWithoutQuizSessionsInput>
  }

  export type QuizParticipationCreateWithoutQuizSessionInput = {
    id?: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutQuizParticipationsInput
  }

  export type QuizParticipationUncheckedCreateWithoutQuizSessionInput = {
    id?: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizParticipationCreateOrConnectWithoutQuizSessionInput = {
    where: QuizParticipationWhereUniqueInput
    create: XOR<QuizParticipationCreateWithoutQuizSessionInput, QuizParticipationUncheckedCreateWithoutQuizSessionInput>
  }

  export type QuizParticipationCreateManyQuizSessionInputEnvelope = {
    data: QuizParticipationCreateManyQuizSessionInput | QuizParticipationCreateManyQuizSessionInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipUpsertWithoutQuizSessionsInput = {
    update: XOR<RelationshipUpdateWithoutQuizSessionsInput, RelationshipUncheckedUpdateWithoutQuizSessionsInput>
    create: XOR<RelationshipCreateWithoutQuizSessionsInput, RelationshipUncheckedCreateWithoutQuizSessionsInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutQuizSessionsInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutQuizSessionsInput, RelationshipUncheckedUpdateWithoutQuizSessionsInput>
  }

  export type RelationshipUpdateWithoutQuizSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutQuizSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    agreementSessions?: AgreementSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type QuizParticipationUpsertWithWhereUniqueWithoutQuizSessionInput = {
    where: QuizParticipationWhereUniqueInput
    update: XOR<QuizParticipationUpdateWithoutQuizSessionInput, QuizParticipationUncheckedUpdateWithoutQuizSessionInput>
    create: XOR<QuizParticipationCreateWithoutQuizSessionInput, QuizParticipationUncheckedCreateWithoutQuizSessionInput>
  }

  export type QuizParticipationUpdateWithWhereUniqueWithoutQuizSessionInput = {
    where: QuizParticipationWhereUniqueInput
    data: XOR<QuizParticipationUpdateWithoutQuizSessionInput, QuizParticipationUncheckedUpdateWithoutQuizSessionInput>
  }

  export type QuizParticipationUpdateManyWithWhereWithoutQuizSessionInput = {
    where: QuizParticipationScalarWhereInput
    data: XOR<QuizParticipationUpdateManyMutationInput, QuizParticipationUncheckedUpdateManyWithoutQuizSessionInput>
  }

  export type QuizSessionCreateWithoutParticipationsInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutQuizSessionsInput
  }

  export type QuizSessionUncheckedCreateWithoutParticipationsInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSessionCreateOrConnectWithoutParticipationsInput = {
    where: QuizSessionWhereUniqueInput
    create: XOR<QuizSessionCreateWithoutParticipationsInput, QuizSessionUncheckedCreateWithoutParticipationsInput>
  }

  export type UserCreateWithoutQuizParticipationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizParticipationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    agreementParticipations?: AgreementParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizParticipationsInput, UserUncheckedCreateWithoutQuizParticipationsInput>
  }

  export type QuizSessionUpsertWithoutParticipationsInput = {
    update: XOR<QuizSessionUpdateWithoutParticipationsInput, QuizSessionUncheckedUpdateWithoutParticipationsInput>
    create: XOR<QuizSessionCreateWithoutParticipationsInput, QuizSessionUncheckedCreateWithoutParticipationsInput>
    where?: QuizSessionWhereInput
  }

  export type QuizSessionUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: QuizSessionWhereInput
    data: XOR<QuizSessionUpdateWithoutParticipationsInput, QuizSessionUncheckedUpdateWithoutParticipationsInput>
  }

  export type QuizSessionUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutQuizSessionsNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutQuizParticipationsInput = {
    update: XOR<UserUpdateWithoutQuizParticipationsInput, UserUncheckedUpdateWithoutQuizParticipationsInput>
    create: XOR<UserCreateWithoutQuizParticipationsInput, UserUncheckedCreateWithoutQuizParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizParticipationsInput, UserUncheckedUpdateWithoutQuizParticipationsInput>
  }

  export type UserUpdateWithoutQuizParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    agreementParticipations?: AgreementParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RelationshipCreateWithoutAgreementSessionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberCreateNestedManyWithoutRelationshipInput
    invites?: InviteCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingCreateNestedManyWithoutRelationshipInput
    streak?: StreakCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipUncheckedCreateWithoutAgreementSessionsInput = {
    id?: string
    name?: string | null
    status?: $Enums.RelationshipStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: RelationshipMemberUncheckedCreateNestedManyWithoutRelationshipInput
    invites?: InviteUncheckedCreateNestedManyWithoutRelationshipInput
    dailySessions?: DailySessionUncheckedCreateNestedManyWithoutRelationshipInput
    quizSessions?: QuizSessionUncheckedCreateNestedManyWithoutRelationshipInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutRelationshipInput
    streak?: StreakUncheckedCreateNestedOneWithoutRelationshipInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutRelationshipInput
  }

  export type RelationshipCreateOrConnectWithoutAgreementSessionsInput = {
    where: RelationshipWhereUniqueInput
    create: XOR<RelationshipCreateWithoutAgreementSessionsInput, RelationshipUncheckedCreateWithoutAgreementSessionsInput>
  }

  export type AgreementParticipationCreateWithoutAgreementSessionInput = {
    id?: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAgreementParticipationsInput
  }

  export type AgreementParticipationUncheckedCreateWithoutAgreementSessionInput = {
    id?: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementParticipationCreateOrConnectWithoutAgreementSessionInput = {
    where: AgreementParticipationWhereUniqueInput
    create: XOR<AgreementParticipationCreateWithoutAgreementSessionInput, AgreementParticipationUncheckedCreateWithoutAgreementSessionInput>
  }

  export type AgreementParticipationCreateManyAgreementSessionInputEnvelope = {
    data: AgreementParticipationCreateManyAgreementSessionInput | AgreementParticipationCreateManyAgreementSessionInput[]
    skipDuplicates?: boolean
  }

  export type RelationshipUpsertWithoutAgreementSessionsInput = {
    update: XOR<RelationshipUpdateWithoutAgreementSessionsInput, RelationshipUncheckedUpdateWithoutAgreementSessionsInput>
    create: XOR<RelationshipCreateWithoutAgreementSessionsInput, RelationshipUncheckedCreateWithoutAgreementSessionsInput>
    where?: RelationshipWhereInput
  }

  export type RelationshipUpdateToOneWithWhereWithoutAgreementSessionsInput = {
    where?: RelationshipWhereInput
    data: XOR<RelationshipUpdateWithoutAgreementSessionsInput, RelationshipUncheckedUpdateWithoutAgreementSessionsInput>
  }

  export type RelationshipUpdateWithoutAgreementSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutRelationshipNestedInput
  }

  export type RelationshipUncheckedUpdateWithoutAgreementSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRelationshipStatusFieldUpdateOperationsInput | $Enums.RelationshipStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: RelationshipMemberUncheckedUpdateManyWithoutRelationshipNestedInput
    invites?: InviteUncheckedUpdateManyWithoutRelationshipNestedInput
    dailySessions?: DailySessionUncheckedUpdateManyWithoutRelationshipNestedInput
    quizSessions?: QuizSessionUncheckedUpdateManyWithoutRelationshipNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutRelationshipNestedInput
    streak?: StreakUncheckedUpdateOneWithoutRelationshipNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutRelationshipNestedInput
  }

  export type AgreementParticipationUpsertWithWhereUniqueWithoutAgreementSessionInput = {
    where: AgreementParticipationWhereUniqueInput
    update: XOR<AgreementParticipationUpdateWithoutAgreementSessionInput, AgreementParticipationUncheckedUpdateWithoutAgreementSessionInput>
    create: XOR<AgreementParticipationCreateWithoutAgreementSessionInput, AgreementParticipationUncheckedCreateWithoutAgreementSessionInput>
  }

  export type AgreementParticipationUpdateWithWhereUniqueWithoutAgreementSessionInput = {
    where: AgreementParticipationWhereUniqueInput
    data: XOR<AgreementParticipationUpdateWithoutAgreementSessionInput, AgreementParticipationUncheckedUpdateWithoutAgreementSessionInput>
  }

  export type AgreementParticipationUpdateManyWithWhereWithoutAgreementSessionInput = {
    where: AgreementParticipationScalarWhereInput
    data: XOR<AgreementParticipationUpdateManyMutationInput, AgreementParticipationUncheckedUpdateManyWithoutAgreementSessionInput>
  }

  export type AgreementSessionCreateWithoutParticipationsInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
    relationship: RelationshipCreateNestedOneWithoutAgreementSessionsInput
  }

  export type AgreementSessionUncheckedCreateWithoutParticipationsInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementSessionCreateOrConnectWithoutParticipationsInput = {
    where: AgreementSessionWhereUniqueInput
    create: XOR<AgreementSessionCreateWithoutParticipationsInput, AgreementSessionUncheckedCreateWithoutParticipationsInput>
  }

  export type UserCreateWithoutAgreementParticipationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberCreateNestedManyWithoutUserInput
    invitesSent?: InviteCreateNestedManyWithoutSenderInput
    responses?: ResponseCreateNestedManyWithoutUserInput
    reflections?: ReflectionCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgreementParticipationsInput = {
    id?: string
    email: string
    emailVerified?: Date | string | null
    name?: string | null
    image?: string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    relationshipMembers?: RelationshipMemberUncheckedCreateNestedManyWithoutUserInput
    invitesSent?: InviteUncheckedCreateNestedManyWithoutSenderInput
    responses?: ResponseUncheckedCreateNestedManyWithoutUserInput
    reflections?: ReflectionUncheckedCreateNestedManyWithoutUserInput
    responseValidations?: ResponseValidationUncheckedCreateNestedManyWithoutUserInput
    quizParticipations?: QuizParticipationUncheckedCreateNestedManyWithoutUserInput
    meetingEntries?: MeetingEntryUncheckedCreateNestedManyWithoutUserInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgreementParticipationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgreementParticipationsInput, UserUncheckedCreateWithoutAgreementParticipationsInput>
  }

  export type AgreementSessionUpsertWithoutParticipationsInput = {
    update: XOR<AgreementSessionUpdateWithoutParticipationsInput, AgreementSessionUncheckedUpdateWithoutParticipationsInput>
    create: XOR<AgreementSessionCreateWithoutParticipationsInput, AgreementSessionUncheckedCreateWithoutParticipationsInput>
    where?: AgreementSessionWhereInput
  }

  export type AgreementSessionUpdateToOneWithWhereWithoutParticipationsInput = {
    where?: AgreementSessionWhereInput
    data: XOR<AgreementSessionUpdateWithoutParticipationsInput, AgreementSessionUncheckedUpdateWithoutParticipationsInput>
  }

  export type AgreementSessionUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutAgreementSessionsNestedInput
  }

  export type AgreementSessionUncheckedUpdateWithoutParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutAgreementParticipationsInput = {
    update: XOR<UserUpdateWithoutAgreementParticipationsInput, UserUncheckedUpdateWithoutAgreementParticipationsInput>
    create: XOR<UserCreateWithoutAgreementParticipationsInput, UserUncheckedCreateWithoutAgreementParticipationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAgreementParticipationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAgreementParticipationsInput, UserUncheckedUpdateWithoutAgreementParticipationsInput>
  }

  export type UserUpdateWithoutAgreementParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUpdateManyWithoutSenderNestedInput
    responses?: ResponseUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgreementParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    relationshipMembers?: RelationshipMemberUncheckedUpdateManyWithoutUserNestedInput
    invitesSent?: InviteUncheckedUpdateManyWithoutSenderNestedInput
    responses?: ResponseUncheckedUpdateManyWithoutUserNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutUserNestedInput
    responseValidations?: ResponseValidationUncheckedUpdateManyWithoutUserNestedInput
    quizParticipations?: QuizParticipationUncheckedUpdateManyWithoutUserNestedInput
    meetingEntries?: MeetingEntryUncheckedUpdateManyWithoutUserNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type RelationshipMemberCreateManyUserInput = {
    id?: string
    relationshipId: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateManySenderInput = {
    id?: string
    code: string
    relationshipId: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseCreateManyUserInput = {
    id?: string
    sessionId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReflectionCreateManyUserInput = {
    id?: string
    sessionId: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseValidationCreateManyUserInput = {
    id?: string
    responseId: string
    reactions?: string | null
    acknowledgment?: string | null
  }

  export type QuizParticipationCreateManyUserInput = {
    id?: string
    quizSessionId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementParticipationCreateManyUserInput = {
    id?: string
    agreementSessionId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingEntryCreateManyUserInput = {
    id?: string
    meetingId: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyUserInput = {
    id?: string
    relationshipId?: string | null
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutMembersNestedInput
  }

  export type RelationshipMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type InviteUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DailySessionUpdateOneRequiredWithoutResponsesNestedInput
    validations?: ResponseValidationUpdateManyWithoutResponseNestedInput
  }

  export type ResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validations?: ResponseValidationUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type ResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReflectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: DailySessionUpdateOneRequiredWithoutReflectionsNestedInput
  }

  export type ReflectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReflectionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseValidationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: ResponseUpdateOneRequiredWithoutValidationsNestedInput
  }

  export type ResponseValidationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseValidationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizSession?: QuizSessionUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type QuizParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizSessionId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizSessionId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreementSession?: AgreementSessionUpdateOneRequiredWithoutParticipationsNestedInput
  }

  export type AgreementParticipationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementSessionId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementSessionId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meeting?: MeetingUpdateOneRequiredWithoutEntriesNestedInput
  }

  export type MeetingEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    meetingId?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberCreateManyRelationshipInput = {
    id?: string
    userId: string
    role?: string | null
    leftAt?: Date | string | null
    joinedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InviteCreateManyRelationshipInput = {
    id?: string
    code: string
    invitedBy: string
    email?: string | null
    status?: $Enums.InviteStatus
    expiresAt?: Date | string | null
    claimedBy?: string | null
    claimedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailySessionCreateManyRelationshipInput = {
    id?: string
    sessionDate: Date | string
    promptId?: string | null
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizSessionCreateManyRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.QuizState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementSessionCreateManyRelationshipInput = {
    id?: string
    sessionDate: Date | string
    state?: $Enums.AgreementState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingCreateManyRelationshipInput = {
    id?: string
    weekKey: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyRelationshipInput = {
    id?: string
    userId: string
    stripeSubscriptionId?: string | null
    stripeCustomerId?: string | null
    status: $Enums.SubscriptionStatus
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelationshipMemberUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRelationshipMembersNestedInput
  }

  export type RelationshipMemberUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelationshipMemberUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutInvitesSentNestedInput
  }

  export type InviteUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InviteUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    invitedBy?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimedBy?: NullableStringFieldUpdateOperationsInput | string | null
    claimedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailySessionUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: PromptUpdateOneWithoutDailySessionsNestedInput
    responses?: ResponseUpdateManyWithoutSessionNestedInput
    reflections?: ReflectionUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: ResponseUncheckedUpdateManyWithoutSessionNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    promptId?: NullableStringFieldUpdateOperationsInput | string | null
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizSessionUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: QuizParticipationUpdateManyWithoutQuizSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: QuizParticipationUncheckedUpdateManyWithoutQuizSessionNestedInput
  }

  export type QuizSessionUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumQuizStateFieldUpdateOperationsInput | $Enums.QuizState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementSessionUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: AgreementParticipationUpdateManyWithoutAgreementSessionNestedInput
  }

  export type AgreementSessionUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participations?: AgreementParticipationUncheckedUpdateManyWithoutAgreementSessionNestedInput
  }

  export type AgreementSessionUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumAgreementStateFieldUpdateOperationsInput | $Enums.AgreementState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: MeetingEntryUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entries?: MeetingEntryUncheckedUpdateManyWithoutMeetingNestedInput
  }

  export type MeetingUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyWithoutRelationshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailySessionCreateManyPromptInput = {
    id?: string
    relationshipId: string
    sessionDate: Date | string
    state?: $Enums.SessionState
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailySessionUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationship?: RelationshipUpdateOneRequiredWithoutDailySessionsNestedInput
    responses?: ResponseUpdateManyWithoutSessionNestedInput
    reflections?: ReflectionUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: ResponseUncheckedUpdateManyWithoutSessionNestedInput
    reflections?: ReflectionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type DailySessionUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationshipId?: StringFieldUpdateOperationsInput | string
    sessionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: EnumSessionStateFieldUpdateOperationsInput | $Enums.SessionState
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseCreateManySessionInput = {
    id?: string
    userId: string
    content?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReflectionCreateManySessionInput = {
    id?: string
    userId: string
    content?: string | null
    reaction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResponseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutResponsesNestedInput
    validations?: ResponseValidationUpdateManyWithoutResponseNestedInput
  }

  export type ResponseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    validations?: ResponseValidationUncheckedUpdateManyWithoutResponseNestedInput
  }

  export type ResponseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReflectionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReflectionsNestedInput
  }

  export type ReflectionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReflectionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    reaction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResponseValidationCreateManyResponseInput = {
    id?: string
    userId: string
    reactions?: string | null
    acknowledgment?: string | null
  }

  export type ResponseValidationUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutResponseValidationsNestedInput
  }

  export type ResponseValidationUncheckedUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseValidationUncheckedUpdateManyWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reactions?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MeetingEntryCreateManyMeetingInput = {
    id?: string
    userId: string
    wins?: string | null
    stressors?: string | null
    request?: string | null
    plan?: string | null
    appreciation?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingEntryUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMeetingEntriesNestedInput
  }

  export type MeetingEntryUncheckedUpdateWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingEntryUncheckedUpdateManyWithoutMeetingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    wins?: NullableStringFieldUpdateOperationsInput | string | null
    stressors?: NullableStringFieldUpdateOperationsInput | string | null
    request?: NullableStringFieldUpdateOperationsInput | string | null
    plan?: NullableStringFieldUpdateOperationsInput | string | null
    appreciation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizParticipationCreateManyQuizSessionInput = {
    id?: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizParticipationUpdateWithoutQuizSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutQuizParticipationsNestedInput
  }

  export type QuizParticipationUncheckedUpdateWithoutQuizSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizParticipationUncheckedUpdateManyWithoutQuizSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationCreateManyAgreementSessionInput = {
    id?: string
    userId: string
    answerIndices: string
    guessIndices: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgreementParticipationUpdateWithoutAgreementSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAgreementParticipationsNestedInput
  }

  export type AgreementParticipationUncheckedUpdateWithoutAgreementSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementParticipationUncheckedUpdateManyWithoutAgreementSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    answerIndices?: StringFieldUpdateOperationsInput | string
    guessIndices?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipCountOutputTypeDefaultArgs instead
     */
    export type RelationshipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptCountOutputTypeDefaultArgs instead
     */
    export type PromptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailySessionCountOutputTypeDefaultArgs instead
     */
    export type DailySessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailySessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResponseCountOutputTypeDefaultArgs instead
     */
    export type ResponseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResponseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingCountOutputTypeDefaultArgs instead
     */
    export type MeetingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizSessionCountOutputTypeDefaultArgs instead
     */
    export type QuizSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementSessionCountOutputTypeDefaultArgs instead
     */
    export type AgreementSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipDefaultArgs instead
     */
    export type RelationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationshipMemberDefaultArgs instead
     */
    export type RelationshipMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationshipMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteDefaultArgs instead
     */
    export type InviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromptDefaultArgs instead
     */
    export type PromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailySessionDefaultArgs instead
     */
    export type DailySessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailySessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResponseDefaultArgs instead
     */
    export type ResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResponseValidationDefaultArgs instead
     */
    export type ResponseValidationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResponseValidationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReflectionDefaultArgs instead
     */
    export type ReflectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReflectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingDefaultArgs instead
     */
    export type MeetingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeetingEntryDefaultArgs instead
     */
    export type MeetingEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeetingEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StreakDefaultArgs instead
     */
    export type StreakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StreakDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BetaSignupDefaultArgs instead
     */
    export type BetaSignupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BetaSignupDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizSessionDefaultArgs instead
     */
    export type QuizSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizParticipationDefaultArgs instead
     */
    export type QuizParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizParticipationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementSessionDefaultArgs instead
     */
    export type AgreementSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgreementParticipationDefaultArgs instead
     */
    export type AgreementParticipationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgreementParticipationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}